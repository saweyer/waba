// Text of project WabaTester.ntk written on 2/12/01 at 8:02 PM// Beginning of text file WabaTesterDefs.txt// WabaTester versionconstant kWabaTester 	:= "WabaTester";constant kFileName 		:= "wbtst";constant kVersionNum 	:= "1.0";constant kVersionInt	:= "10";constant kBetaVersion 	:= "o";// TO DO & RECENT CHANGES: moved to changes.txt// =========Print(kFileName & kVersionInt & kBetaVersion & ".pkg");DefineGlobalConstant('kAppTitle, kWabaTester && kVersionNum & kBetaVersion);Print(kAppTitle && DateNTime(Time()));Print([kAppName, kAppSymbol, kPackageName]);	// kPackageName used in :getPkgItemsDefineGlobalConstant('kWabaTesterSym, kAppSymbol);// =====DefineGlobalConstant('kClassEntry, { // format used in :setAppClasses	//name: /*string*/	nil,	not needed	class:  /*binary*/ 	nil,		offset: /*int*/		nil,	length: /*int*/		nil,});DefineGlobalConstant('kFileEntry, { // format for builtinFiles, inboxFiles, pkgFiles	appName:	/*string*/ 	nil,	appArgs: 	/*object*/	nil,	// string,frame,entryAlias,nil	appClasses: /*binary*/ 	nil,		appFormat: 	/*symbol*/	nil,	//appContext:	//appMainName:});DefineGlobalConstant('kFileEntrySort, /*int*/ func(/*fileEntry*/ entry1, /*fileEntry*/ entry2)begin	local int strcomp := StrCompare(entry1.appName, entry2.appName);	if strcomp=0	then SymbolCompareLex(entry1.appFormat, entry2.appFormat)	else strcomp;end);// file formatsDefineGlobalConstant('kPDB,		'pdb);	// PalmDefineGlobalConstant('kWRP, 	'wrp);	// WinCEDefineGlobalConstant('kJAR, 	'jar);	// JarDefineGlobalConstant('kCLASS, 	'class);// class(single)DefineGlobalConstant('kNTK, 	'ntk);	// ntk-generatedDefineGlobalConstant('kPKG, 	'pkg);	// Warp/Exegen-generated	!!!oDefineGlobalConstant('kFormats, [kJAR, kCLASS, kWRP, kPDB, kNTK, kPKG]); // used in getPkgItems  !!!o// file/header signaturesDefineGlobalConstant('kWarpSig,   "Wrp1");DefineglobalConstant('kJarLocSig, "PK\u00030004");DefineglobalConstant('kJarCenSig, "PK\u00010002");DefineglobalConstant('kJarEndSig, "PK\u00050006");DefineGlobalConstant('kBMPSig, 	  "BM");DefineGlobalConstant('kClassSig,  "\uCAFEBABE");// file offset infoDefineGlobalConstant('kFileSig,   {pdb: kWarpSig, wrp: kWarpSig, jar: kJarEndSig});DefineGlobalConstant('kFileSigPos,{pdb: 60, wrp: 0, jar: -22});	// kFileSig pos inside pdb,wrp,jarDefineGlobalConstant('kNumRecPos, {pdb: 76, wrp: 6, jar: -12});	// numRec pos (word) within fileDefineGlobalConstant('kRecPos, 	  {pdb: 78, wrp: 8, jar: 0});	// 1st rec pos (long)DefineGlobalConstant('kRecOffset, {pdb:  8, wrp: 4, jar: 30});	// rec size incrementDefineGlobalConstant('kLOCHDR,	  30); // .jar  header lengthDefineGlobalConstant('kPRCArgPos, 1219);DefineGlobalConstant('kPRCIconPos,1512);// file extensions/namesDefineGlobalConstant('kClassExt, 	".class");DefineGlobalConstant('kClassExtLen, StrLen(kClassExt));DefineGlobalConstant('kBMPExt, 		".bmp");DefineGlobalConstant('kWBMExt, 		".wbm");	// e.g., MajongDefineGlobalConstant('kHTMExt, 		".htm");DefineGlobalConstant('kIconName, 	"icon.bmp");DefineGlobalConstant('kIconSym, 	Intern(kIconName));DefineGlobalConstant('kIconProName, "iconPro.bmp");	// !!!o// see getInboxItems. important conventions: ARGS=even(any len ok), CLASSES=odd(all 3 letters)DefineGlobalConstant('kWabaExts, [	".lnk",  ".wrp",	".prc",  ".pdb",	kHTMExt, ".jar",	// or .class	".html", kClassExt,	// or .jar]);// Waba VMDefineGlobalConstant('kWabaVMName,		"vm:waba");				// for getPkgItemsDefineGlobalConstant('kWabaVMSymbol,	Intern(kWabaVMName));	// for appLaunchDefineGlobalConstant('kWabaAppSig,		":waba");	// also used in getPkgItemsDefineGlobalConstant('kWabaLibName, 	"waba");	// w/o :waba suffixDefineGlobalConstant('kWabaLibSymbol, 	Intern(kWabaLibName));	// w/o :waba suffixDefineGlobalConstant('kWabaEmptyGlobal, { // ?? share w/ Waba VM?	lib: {},});			constant kExtrasSym := 'ExtrasDrawer;// NewtPack (saving app/autopart packages)DefineGlobalConstant('kNewtSymbol, '|NewtDevEnv:TKnollSys|);	// for NewtPackDefineGlobalConstant('kGetResource, /*frame*/ func(/*string*/ name)begin	local rf := OpenResFileX(HOME & kWabaTester & ".rsc");	local icon := GetPictAsBits(name,nil);	CloseResFileX(rf);	icon;end);DefineGlobalConstant('kWabaIconAddW, call kGetResource with ("WabaAppInsert"));//Write("kWabaIconAddW: "); Print(kWabaIconAddW.bounds);// === are shared statically via WabaTester.afterScript// *** are copied dynamically during WabaTester.savePkgDefineGlobalConstant('kNewtPackApp, { // for a regular Waba appviewClass:  clView,viewFlags:  0, viewFormat: 0, viewBounds: SetBounds(0,0,0,0), viewSetupFormScript: func()	// === WabaTester.appLaunchnil,viewQuitScript: func() 		// === WabaTester.appShutdownnil,VMExited: func(wvm)			// === WabaTester.VMExitednil,vm: nil,//oldInfo: nil,		//***. see appLaunch, appShutdown, savePackage//newInfo: {icon: call kGetResource with ("WabaAppOpen")},getResource:  nil,		// === WabaTester.getResourcegetWabaClass: nil,		// === WabaTester.getWabaClass//setAppContext:nil,	// was copied from WabaTester.setAppContext, but now called from lib/waba// copied via WabaTester:savePkgappArgs:	nil,	//***appClasses:	nil,	//***appContext:	nil,	//***appFormat: 	nil,	//***appMainName:nil,	//***appName: 	nil,	//***appRequires:nil,	//*** !!!nappSymbol: nil,		//***// for NewtPack_package: {	shortTitle: nil,		//***	copyright:	nil,		//***	//compressed: 'faster,	//??	icon: call kGetResource with ("WabaAppIcon"),	//***	DeletionScript: nil,	//***	},});//Print(kNewtPackApp._package.icon.bounds);DefineGlobalConstant('kNewtPackAuto, { // for a library extension, e.g., lib/wabaappSymbol: nil,				//***// for NewtPack_package: {	shortTitle: nil,		//***	copyright:	nil,		//***	//compressed: 'faster,	//??	icon: call kGetResource with ("WabaLibIcon"),	partData: {		// copied from WabaTester in SavePkg		//appArgs:	nil,	//unneeded		appClasses:	nil,	//***		appContext:	nil,	//***		appFormat: 	nil,	//***		//appMainName: 	nil,//unneeded		appName: 	nil,	//***		//appRequires:  nil,//???		//getResource:  nil,//unneeded		//getWabaClass: nil,//unneeded		//setAppContext:nil,//*** for lib/waba only		},	InstallScript: /*void*/ func(/*frame*/ partFrame, /*frame*/ removeFrame)	begin		// stash a reference in the global:		local /*frame*/ gData := GetGlobalVar(kWabaVMSymbol), partData := partFrame.partData;		local /*symbol*/ libSym := Intern(partData.appName); // w/o :waba		if not gData		then DefGlobalVar(EnsureInternal(kWabaVMSymbol), gData := EnsureInternal(kWabaEmptyGlobal));		if gData.lib.(libSym)		then GetRoot():Notify(kNotifyAlert, EnsureInternal("Waba Lib"), "name confict:" && libSym);		else begin			gData.lib.(libSym) := partData;			removeFrame.libSym := libSym;			end;		end,	RemoveScript: /*void*/ func(/*frame*/ removeFrame)	begin		RemoveSlot(GetGlobalVar(kWabaVMSymbol).lib, removeFrame.libSym);		// no gData or already removed??	end,	},});// ==========// Newt's Cape helperAppDefineGlobalConstant('kNewtsCapeSymbol, '|NewtsCape:NewtsCape|);DefineGlobalConstant('kNewtsCapeEmptyGlobal, {	cache: [], historyPos: 0,				htmlApps: {}, helperApps: {},	imageExtensions: [".gif"],	protos: {},	}); DefineGlobalConstant('kWabaMediaTypes, [	//??"text/plain", "*/*",	"application/octet-stream", "chemical/x-pdb",	"application/x-pilot-pdb",	//?? "application/x-pilot-prc", //.prc	"application/x-palmpilot", "application/x-pilot",	"application/java",	//.class	"application/zip-compressed",	//.jar	// ??.wrp,.lnk	]);// basically same as kWabaExt except just 'class' (not arg) files??DefineGlobalConstant('kWabaMediaExt, [".pdb", ".wrp", ".jar", ".class"]); // .prc, .lnk??DefineGlobalConstant('kHelperFrame, {transferMode: 'binary,extensions:   kWabaMediaExt,matchFile: /*boolean*/ func(/*string*/ url, /*binary*/ data) // for Inbox testingbegin	local int pos := LSearch(extensions, url, 0, GetGlobalFn('EndsWith), nil);	return pos and GetRoot().(kAppSymbol):checkFileSig(data, Intern(Substr(extensions[pos],1,nil)), nil);end,addFile: /*boolean*/ func(/*string*/ contentType, /*string*/ url, /*binary*/ data, /*frame*/ options)begin	local int pos := LSearch(extensions, url, 0, GetGlobalFn('EndsWith), nil);	if not pos	then return NIL;	if not options	then options := {};	// !!!n	local int i, ulen := StrLen(url), elen := StrLen(extensions[pos]); // incl .	local /*symbol*/ format := Intern(Substr(extensions[pos],1,nil));	pos := 0;	for i := ulen-elen to 0 by -1	do  if url[i] = $/		then break pos := i+1;//Print(url); Print(options);	local /*app*/ wabaTester := GetRoot().(kAppSymbol);	wabaTester:open();	AddDeferredSend(wabaTester, 'setAppClasses,		[Substr(url, pos, ulen-elen), data, options.appArgs, format, nil, options.appClass, options.appRequires]); // !!!n	TRUE; // return immed to allow some cleanupend,});DefineGlobalConstant('kInstallHelperApp, /*void*/ func(/*string*/ contentType, /*symbol*/ sym, /*frame*/ helperApp)if GetRoot().(kNewtsCapeSymbol)	// use built-in installHelperApp if therethen GetRoot().(kNewtsCapeSymbol):installHelperApp(contentType, sym, helperApp)else begin	local /*frame*/ gData := GetGlobalVar(kNewtsCapeSymbol);	if not gData	then DefGlobalVar(kNewtsCapeSymbol, gData := EnsureInternal(kNewtsCapeEmptyGlobal)); 	local /*frame*/ helperApps := gData.helperApps;	local /*symbol*/ icontentType := Intern(contentType);	local /*frame*/ helperFrame := helperApps.(icontentType); 	if isFrame(helperApp)	then begin // install		if not helperFrame then		helperApps.(EnsureInternal(icontentType)) := helperFrame := EnsureInternal({});		// assume in this version that helperApp has 'addFile		helperFrame.(EnsureInternal(sym)) := helperApp; // add/replace		end	else if helperFrame and Length(RemoveSlot(helperFrame,sym))=0	then RemoveSlot(helperApps, icontentType); // un-install	end;);InstallScript := func(partFrame)begin	local /*string*/ contentType;	foreach contentType in kWabaMediaTypes	do call kInstallHelperApp with (contentType, kAppSymbol, kHelperFrame);end;RemoveScript :=	func(partFrame)begin	local /*string*/ contentType;	foreach contentType in kWabaMediaTypes	do call kInstallHelperApp with (contentType, kAppSymbol, nil);end;// =========// MISC/UTILS// for infoParaDefineGlobalConstant('kScrollLines, 4);DefineGlobalConstant('kIndent, "  ");DefineGlobalConstant('kByteBeginsWith, /*boolean*/ func(/*binary*/ bytes, /*string*/ str, int offset)begin	local int i, slen := StrLen(str), blen := Length(bytes);	if offset < 0	then offset := blen+offset;	if offset < 0 or offset+slen > blen	then return NIL;	for i := 0 to slen-1	do if ExtractChar(bytes, offset+i) <> str[i]		then return NIL;	TRUE;end);DefineGlobalConstant('kExtractString, /*String*/ func(/*binary*/ data, int offset, int len) // packed asciibegin	local int i, dlen := Length(data);	if len = nil	then len := dlen-offset	else if offset+len > dlen	then return "";	local s := MakeBinary((len*2)+2, 'string);	for i := 0 to len-1	do StuffByte(s, (i*2)+1, ExtractByte(data, offset+i));	s;end);DefineGlobalConstant('kSetBytes, /*binary*/ func(array abytes)begin	local int i, blen := Length(abytes);	local /*binary*/ bbytes := MakeBinary(blen, 'binary);	for i:=0 to blen-1	do StuffByte(bbytes, i, abytes[i]);	bbytes;end);// replace with compile-time MakeBinaryFromHex(str, type) w/o /u/*DefineGlobalConstant('kFixBinaryType, func (ustr, type)	SetClass(SetLength(ustr,Length(ustr)-2), type) // fix class, get rid of null);*/DefineGlobalConstant('kDefaultPRCIcon1, call kSetBytes with ('[ // from PrcFile.java	0,   0,   0, 0,	0,   0,   0, 0,	0,   0,   0, 0,	0,   3, 192, 0,    0,  15, 240, 0,    0,  31, 248, 0,    0,  63, 252, 0,    0, 127, 254, 0,    0,  79, 242, 0,    0, 207, 243, 0,    0, 206, 115, 0,    0, 198,  99, 0,    0, 228,  39, 0,    0,  97, 134, 0,    0, 113, 142, 0,    0,  59, 220, 0,    0,  31, 248, 0,    0,  15, 240, 0,    0,   3, 192, 0,    0,   0,   0, 0,    0,   0,   0, 0,    0,   0,   0, 0,    ]));DefineGlobalConstant('kDefaultPRCIcon2, MakeBinaryFromHex( // mostly black, e.g., skey.prc	"07FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE007FFFFE0",	'binary));constant kHeadlen1x := 16;constant kHeadlen2x := 28;DefineGlobalConstant('kSetBitmapSize, /*void*/ func(/*bitmap*/ bitmap, int width, int height)begin	local /*binary/frame*/ bnds := bitmap.bounds;	local /*binary*/ bits := bitmap.data;	if IsBinary(bnds) // 2.x	then begin		StuffWord(bnds, 4, height);		StuffWord(bnds, 6, width);		end	else begin		bits := bitmap.bits;		bnds.bottom := height;		bnds.right  := width;		end;	StuffWord(bits, 12, height);	StuffWord(bits, 14, width);end);DefineGlobalConstant('kShapeBounds, /*frame*/ func(/*bitmap*/ bitmap)if bitmapthen begin	local bnds := bitmap.bounds;	if IsFrame(bnds) // and bitmap.bits	then bnds	else ShapeBounds(bitmap);	// 2.x	end);DefineGlobalConstant('kMakeBitmap, /*bitmap*/ func(int width, int height, /*frame*/ options, /*boolean*/ icon)if iconthen begin // 1.x-compatible format (and for 2.0 Extras icon)	local int depth := options.depth;	if depth <> 1	then begin		GetRoot():Notify(kNotifyAlert, EnsureInternal(kWabaTester), "1.x depth:" && depth);		return NIL;		end;	local int rowBytes := options.rowBytes;	if not rowBytes	then rowBytes := 4*((width + 31) div 32);	local /*binary*/ bits := MakeBinary(kHeadlen1x + (rowBytes*height), 'bits);	StuffWord(bits,  4, rowBytes);	StuffWord(bits, 12, height);	//8=top(0),10=left(0)	StuffWord(bits, 14, width);	{	bounds: RelBounds(0, 0, width, height),	bits: bits,	};	endelse if GetGlobalFn('MakeBitmap) // 2.x runtimethen MakeBitmap(width,height,options)else begin // 2.x but probably build time (e.g., WabaNewApp)	local /*binary*/ bits;	local int depth := options.depth;	if not depth	then depth := 1;	local int rowBytes := options.rowBytes;	if not rowBytes	then rowBytes := 4*((width*depth + 31) div 32);		local /*frame*/ bitmap := {		class: 'bitmap,		bounds: MakeBinary(8, 'boundsrect),		data: 	bits := MakeBinary(kHeadlen2x + (rowBytes*height), 'pixels), // assume padded already		colordata: NIL,		mask: 	NIL,		};	local /*int,int[]*/ res := options.resolution;	if not res	then res := 72;		// fix header   	StuffWord(bits,  2, kHeadlen2x);// scanOffset	StuffWord(bits,  4, rowBytes);	call kSetBitmapSize with (bitmap, width, height);    StuffByte(bits, 16, 128);		// ?    StuffByte(bits, 18,  16);		// ?    StuffByte(bits, 19, depth); 	StuffWord(bits, 22, if IsArray(res) then res[0] else res);	// resX 	StuffWord(bits, 24, if IsArray(res) then res[1] else res);	// resY 	bitmap;	end);constant kByteSize :=   256;constant kWordSize := 65536;// BMP,JAR seems to use little-endian rather than big-endian for header fieldsDefineGlobalConstant('kExtractRWord, /*int*/ func(/*binary*/ data, int offset)begin	local int byte1 := ExtractByte(data, offset+1), byte2 := ExtractByte(data, offset);	if byte1=0	then byte2	else (byte1*kByteSize) + byte2;end);DefineGlobalConstant('kExtractRLong, /*long*/ func(/*binary*/ data, int offset)begin	local int word1 := call kExtractRWord with (data, offset+2);	local int word2 := call kExtractRWord with (data, offset);	if word1=0	then word2	else (word1*kWordSize) + word2;end);// e.g., to compare against known classfile. like BinEqual but for rangesDefineGlobalConstant('kByteEqual, /*boolean*/ func(/*binary*/ bytes1, int offset1, int len1, /*binary*/ bytes2, int offset2, int len2)if len1=len2then begin	local int i;	for i := 0 to len1-1	do if ExtractByte(bytes1, offset1+i) <> ExtractByte(bytes2, offset2+i)		then return NIL;	TRUE;	end);// =====// only used for debuggingDefineGlobalConstant('kFindInboxItem, /*entry*/ func(/*string*/ title)begin	local cursor := GetUnionSoup(ROM_inboxsoupname):?Query(nil);	local entry := cursor:?entry(), etitle;	while entry	do  if isFrame(entry.body) and IsString(etitle := entry.body.title) and StrEqual(etitle, title)		then return entry		else begin			entry := NIL;			entry := cursor:next();			end;end);DefineGlobalConstant('kBytePos, /*int*/ func(/*binary*/ bytes, /*string*/ str, int offset) // unusedif StrLen(str) > 0then begin	local int i, j, slen := StrLen(str), ch0 := str[0];	local /*boolean*/ match;	for i := offset to Length(bytes)-slen	do  if ExtractChar(bytes,i) = ch0		then begin			match := true;			for j:=1 to slen-1			do  if ExtractChar(bytes,i+j) <> str[j]				then break match := NIL;			if match			then return i;			end;	NIL;	end);// End of text file WabaTesterDefs.txt// Beginning of file WabaTester.lytWabaTester :=    {     appArgs:       /*frame*/ nil // set via appPicker. shared with saved kNewtPackApp       ,     viewFormat: 83951953,     appShutdown:       /*void*/ func() // called by closeVMButton, appPicker, openWith, and kNewtPackApp.viewQuitScript === in afterScript       begin       	if appContext._proto	// in WabaTester don't want to lose current app via RemoveSlot       	then appContext := appContext._proto;       	//RemoveSlot(self, 'appContext);              	if vm       	then begin	// vm only set if WabaVM:launchWabaVM succeeded in appLaunch       		AddDeferredSend(GetRoot().(kWabaVMSymbol), 'shutdownWabaVM, [vm]);       		vm := nil;       		end;              	local /*symbol*/ appSym;       	if appSymbol = kWabaTesterSym and appArgs and (appSym := appArgs.uniqueSymbol) and not GetRoot().(appSym) //and appMainName and wabaVM.RemovePreferences       	then //AddDeferredSend(wabaVM, 'RemovePreferences, [appMainName, appArgs.uniqueSymbol]); // in DeletionScript (savePackage)       		EntryRemoveFromSoupXmit (GetAppPrefs(appSym, {}), nil);       	//else call kSetExtrasInfoFunc with ({appSymbol: appSymbol}, oldInfo);       end,     appClasses:       /*binary*/ nil	// set via appPicker. shared with saved kNewtPackApp/kNewtPackAuto       ,     GetResource:       /*frame*/ func(/*string*/ name)	// shared with === kNewtPackApp.getResource via afterScript       // name complete with path and extension (except for .class)       //note: long sym ok. check/print via Stringer([sym]) or SymbolName(sym) [undoc?]       begin       	local /*frame,binary*/ obj := GetVariable(appContext, Intern(name));	// uses _parent and _proto inheritance       	if IsBinary(obj)	// !!!o. allow tighter packages       	then {class: obj, offset: 0, length: Length(obj)}       	else obj;       end                     /* //old       // or use BFind for largeN and a case sensitive test??       	local pos := LSearch(classNames, name & ext, 0, '|str=|, nil);       	if pos       	then return {       		name: 	name,       		bytes: 	appClasses,       		offset: classOffs[pos],	// offset to beginning of class resource itself       		length: classLens[pos],       		};       */,     viewQuitScript:       /*void*/ func()       begin       	:appShutdown();	// get rid of dynamic appContext and vm, if necessary              	appArgs := appClasses := appFormat := appName := appMainName := NIL;       	inboxFiles := pkgFiles := NIL;              	appContext := {};	// munged by savePkg -- remove didn't work??       	//RemoveSlot(self, appContext);              	inherited:?viewQuitScript();       end,     setAppContext:       // --- unused. since accessed via lib/waba in appLaunch, but keep for savePackage (lib/waba)!       /*frame*/ func(/*frame*/ context, /*string[]*/ classpath) // used in appLaunch, kNewtPackApp.viewSetupFormScript       if context._proto	// only do this if we haven't already created an appContext chain       then context       else begin       	// construct an app context using _proto and _parent inheritance       	// that includes class entries from installed libraries -- order possibly specified via classpath arg       	// used indirectly by getResource, getWabaClass              	local /*frame*/ gData := GetGlobalVar(kWabaVMSymbol), lib;	// when defined in lib/waba, less checking needed       	if gData and IsFrame(lib := gData.lib) and Length(lib) > 0       	then begin       		local /*frame*/ appTemp, fr;       		local /*symbol*/ sym;	// !!!n       		context := appTemp := {_parent: {}, _proto: context};              		if IsArray(classpath) and Length(classpath) > 0       		then begin // selected classpath in a specific order       			foreach sym in classpath       			do  if sym and isFrame(fr := lib.(sym))	// !!!o,n       				then appTemp := appTemp._parent :=       					{_parent: appTemp._parent, _proto: fr.appContext};       			end              		else  // all, in no specific order       			foreach fr in lib       			do appTemp := appTemp._parent :=       				{_parent: appTemp._parent, _proto: fr.appContext};       		end;       	context;       	end,     getInboxItems:       /*void*/ func()       begin       	/*frame[]*/ inboxFiles := [];              	local /*soupCursor*/ cursor := GetUnionSoup(ROM_inboxsoupname):?Query(nil);       	local /*soupEntry*/ entry := cursor:?entry(), body;       	local /*binary*/ data;       	local /*string*/ titleStr, className;       	local /*symbol*/ format, iformat;       	local /*boolean*/ isClass;       	local /*frame*/ fileEntry, curFileEntry;       	local int i, wpos;              	while entry       	do begin       		if  IsFrame(body := entry.body) and       			IsBinary(data := body.data) and       			IsString(titleStr := body.title) and       			(wpos := LSearch (kWabaExts, titleStr, 0, GetGlobalFn('EndsWith), nil))       		then begin       			className := Substr(titleStr, 0, StrLen(titleStr)-StrLen(kWabaExts[wpos]));       			isClass := (wpos mod 2) = 1; // e.g., 0=args,1=classes,2=args,3=classes,...       			format := Intern(Substr(kWabaExts[if isClass then wpos else wpos+1], 1, nil)); // wrp, pdb, jar, class       //Print([className, format, isClass]);       			if not isClass or :checkFileSig(data,format,nil)       			then begin       				curFileEntry := nil;       				// need to check format also       				//curFileEntry := LFetch(inboxFiles, className, 0, '|str=|, 'appName);       				foreach fileEntry in inboxFiles       				do  if StrEqual(className, fileEntry.appName)       					then if format = (iformat := fileEntry.appFormat)       						then break curFileEntry := fileEntry       						else if isClass and ((format=kClass and iformat=kJar) or (format=kJar and iformat=kClass))       						then break curFileEntry := fileEntry; // swap format below for .jar/.class for .htm/.html              //Print([className, isClass, format]);              				if not curFileEntry       				then begin       					AddArraySlot(inboxFiles, curFileEntry := Clone(kFileEntry));       					curFileEntry.appName := className;       					end;              				curFileEntry.appFormat := format;              				curFileEntry.(if isClass then 'appClasses else 'appArgs) :=       					MakeEntryAlias(entry);  // expand later       				end;       			end;       		entry := body := data := nil;       		entry := cursor:next();       		end;       	cursor := nil;              //Print(inboxNames);       	// in case there might be an orphan "args" file unmatched by a class file       	// and in fact .prc files aren't checked anyway, so get rid of some entries       	       	for i := Length(inboxFiles)-1 to 0 by -1       	do  if inboxFiles[i].appClasses = nil       		then ArrayRemoveCount(inboxFiles, i,1);       end,     savePackage:       /*void*/ func(/*symbol*/ saveFmt)       if GetGlobalVar(kNewtSymbol).protos.protoPackage exists // NewtPack installed?       then begin       	local /*string*/ pkgName := (if appMainName then appMainName else appName) & kWabaAppSig;       	local /*symbol*/ appSym := Intern(pkgName), pkgSym := base.pkgSymbol;	// !!!o. might be different (shorter for template)       	if not pkgSym       	then pkgSym := appSym;       	local /*store*/ store;       	local /*frame*/ xpkg, app, wabaVars, curPkg, icon;              	// NewtPack pkg stuff       	if saveFmt = 'app       	then begin       		app := wabaVars := Clone(kNewtPackApp);       		app._package := xpkg := Clone(app._package); // modifiable (here and by NewtPack)       		wabaVars.appArgs    	:= appArgs;       		wabaVars.appMainName    := appMainName;       		wabaVars.appRequires	:= appRequires;		// !!!n       		wabaVars.appSymbol 		:= appSym;       		xpkg.shortTitle 		:= appName;			// default shortTitle in Extras                     	local /*string*/ dscript := ParamStr(               		"func()EntryRemoveFromSoupXmit(GetAppPrefs('|^0|,{}),nil)", [pkgName]              		);       //Print(dscript);       		local /*func*/ dfunc := call Compile(dscript) with ();       		local /*frame*/ args := dfunc.argFrame;       //Print([args, dfunc.DebuggerInfo]);       		if args       		then args._nextArgFrame := args._parent := args._implementor := nil;             	RemoveSlot(dfunc, 'DebuggerInfo);              	xpkg.DeletionScript := dfunc;       		end       	else // saveFmt = 'auto then       		begin        		app := Clone(kNewtPackAuto);       		app._package := xpkg := Clone(app._package);       		wabaVars := xpkg.partData := Clone(xpkg.partData);       		xpkg.shortTitle := "lib/" & appName;       		if StrEqual(appName, kWabaLibName)       		then wabaVars.setAppContext := setAppContext;       		end;               	:appShutdown();	// undo lib in appContext, vm now (vs. via :close later)              	xpkg.pkgSymbol := pkgSym; // !!!o       	xpkg.copyright  := $© & Date(Time()).year & $, && GetUserConfig('name) & ". All rights reserved worldwide.      "; // !!!o       	if icon := :getResource(kIconName) // no lib       	then xpkg.icon := icon;              	//if app=wabaVars // app       	//then wabaVars.oldInfo := {icon: xpkg.icon};              	// Waba specific stuff to save       	wabaVars.appClasses 	:= appClasses;       	wabaVars.appContext 	:= appContext; // no lib       	wabaVars.appFormat  	:= appFormat;       	wabaVars.appName    	:= appName;              	curPkg := {       		_proto: GetGlobalVar(kNewtSymbol).protos.protoPackage,	// NewtPack       		appTemplate: app,       		};              	pkgName := Stringer([pkgSym]);			// !!!o       	foreach store in GetStores()       	do  if xpkg := GetPkgRef(pkgName, store)       		then break;              	if xpkg       	then AsyncConfirm(       		"Replace" && pkgName && $?, 'yesNo,       		func(/*boolean*/ x) if x       			then begin       				SafeRemovePackage(xpkg);       				AddDeferredSend(curPkg, 'savePackage, nil);       				end)       	else AddDelayedSend(curPkg, 'savePackage, nil, 1000);              	:close();	// close to avoid problems with munged data. NewtPack starts       	end,     appContext:       /*frame*/ {} // set in setAppClasses. shared with saved kNewtPackApp       ,     viewBounds: {left: 0, top: 0, right: 0, bottom: 0},     _proto: @157 /* protoApp */,     VMExited:       /*void*/ func(/*binary*/ wvm)	// === event called from VM. shared with kNewtPackApp.VMExited in afterScript       begin       	if vm and BinEqual(vm,wvm)       	then vm := nil;	// just discard. no need to do shutDownWaba later during appShutDown              	if appSymbol <> kWabaTesterSym	// standalone apps       	then AddDeferredSend(self, 'close, nil)       	else :appShutdown();       end,     getWabaClass:       /*frame*/ func(/*string*/ name) // === share method directly with WabaTester.getWabaClass, kNewtPackApp.getWabaClass via afterScript       :getResource(name),     appFormat:       /*symbol*/ nil // set via appPicker & appLaunch. shared with saved kNewtPackApp/kNewtPackAuto       ,     viewScrollDownScript:       /*void*/ func()       infoPara:scroll(0, -kScrollLines),     viewOverviewScript:       /*void*/ func()       infoScroll:SetOrigin(0,0),     viewJustify: 240,     title: /*string*/ kAppTitle,     savePrefs:       func(/*string*/ tag) // !!!n       begin       	// we could use GetAppPrefs, except don't want to create it       	local /*cursor*/ cursor := GetStores()[0]:GetSoup(ROM_systemSoupName):Query(       		if tag       		then {       			indexPath: 'tag,       			beginKey: 	tag,       			endKey: 	tag,       			}       		);       	local /*soupEntry*/ entry := cursor:?entry();              	if tag       	then begin // !!!n       		Write("\nGetAppPrefs('|" & tag & "|,...) ==\n");        		Print(if entry and StrEqual(tag, entry.tag)       			then entry       			else "[none]");       		end              	else while entry // all       	do begin              		if EndsWith(tag := entry.tag, kWabaAppSig) and       			not StrEqual(tag, kWabaVMName) and       			not StrEqual(tag, kAppName)       		then begin Print(tag); Print(entry); end;              		entry := cursor:next();       		end;       end,     checkFileSig:       // used by helperApp, convertBitmap, setAppClasses, getInboxItems       /*boolean*/ func(/*binary*/ data, /*symbol,string*/ format, int offset)       if IsString(format)       then :ByteBeginsWith(data, format, offset)              else if IsSymbol(format)       then format=kClass or       	(:ByteBeginsWith(data, kFileSig.(format), kFileSigPos.(format)) and       	(if format=kJar then ExtractWord(data, 8) = 0 else TRUE))	// if .jar, uncompressed only       ,     inboxFiles:       /*frame[]*/ [] // see kFileEntry       ,     viewScrollUpScript:       /*void*/ func()       infoPara:scroll(0, kScrollLines),     appName:       /*string*/ nil	// file = main class name set via appPicker. shared with saved kNewtPackApp/kNewtPackAuto       ,     getPkgItems:       /*void*/ func() // may be removed in afterScript       // scan thru Newton packages for packages ending with kWabaAppSig (except WabaTester and VM)       // and which have appName, appClasses, appFormat, (and appArgs for apps only)       begin       	/*frame[]*/ pkgFiles := [];              	local /*store*/ store;       	local /*string*/ pkgName;       	local /*frame*/ app, root := GetRoot(), gData := GetGlobalVar(kWabaVMSymbol), lib := if gData then gData.lib else {};       	foreach store in GetStores()       	do  foreach pkgName in GetPackageNames(store)       	  	do if 	EndsWith(pkgName, kWabaAppSig) and		// ...:waba       				not StrEqual(pkgName, kPackageName) and	// omit WabaTester       				not StrEqual(pkgName, kWabaVMName) and	// and WabaVM       				(IsFrame(app := root.(Intern(pkgName))) or	// app or lib?       				 IsFrame(app := lib.(Intern(Substr(pkgName,0,StrLen(pkgName)-5))))       			 	) and       				SetContains(kFormats, app.appFormat) and	// recognizable format?       				IsString(app.appName)       			then AddArraySlot(pkgFiles, app);       end,     appRequires: nil,     viewSetupFormScript:       func()       begin       	:?getPkgItems();	// might not be present (see afterScript)       	:getInboxItems();              	inherited:?viewSetupFormScript();       end,     saveNTK:       DefineGlobalConstant('kStuffWrite, func(/*string*/ str, int offset, /*char*/ ch) Write (ch));              /*void*/ func()       begin       	local /*frame*/ context := if appContext._proto then appContext._proto else appContext;       	local /*string*/ verstr := "-- generated from" && appFormat && "format by" && kAppTitle && "on" && DateNTime(Time()) & unicodeCR; // !!!n       	Write("//" && appName & ".cls.txt" && verstr);       	Write("// number of classes/resources:" && Length(context) & unicodeCR);              	local /*symbol*/ slot;       	local /*frame*/  val;       	local /*string*/ sexpr, eexpr;              	foreach slot,val in context       	do begin       		if slot=kIconSym       		then begin       			sexpr := "ReplaceObject(kAppIcon, { //icon.bmp\n";       			eexpr := "});\n";       			end       		else begin       			sexpr := "kAppContext.|" & slot & "|:= {\n";       			eexpr := "};\n"       			end;              		Write(sexpr);       		if slot=kIconSym       		then begin	// icon. 1.x(2.0) compatible       			Write("\tbounds: "); Write(val.bounds); Write(",\n");       			Write("\tbits: MakeBinaryFromHex(\n\t\t\"");       			:hexData(val.bits, 0, nil, kStuffWrite);       			Write("\",\n\t\t'" & ClassOf(val.bits) & "),\n");       			end       		else if IsInstance(val,'bitmap) // 2.x format       		then begin       			Write ("\tclass: 'bitmap,\n");       			       			Write("\tbounds: MakeBinaryFromHex(\"");       			:hexData(val.bounds, 0, nil, kStuffWrite);       			Write("\", '" & ClassOf(val.bounds) & "),\n"); 		//boundsrect              			Write("\tdata: MakeBinaryFromHex(\n\t\t\"");       			:hexData(val.data, 0, nil, kStuffWrite);       			Write("\",\n\t\t'" & ClassOf(val.data) & "),\n");	//pixels              			Write("\tcolordata: nil, mask: nil");       			end       		else begin // class       			Write ("\tclass: MakeBinaryFromHex(\n\t\t\"");       			:hexData(val.class, val.offset, val.length, kStuffWrite);       			Write("\",\n\t\t'java),\n");       			Write("\toffset: 0, length:" && val.length);       			end;       		Write(eexpr);       		end;              	Write("\n\n//" && appName & ".arg.txt" && verstr);       	foreach slot,val in appArgs       	do Write("kAppArgs." & slot && ":=" && (       		if IsSymbol(val) then "'|" & val & $|       		else if IsString(val) then $" & val & $"       		else if val then val else "nil")       		& ";\n");              	Write("StrMunger(kAppMainName,0,nil, \"" & appMainName & "\",0,nil);\n");       end,     vm: /*binary*/ nil,     appMainName:       /*string*/ nil	// set in setAppClasses/setAppArgs from appArgs or appName       ,     hexData:              /*string*/ func(/*binary*/ data, int offset, int len, /*func*/ stuffFunc) // used in saveApp. basically like StrHexDump       begin       	constant /*string*/ kHex := "0123456789ABCDEF";       	if not len       	then len := Length(data)-offset;       	local int i, ch, uoff := 0, uextra := len mod 2; // uoff for \u, uextra for possible pad       	local /*string*/ ustr;              	if not stuffFunc       	then begin       		ustr := MakeBinary(uoff + 4*(len+uextra) + 2, 'string);       		stuffFunc := GetGlobalFn('StuffUniChar);       		end;              	//call stuffFunc with (ustr, 0, $\\);	// if using kFixBinaryType       	//call stuffFunc with (ustr, 2, $u);       	//uoff := 4;              	for i := offset to offset+len-1       	do begin       		ch := ExtractByte(data, i);       		call stuffFunc with (ustr, uoff,   kHex[Band(ch >> 4, 0xF)]);       		call stuffFunc with (ustr, uoff+2, kHex[Band(ch, 0xF)]);       		uoff := uoff+4;       		end;       	if uextra > 0       	then begin	// to even things out       		call stuffFunc with (ustr, uoff,   $0);       		call stuffFunc with (ustr, uoff+2, $0);       		end;          ustr;       end,     appLaunch:       /*void*/ func() // called by Launch button and === shared with kNewtPackApp.viewSetupFormScript in afterScript       begin       	local /*string*/ errMsg, delim := "not installed:";	// !!!n       	local /*app*/ wabaVM := GetRoot().(kWabaVMSymbol);       	local /*frame*/ gData := GetGlobalVar(kWabaVMSymbol), lib := if gData then gData.lib, waba := if lib then lib.(kWabaLibSymbol);       	local /*symbol*/ sym;       	if not wabaVM       	then begin       		errMsg := delim && "WabaVM";       		delim := $,;       		end;       	if lib and IsArray(appRequires)	// !!!n       	then begin       		 foreach sym in appRequires       		 do if sym and not lib.(sym)	// !!!o       		 	then begin       		 		errMsg := errMsg & delim && "lib/" & sym;       		 		delim := $,;       		 		end;       		 end       	else if not waba       	then errMsg := errMsg & delim && "lib/" & kWabaLibSymbol;              	if errMsg       	then begin       		GetRoot():Notify(kNotifyAlert, EnsureInternal("WabaApp"), errMsg);	// !!!n       		if appSymbol <> kWabaTesterSym // for WabaApp       		then AddDeferredSend(self, 'close, nil);       		end       	       	else begin // shares from lib/waba (since it's installed)       		appContext := waba:setAppContext(appContext, appRequires); 	// !!!n              		if not vm // defer so app.viewSetupFormScript completes & App LaunchVM button hilights       		then AddDeferredCall( // ...Call instead of ...Send to set vm var!       			func(name, args, app)       				app.vm := wabaVM:launchWabaVM(name,args,app), // NIL if not installed       			[appMainName, appArgs, self]);       		end;              /*       		if appSymbol <> kWabaTesterSym // for WabaApp       		then call kSetExtrasInfoFunc with ({appSymbol: appSymbol}, newInfo); // GetRoot().(kExtrasSym):?setExtrasInfo(...);        */       end,     convertBitmap:       /*bitmap*/ func(/*string*/ className, /*binary*/ data, int offset, int len, /*1.x bitmap*/ addWaba, /*boolean*/ rawIcon) // used by setAppClasses       if IsBinary(data) and (rawIcon or :checkFileSig(data, kBMPSig, offset))       then begin       	// addWaba is basically a boolean; set only for 1.x/2.0 compatible icon for Extras       	local int doffset, width, height, depth, dlen;       	local /*boolean*/ invert;	// !!!o       	if rawIcon       	then begin // from PRC file       		doffset := 0; // no header       		width 	:= height := 22;       		depth 	:= 1;       		dlen 	:= len;       		end       	else begin       		//+0 = "BM"       		//+2L = len       		//+6L = 0 reserved       		doffset  	:= :ExtractRLong(data, offset+10);       		//+14L infoSize=40       		width  		:= :ExtractRLong(data, offset+18);       		height 		:= :ExtractRLong(data, offset+22);       		//+26W = 0 planes       		depth    	:= :ExtractRWord(data, offset+28);	// gray. other fields??       		//+30L compression=0       		dlen 		:= :ExtractRLong(data, offset+34);       		//+38L  x pixelspermeter       		//+42L	y pixelspermeter       		//+46L colorsUsed=2       		//+50L colorImportant?       		//+54L col1       		//+58L col2 (blue,green,red,reserved) 255,255,255,0            invert :=            	not (:ExtractRLong(data, offset+54) <> 0 and            		 :ExtractRLong(data, offset+58) = 0);       		end;              	if dlen=0       	then dlen := ((len-doffset) div 4) * 4;       //Print([offset,len, doffset,dlen, width,height,depth]);       	if addWaba and depth <> 1       	then return infoPara:errorLog("convertBitmap:", className & "; depth:" && depth);       	if (doffset+dlen > len)       	then return infoPara:errorLog("convertBitmap:", className & "; doffset:" && doffset & "; dlen:" &&  dlen & "; len:" && len);              	local /*bitmap*/ bitmap := call kMakeBitMap with (width, height, {depth: depth}, addWaba);       //Print(bitmap);       	local /*binary*/ bits;       	local int i, j, btop;       	if addWaba       	then begin       		btop := kHeadLen1x;       		bits := bitmap.bits;       		end       	else begin	// 2.x       		btop := kHeadLen2x;       		bits := bitmap.data;       		end;       	local int rowBytes := ExtractWord(bits, 4), dtop := offset + doffset + dlen - rowBytes, byte;       //Print([btop, rowBytes, bits]);       	// copy, flip, invert. MungeBitmap,DrawIntoBitmap not avail at build-time, plus single loop probably faster anyway       	//BinaryMunger(bitmap.data, kHeadlen2x, dlen, data, offset+doffset, dlen); 	// copy raw bits       	//MungeBitmap(bitmap, 'flipVertical, nil);									// but bits were upside down       	//DrawIntoBitmap(MakeRect(0,0,width,height), 						// ...and inverted (this doesn't work for 1.x bitmaps)       	//	{penSize: 0, fillPattern: vfBlack, transferMode: modeXor}, bitmap);              	if rawIcon       	then BinaryMunger(bits, btop, dlen, data, offset+doffset, dlen)       	else for i := 0 to dlen-1 by rowBytes        		 do for j := 0 to rowBytes-1        			do begin        				byte := ExtractByte(data, dtop-i+j);       				StuffByte(bits, btop+i+j, if invert then Bxor(0xFF, byte) else byte);	// !!!o       				end;              	// and if it's an icon (22x22) we should center it and add "W" (or whatever) to right bottom corner (30x28)       	if addWaba       	then begin // add rows for "W" at bottom       		call kSetBitmapSize with (bitmap, width := 30, height := 28);       		SetLength(bits, btop + (rowBytes*height));              		// center orig dev 22x22 icon by shifting 3+1 right; (was 3+2) ?mask rightmost 5       		if not rawIcon       		then for i := btop to btop+dlen-1 by 4       			 do StuffLong(bits, i, Band(ExtractXLong(bits,i) >> 1, 0x0FFFFFC0));              		// now, Bor the "W" (it might overlap ~2 bottom rows of original icon)       		local int wlen := addWaba.bounds.bottom * 4, boff := Length(bits)-wlen;       		local /*binary*/ wbits := addWaba.bits;       		//for i := 0 to wlen-1       		//do StuffByte(bits, boff+i, Bor(ExtractByte(bits, boff+i), ExtractByte(wbits, kHeadlen1x+i)));              		// copy last 2 bytes of each row, copy 5 bits into byte2, store 8 bits into byte3       		for i := 2 to wlen-1 by 4       		do begin       			StuffByte(bits, boff+i,   Bor(ExtractByte(wbits, kHeadlen1x+i), Band(ExtractByte(bits,boff+i),0xE0)));       			StuffByte(bits, boff+i+1,     ExtractByte(wbits, kHeadlen1x+i+1));       			end;       		end;              	bitmap;       	end       else infoPara:errorLog("convertBitmap:", className & "; not binary or BMP?")     ,     builtinFiles:       /*frame[]*/ [ // see kFileEntry              {       appName: "HelloWorld",       appArgs: "... /w 0 /h 0 /l 14000 /m 8000 /s 1500 /t 300 HelloWorld \"\\...",       appClasses: SetClass("\u577270310000000100000010000001BC001048656C6C6F576F726C642E636C617373CAFEBABE0003002D001B0A0006000F0A001000110800120A001000130700140700150100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100076F6E5061696E74010015284C776162612F66782F47726170686963733B295601000A536F7572636546696C6501000F48656C6C6F576F726C642E6A6176610C000700080700160C0017001801000D48656C6C6F20576869726C65640C0019001A01000A48656C6C6F576F726C64010012776162612F75692F4D61696E57696E646F77010010776162612F66782F4772617068696373010008736574436F6C6F720100062849494929560100086472617754657874010017284C6A6176612F6C616E672F537472696E673B49492956002100050006000000000002000100070008000100090000001D00010001000000052AB70001B100000001000A000000060001000000040001000B000C000100090000003000040002000000102B030303B600022B12030303B60004B100000001000A0000000E00030000000800070009000F000A0001000D00000002000E"       	, 'binary),	       appFormat: 	kWRP,       },              {       appName: "Scribble",       appArgs: "... /w 0 /h 0 /l 14000 /m 8000 /s 1500 /t 300 Scribble \"\\...",       appClasses: SetClass("\u5772703100000003000000180000041A0000083A00000C09000E44726177417265612E636C617373CAFEBABE0003002D00470A0012002309001100240A00120025090012002609001200270A0028002909002A002B07002C090008002D090011002E090008002F09001100300A002800310A001200320A002800330A0028003407003507003601000564726177670100124C776162612F66782F47726170686963733B0100056C61737458010001490100056C617374590100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100076F6E4576656E74010012284C776162612F75692F4576656E743B2956010005636C6561720100076F6E5061696E74010015284C776162612F66782F47726170686963733B295601000A536F7572636546696C6501000D44726177417265612E6A6176610C001800190C001300140C003700380C003900160C003A001607003B0C003C003D07003E0C003F0016010010776162612F75692F50656E4576656E740C004000160C001500160C004100160C001700160C0042003D0C004300190C004400450C0046003D010008447261774172656101000F776162612F75692F436F6E74726F6C01000E637265617465477261706869637301001428294C776162612F66782F47726170686963733B0100057769647468010006686569676874010010776162612F66782F4772617068696373010007736574436C69700100072849494949295601000D776162612F75692F4576656E74010004747970650100017801000179010008647261774C696E6501000772657061696E74010008736574436F6C6F7201000628494949295601000866696C6C526563740021001100120000000300000013001400000000001500160000000000170016000000040001001800190001001A0000001D00010001000000052AB70001B100000001001B000000060001000000080001001C001D0001001A000000C100050003000000792AB40002C7001C2A2AB60003B500022AB4000203032AB400042AB40005B600062BB400071100C8A0001B2BC000084D2A2CB40009B5000A2A2CB4000BB5000CA700392BB400071100CBA0002F2BC000084D2AB400022AB4000A2AB4000C2CB400092CB4000BB6000D2A2CB40009B5000A2A2CB4000BB5000CB100000001001B00000036000D0000000F00070011000F001200200014002A0016002F0017003700180042001A004C001C0051001D0068001E0070001F007800210001001E00190001001A0000002100010001000000052AB6000EB100000001001B0000000A000200000025000400260001001F00200001001A0000003C000500020000001C2B1100FF1100FF1100FFB6000F2B03032AB400042AB40005B60010B100000001001B0000000E00030000002B000D002C001B002D00010021000000020022000E5363726962626C652E636C617373CAFEBABE0003002D004D0A001700250700260800270A00020028090029002A0A0029002B0A002C002D07002E0A00080025090016002F09002900300700310800320A000C002809001600330800340900160035090036003709003600380A001700390A0008003A07002707003B010008647261774172656101000A4C44726177417265613B01000B636C6F7365427574746F6E0100104C776162612F75692F427574746F6E3B01000B636C656172427574746F6E0100063C696E69743E010003282956010004436F646501000F4C696E654E756D6265725461626C650100076F6E4576656E74010012284C776162612F75692F4576656E743B295601000A536F7572636546696C6501000D5363726962626C652E6A6176610C001D001E0100055469746C650100085363726962626C650C001D003C07003D0C003E003F0C004000410700420C0043004401000844726177417265610C001800190C0045003F01000E776162612F75692F427574746F6E010005436C6F73650C001A001B010005436C6561720C001C001B0700460C0047003F0C004800490C004A004B0C004C001E010012776162612F75692F4D61696E57696E646F77010015284C6A6176612F6C616E672F537472696E673B295601000F776162612F75692F436F6E74726F6C0100057769647468010001490100077365745265637401000728494949492956010011776162612F75692F436F6E7461696E6572010003616464010014284C776162612F75692F436F6E74726F6C3B295601000668656967687401000D776162612F75692F4576656E74010004747970650100067461726765740100124C6A6176612F6C616E672F4F626A6563743B0100046578697401000428492956010005636C6561720021001600170000000300000018001900000000001A001B00000000001C001B000000020001001D001E0001001F000000E500060002000000992AB70001BB0002591203B700044C2B03032AB40005100FB600062A2BB600072ABB000859B70009B5000A2AB4000A0310142AB400052AB4000B102864B600062A2AB4000AB600072ABB000C59120DB7000EB5000F2AB4000F032AB4000B100F64102C100FB600062A2AB4000FB600072ABB000C591210B7000EB500112AB40011102E2AB4000B100F64102C100FB600062A2AB40011B60007B10000000100200000003A000E000000290004002A000E002B001A002C001F002E002A002F003F0030004700320054003300670034006F0036007C003700900038009800390001002100220001001F0000005C00020002000000302BB4001211012CA000282BB400132AB4000FA6000B2A03B60014A700152BB400132AB40011A6000A2AB4000AB60015B10000000100200000001A00060000003D000A003F00150040001D004100280042002F004400010023000000020024000B5469746C652E636C617373CAFEBABE0003002D00440A0011001E090010001F0700200800210A0003002209001000230A00240025090011002609001100270A002400280A001100290A002A002B0A0024002C0A0024002D0A0024002E07002F0700300100046E616D650100124C6A6176612F6C616E672F537472696E673B010004666F6E7401000E4C776162612F66782F466F6E743B0100063C696E69743E010015284C6A6176612F6C616E672F537472696E673B2956010004436F646501000F4C696E654E756D6265725461626C650100076F6E5061696E74010015284C776162612F66782F47726170686963733B295601000A536F7572636546696C6501000A5469746C652E6A6176610C001600310C0012001301000C776162612F66782F466F6E7401000948656C7665746963610C001600320C001400150700330C003400350C003600370C003800370C0039003A0C003B003C07003D0C003E003F0C0040003A0C004100420C004300320100055469746C6501000F776162612F75692F436F6E74726F6C010003282956010017284C6A6176612F6C616E672F537472696E673B49492956010010776162612F66782F4772617068696373010008736574436F6C6F72010006284949492956010006686569676874010001490100057769647468010008647261774C696E650100072849494949295601000E676574466F6E744D657472696373010025284C776162612F66782F466F6E743B294C776162612F66782F466F6E744D6574726963733B010013776162612F66782F466F6E744D65747269637301000C676574546578745769647468010015284C6A6176612F6C616E672F537472696E673B294901000866696C6C52656374010007736574466F6E74010011284C776162612F66782F466F6E743B2956010008647261775465787400210010001100000002000000120013000000000014001500000002000100160017000100180000003E000600020000001A2AB700012A2BB500022ABB000359120404100CB70005B50006B10000000100190000001200040000000E0004000F00090010001900110001001A001B00010018000000AA00050005000000662B030303B600072AB4000804643D2B031C2AB400091CB6000A8402FF2B031C2AB400091CB6000A2A2AB40006B6000B4E2D2AB40002B6000C10086036042B030315041CB6000D2B1100FF1100FF1100FFB600072B2AB40006B6000E2B2AB400020705B6000FB100000001001900000032000C0000001600070017000E001800190019001C001A0027001D0030001E003D001F0046002000530021005B0022006500230001001C00000002001D00"       	, 'binary),       appFormat: kWRP,       },       ],     setAppArgs:       /*void*/ func(/*frame*/ args, /*symbol*/ format) // called by getAppClasses. sets appArgs and maybe appMainName       begin       	// now fill in appArgs. these may be ignored, though mainClass is used here       	/* e.g.,        	.lnk(WRP) = ... " /w 0 /h 0 /l 14000 /m 8000 /s 1500 /t 300 HelloWorld "...       	.htm(JAR) =       		<applet code=waba/applet/Applet.class archive="MyApp.jar,waba.jar" width=160 height=160>       		<param name=appClass value="MyApp">       		</applet>       	.prc(PDB) = like .lnk (@1219), raw icon (@1512)       	*/              /* appArgs frame       //        width: <int>,		// requested width  of the JAVA drawing area Default: 160       height: <int>,		// requested height of the JAVA drawing area Default: 160              vmStackSize: <int>,		// default: 1500       nmStackSize: <int>,		// default: 300       classHeapSize: <int>,	// default: 14000       objectHeapSize: <int>,	// default: 8000              uniqueSymbol: <symbol>  	// the symbol that preferences for the app will be based on.       				    		// default: |wabaApp-CLASSNAMEHERE:waba|       title:			<string>              // WabaTester and apps generally don't set these?       wantsGray: <int 1 or 0>, // Default: 0. (0 anyway for MP130 or MP120)              useCPlusPlusHeap: <int 1 or 0>,	// allocate Java classes on the C++ heap?  Default: 0              doubleBuffer: <int 1 or 0>,	// double-buffer? (grab bitmaps from windows)  Default: 0       */              	constant /*string*/   kOptionLetters := "hwlmst"; // i,p? order matches kOptionAttribs       	constant /*symbol[]*/ kOptionAttribs := '[       		height, width, classHeapSize, objectHeapSize,       		vmStackSize, nmStackSize,];       	constant /*string[]*/ kAppletAttribs := '[       		"height", "width", "classHeapSize", "objectHeapSize",       		"vmStackSize", "nmStackSize", "archive", ];       	constant /*string[]*/ kParamAttribs  := '["value",];              	local /*int,string,symbol*/ attrib, val;       	local /*string*/ className, str, argMainName;       	local int i, spos, epos := 0;              	if format = kPDB and IsBinary(args) and not IsReadonly(appContext) and       		not :ByteEqual(args,kPRCIconPos,88, kDefaultPRCIcon1,0,88) and       		not :ByteEqual(args,kPRCIconPos,88, kDefaultPRCIcon2,0,88) and		       		attrib := :convertBitmap(className := kIconName, args, kPRCIconPos, 88, kWabaIconAddW, true)       	then begin       		appContext.(Intern(className)) := attrib;       		val := call kShapeBounds with (attrib);       		infoPara:println(kIndent & className & "; [from .prc];" && val.right & $x & val.bottom);       		end       	else if (format=kNTK or format=kPKG) and (attrib := Intern(appMainName & kWabaAppSig)) and       		val := call kShapeBounds with (GetRoot().(attrib).icon)	// nil for default       	then infoPara:println(kIndent & kIconName & "; [pkg];" && val.right & $x & val.bottom);              	infoPara:println("\nArgs:");              	if not args and format = kJAR and (args := :getResource(appName & kHTMExt)) // .htm in .jar file?       	then args := :ExtractString(args.class, args.offset, args.length);              	if not args       	then nil       	else if IsFrame(args)       	then foreach attrib,val in (appArgs := args)       		 do infoPara:println(kIndent & attrib & $: && val);       	else if format = kWRP or format = kPDB       	then begin       		if IsString(args)       		then str := args       		else if format = kWRP       		then str := :ExtractString(args, 0, nil)       		else begin // kPDB (i.e., .prc)       			str := ExtractCString(args, kPRCArgPos);       			str := Substr(str,0,StrLen(str)-5); //skip trailing blank and 4 char creator       			end;       				       		while (spos := CharPos(str, $/, epos)) and (spos = 0 or str[spos-1] = $ ) // all /options preceded by space; not package/names       		do begin       			spos := spos+1;		// skip /       			attrib := CharPos(kOptionLetters, str[spos], 0);	// option letter       			spos := spos+2; 	// skip letter and space       			epos := CharPos(str, $ , spos); // skip space       			val := StringToNumber(Substr(str,spos, epos-spos));       			if val       			then val := RIntToL(val);       			if attrib and val       			then begin       				attrib := kOptionAttribs[attrib];       				appArgs.(attrib) := val;       				infoPara:println(kIndent & attrib & $: && val);       				end;       			end;       		spos := epos;       		if epos := if format = kWRP then CharPos(str, $", spos) else StrLen(str) // main class name was right after options        		then argMainName := TrimString(Substr(str,spos,epos-spos)); // don't save in args       		end       	else if format = kJAR or format = kClass       	then begin       		constant kAppletStartTag := "<APPLET";       		constant kParamStartTag  := "<PARAM";       	       		str := if IsString(args) then args else :ExtractString(args, 0, nil);       		local /*function*/ fn := StrTokenize(str, " \t=\n");       		local /*string[]*/ curAttribs;       		while val := call fn with () // scan('parse') for a few recognized (contextual) attributes       		do begin       			TrimString(val);       			if attrib       			then begin       				StrReplace(val, "\"", "", nil);	// remove ">       				StrReplace(val, ">", "", nil);       				if not (attrib='archive or attrib='appMainName)       				then val := RIntToL(StringToNumber(val));       				if attrib <> 'appMainName       				then infoPara:println(kIndent & attrib & $: && val);       				if attrib='archive       				then begin       					local /*function*/ fn2 := StrTokenize(val, ".,");       					appRequires := val := ['waba];	// !!!n. into appRequires rather than appArgs.archive       					i := 0;       					while str := call fn2 with ()       					do begin       						if (i mod 2)=0 and not StrEqual(str,appName)       						then SetAdd(val, Intern(str), true);	// !!!n sym rather than string       						i := i+1;       						end;       					end       				else if attrib = 'appMainName       				then argMainName := val	// don't save in args       				else appArgs.(attrib) := val;       				attrib := nil;       				end       			else if BeginsWith(val, "</")       			then curAttribs := nil       			else if StrEqual(val, kAppletStartTag)       			then curAttribs := kAppletAttribs       			else if StrEqual(val, kParamStartTag)	// assume NAME=appClass. > 1 PARAM ??       			then curAttribs := kParamAttribs       			else if curAttribs       			then if LSearch(curAttribs, val, 0, '|str=|, nil)       			then attrib := if StrEqual(val, kParamAttribs[0]) then 'appMainName else Intern(val)       			// else ignore other tags and attributes       			end;       		end;              	if IsReadonly(appArgs)       	then appArgs := Clone(appArgs);       	if appArgs.width = 0       	then appArgs.width := nil;       	if appArgs.height = 0       	then appArgs.height := nil;       	if appName and not appArgs.title       	then infoPara:println(kIndent & 'title & $: && (appArgs.title := appName));              	className := argMainName; // possibly set in args       	if appMainName       	then begin // it should be same as args (if any)       		if className and not StrEqual(className, appMainName)       		then return infoPara:errorLog(str & "MISMATCH: [filename]", appMainName & "; [args]" && className);       		end       	else if className       	then if :getWabaClass(className)       		then appMainName := className       		else return infoPara:errorLog(str & "CLASS NOT FOUND: [args]", className)       	else return infoPara:errorLog(str & "NOT FOUND: [filename]", appName);              	if not appArgs.uniqueSymbol       	then infoPara:println(kIndent & 'uniqueSymbol & $: && $| & (appArgs.uniqueSymbol := Intern(appMainName & kWabaAppSig)) & $|);              	infoPara:println("AppMainName:" && appMainName);       end,     pkgFiles:       /*frame[]*/ [] // see kFileEntry       ,     setAppClasses:       // used by appPicker, helperApp       /*void*/ func(/*string*/ name, /*binary*/ data, /*frame*/ args, /*symbol*/ format, /*frame*/ context, /*string*/ mainName, /*symbol[]*/ requires)       if format=kNTK or format=kPKG or (IsBinary(data) and :checkFileSig(data,format,nil)) // doublecheck that it's an appropriate warp/jar       then begin       	:appShutdown(); // cleanup old app if any              	/*string*/ appName 		:= name;       	/*binary*/ appClasses 	:= data;       	/*frame*/  appArgs 		:= {}; 			// fill in setAppArgs       	/*symbol*/ appFormat 	:= format;       	/*frame*/  appContext 	:= if context then context else {};       	/*string*/ appMainName 	:= mainName;       	/*symbol[]*/ appRequires:= requires;	// !!!n              	local int i, recOffset, nameLen, classOffset, classLen, recPad := 0, depth;       	local /*string/symbol*/ className;       	local /*string*/ str;       	local /*frame*/ classEntry, bnds;              	local int numRecOffset := kNumRecPos.(format);       	local int offset, recInc, dlen := if data then Length(data) else 0;       	// technically this could be a long (for .wrp) though I doubt it       	local int numRec :=       		if format=kNTK or format=kPKG       		then Length(appContext)       		else if format=kClass       		then 1       		else if format=kJAR       		then :ExtractRWord(data, dlen+numRecOffset) // from end       		else ExtractWord(data, numRecOffset);              	infoPara:reset();       	iconView:reset();              	if format=kNTK or format=kPKG       	then infoPara:println(appName & "; format:" && appFormat & ";  items:" && numRec);       	else begin       		offset := kRecPos.(format);       		recInc := kRecOffset.(format);       		infoPara:println(appName & "; format:" && appFormat & ";  bytes:" && dlen & "; items:" && numRec);       		end;                     	// cache class names, offsets, lens       	// offset points to beginning of a "record"       	// recOffset to beginning of name & data              	if format=kNTK or format=kPKG       	then begin       		foreach className,classEntry in context       		do begin // just list (don't convert/process)       			className := Stringer([className]); // SPrintObject truncates > ~63       			if EndsWith(className, kBMPExt) or EndsWith(className, kWBMExt)       			then begin       				bnds := call kShapeBounds with (classEntry);       				str := $; && bnds.right & $x & bnds.bottom;       				end       			else str := "";       			infoPara:println(       				kIndent & className & "; len:" &&       					(if IsFrame(classEntry) then classEntry.length else Length(classEntry)) & str);	// !!!o       			end;       		if not context.(kIconSym)	// !!!o.   ?? what about Newt-generated apps       		then infoPara:println(       			kIndent & kIconName    & "; [Extras]" & unicodeCR &       			kIndent & kIconProName & "; [Extras]");       		end              	else if format=kClass // single class       	then begin       		className := appMainName := appName;              		classEntry:= {	//Clone(kClassEntry);       			class:  data,       			offset: classOffset := 0,       			length: classLen := dlen,       			};       		if not :ByteEqual(data,classOffset,4, kClassSig,0,4)       		then infoPara:errorLog("not a class?", className);       		appContext.(Intern(className)) := classEntry;              		infoPara:println(       			kIndent & className & "; offset:" && classOffset & "; len:" && classLen);       		end              	else       	for i := 0 to numRec // including 'eof' record (for kWRP)       	do begin       		if format=kJAR       		then begin       			if i = numRec       			then nil	// ignore       			else if :checkFileSig(data, kJarLocSig, offset) // LOC entry       					// and ExtractWord(data, offset+8) = 0	// LOCHOW = uncompressed? already checked for file as whole?       			then begin       				classLen  := :ExtractRWord(data, offset+22);	//LOCLEN       				nameLen   := :ExtractRWord(data, offset+26);	//LOCNAM       				recPad	  := :ExtractRWord(data, offset+28);	//LOCEXT       				recOffset := offset + kLOCHDR;       				className := :ExtractString(data, recOffset, nameLen);       				classEntry:= {	//Clone(kClassEntry);       					class:  data,       					offset: classOffset := recOffset + nameLen + recPad,       					length: classLen,       					};       				recInc := kLOCHDR + nameLen + recPad + classLen;       				end       			else return infoPara:errorLog("JAR problem", "i:" && i & "; offset:" && offset);       			end              		else begin // PDB, WRP       			recOffset :=       				if format=kPDB and i=numRec       				then dlen       				else ExtractLong(data, offset); // ?? long (probably not)              			if i > 0       			then // fill in length for previous entry       				classEntry.length := classLen := recOffset - classOffset;       			end;              		if classEntry and classLen > 0	// elim empty dir entries       		then begin       			str := "";              			if EndsWith(className, kClassExt)       			then begin       				className := Substr(className, 0, nameLen - kClassExtLen); 	// shorten       				if not :ByteEqual(data,classOffset,4, kClassSig,0,4)       				then infoPara:errorLog("not a class?", className);       				if EndsWith(className, appName)       				then if not appMainName       					then appMainName := className       					else if not StrEqual(appMainName, className)       					then infoPara:errorLog("MAIN conflict?", className);       				end       			else if (EndsWith(className, kBMPExt) or EndsWith(className, kWBMExt)) and       				classEntry := :convertBitmap(className, data, classOffset, classLen, if StrEqual(className, kIconName) then kWabaIconAddW, nil)       			then begin       				bnds := call kShapeBounds with (classEntry);       				str := $; && bnds.right & $x & bnds.bottom;       				if IsInstance(classEntry, 'bitmap) and (depth := ExtractByte(classEntry.data, 19)) > 1       				then str := str && "[D=" & depth & $];       				end;              			infoPara:println(       				kIndent & className & "; offset:" && classOffset & "; len:" && classLen & str);              			appContext.(Intern(className)) := classEntry;	// save current classEntry              			if BeginsWith(className, "waba/lang/") // add duplicate (shared) entry for java/lang       			then begin       				StrMunger(className,0,3,"jav",0,3);       				appContext.(Intern(className)) := classEntry;       				infoPara:println(       					kIndent & className & "; offset:" && classOffset & "; len:" && classLen);       				end;       			end;       		classEntry := nil;              		if format <> kJAR and i < numRec       		then begin       			nameLen    := ExtractWord(data, recOffset);       			className  := :ExtractString(data, recOffset+2, nameLen);       			classEntry := {	//Clone(kClassEntry);       				class:  data,       				offset: classOffset := recOffset + nameLen + 2,       				length: 0,	// set next time thru loop (from beg of next record)       				};       			end;              		offset := offset + recInc;       		end;              		:setAppArgs(args, format);       	end       else infoPara:errorLog(name, $[ & format & "] unrecognized format")    };launchVMButton :=    {     buttonClickScript:       func()       if appMainName and (appClasses or appFormat=kNTK or appFormat=kPKG) // !!!o       then AddDeferredSend(base, 'appLaunch, nil),     text: "Launch VM",     viewBounds: {left: 2, top: 4, right: 65, bottom: 16},     _proto: @226 /* protoTextButton */    };AddStepForm(WabaTester, launchVMButton);closeVMButton :=    {     buttonClickScript:       func()       AddDeferredSend(base, 'appShutdown, nil),     text: "Close VM",     viewBounds: {left: 2, top: 24, right: 65, bottom: 36},     _proto: @226 /* protoTextButton */    };AddStepForm(WabaTester, closeVMButton);appPicker :=    {labelCommands: /*frame|string[]*/ [],     text: /*string*/ "Apps",     viewBounds: {left: 2, top: 46, right: -70, bottom: 60},     viewSetupFormScript:       func()       begin        	local /*frame[]*/ fileList;       	local /*frame*/ fileEntry;       	local /*string[]*/  sources := ["Built-in", "Inbox", "Packages"];  // same order as foreach list	local /*symbol*/ listSep := nil;       	local /*string*/ source;       	//local /*symbol*/ listSep := 'pickSeparator;       	local int i;              	self.labelCommands := [];       	foreach i,fileList in [builtinFiles, inboxFiles, pkgFiles]       	do  if Length(fileList) > 0       		then begin       			source := sources[i];       //Print(source);       			AddArraySlot(labelCommands, {item: "---" && source && "---", pickable: NIL});       			foreach fileEntry in (if IsReadOnly(fileList) then fileList else Sort(fileList, kFileEntrySort, nil))       			do AddArraySlot(labelCommands, {       				// need to keep item names unique (otherwise, multiple checks)       				item:  fileEntry.appName && $( & source[0] & $- & fileEntry.appFormat & $),       				value: fileEntry});       			end;       		       	inherited:?viewSetupFormScript();       end              /*       	local int i;       	for i:=0 to Length(builtinNames)-1       	do AddArraySlot(labelCommands, builtinNames[i] && "(B-" & builtinFormats[i] & $));                     //	for i:=0 to Length(pkgNames)-1       //	do AddArraySlot(labelCommands, pkgNames[i] && "(P-" & pkgFormats[i] & $));              	for i:=0 to Length(inboxNames)-1       	do AddArraySlot(labelCommands, inboxNames[i] && "(I-" & inboxFormats[i] & $));       */       	,     textSetup:       /*string*/ func() "" // none selected initially       ,     labelActionScript:       /*void*/ func(int cmd)       begin       	local /*frame*/ fileEntry := labelCommands[cmd].value;       	local /*entryAlias,binary*/ classes := fileEntry.appClasses;       	local /*entryAlias,frame,string*/ args := fileEntry.appArgs;       	AddDeferredSend(base, 'setAppClasses, [		// allow highlight to complete       		fileEntry.appName,              		if IsEntryAlias(classes) // Inbox       			then EntryFromObj(classes).body.data       			else classes,              		if IsEntryAlias(args) 	// Inbox       			then EntryFromObj(args).body.data       			else args,              		fileEntry.appFormat,              		fileEntry.appContext,		// nil except 'ntk       		fileEntry.appMainName,		// nil except 'ntk(app)       		fileEntry.appRequires,		// nil except 'ntk(app) !!!n       		]);       end,     viewJustify: 8388656,     _proto: @190 /* protoLabelPicker */    };AddStepForm(WabaTester, appPicker);saveFormat :=    {viewBounds: {left: -70, top: 0, right: 0, bottom: 56},     viewJustify: 32,     clusterValue: 'ntk,     _proto: @203 /* protoRadioCluster */    };AddStepForm(WabaTester, saveFormat);StepDeclare(WabaTester, saveFormat, 'saveFormat);appRadio :=    {buttonValue: 'app,     viewBounds: {left: 0, top: 0, right: 57, bottom: 14},     text: "App Pkg",     _proto: @202 /* protoRadioButton */    };AddStepForm(saveFormat, appRadio);autoRadio :=    {buttonValue: 'auto,     viewBounds: {left: 0, top: 14, right: 57, bottom: 28},     text: "Lib Auto",     _proto: @202 /* protoRadioButton */    };AddStepForm(saveFormat, autoRadio);prefRadio :=    {buttonValue: 'pref,     viewBounds: {left: 0, top: 28, right: 57, bottom: 42},     text: "Pref",     _proto: @202 /* protoRadioButton */    };AddStepForm(saveFormat, prefRadio);ntkRadio :=    {buttonValue: 'ntk,     viewBounds: {left: 0, top: 42, right: 57, bottom: 56},     text: "NTK",     _proto: @202 /* protoRadioButton */    };AddStepForm(saveFormat, ntkRadio);saveButton :=    {     buttonClickScript:       func()       begin       	local /*symbol*/ format := saveFormat.clusterValue, sym;       	if format = 'pref // !!!n       	then base:savePrefs(if appClasses then Stringer([appArgs.uniqueSymbol]))       	else if appClasses       	then if format = 'ntk       		then AddDeferredSend(base, 'saveNTK, nil)       		else AddDeferredSend(base, 'savePackage, [format]);       end,     text: "Save",     viewBounds: {left: -30, top: 46, right: -2, bottom: 58},     viewJustify: 8388646,     _proto: @226 /* protoTextButton */    };AddStepForm(WabaTester, saveButton);iconView :=    {icon: nil,     viewBounds: {left: -108, top: 1, right: -70, bottom: 61},     viewFlags: 513,     viewFormat: nil,     viewJustify: 32,     Reset:       /*void*/ func()       begin       	SetValue(self, 'icon, nil);       	base:Dirty();	// restore nearby objects       end,     viewClickScript:       /*boolean*/ func(/*stroke*/ unit) // popup/scale full-size view . !!!o       begin       	constant /*int*/ kBorder := 8, kCloseHt := 20;       	local /*frame*/ bnds := if origBnds then origBnds else call kShapeBounds with (icon);       	if not bnds	// !!!n. no icon       	then return TRUE;              	local /*frame*/ ap := GetAppParams(), oldIcon := origIcon, newBnds;       	local int aht := ap.appAreaHeight, awid := ap.appAreaWidth;       	local int iht := bnds.right, iwid := bnds.bottom, newScale := 1;              	if scale       	then begin // in a pop-up view       		newScale := scale+1;       		newBnds  := Clone(bnds);       		newBnds.right  := iwid := iwid * newScale;       		newBnds.bottom := iht  := iht  * newScale;       		icon := ScaleShape(DeepClone(oldIcon), bnds, newBnds);       		AddDeferredSend(base, 'close, nil);       		end       	else oldIcon := MakeShape(icon);       		       	BuildContext({       		_proto: protoFloatNGo,       		viewFlags: 0,       		viewBounds: SetBounds(0, kBorder, min(awid-2*kBorder, max(40,iwid)), min(aht-kBorder, max(iht,32)+kBorder+kCloseHt)), // !!!o       		stepChildren: [{       			viewClass: clPictureView,       			viewBounds: SetBounds(0,0,0,-kCloseHt),       			viewJustify: vjParentFullH + vjParentFullV,       			viewFlags: vVisible + vClickable + vClipping,       			viewClickScript: self.viewClickScript,       			icon: icon,       			origIcon: oldIcon,       			origBnds: bnds,       			scale: newScale,       			},       			{viewClass: clParagraphView,       			viewBounds: SetBounds(0, -14, 40, -2),       			viewFlags: vVisible,       			viewJustify: vjParentLeftH + vjParentBottomV,       			viewFont: ROM_fontSystem10Bold,       			text: newScale & $x,       			}],       		}):open();       	return TRUE;       end,     scale: nil,     origIcon: nil,     origBnds: nil,     viewClass: 76 /* clPictureView */    };AddStepForm(WabaTester, iconView);StepDeclare(WabaTester, iconView, 'iconView);infoScroll :=    {viewBounds: {left: 0, top: 63, right: 0, bottom: -19},     viewFlags: 33,     viewJustify: 240,     viewOriginX: 0,     viewOriginY: 0,     viewClass: 74 /* clView */    };AddStepForm(WabaTester, infoScroll);StepDeclare(WabaTester, infoScroll, 'infoScroll);infoPara :=    {viewBounds: {left: 1, top: 1, right: -1, bottom: 20000},     viewFlags: 513,     viewFont: userFont12,     viewFormat: 12625,     viewLineSpacing: 14,     viewJustify: 48,     Scroll:       /*void*/ func(int col, int row)       :Parent():SetOrigin(       	max(0, viewOriginX - (col * viewLineSpacing)),       	max(0, viewOriginY - (row * viewLineSpacing))       	),     println:       /*void*/ func(/*String*/ txt)       begin       	SetValue(self, 'text, text & txt & unicodeCR); // append       	//RefreshViews();       end,     errorLog:       /*boolean*/ func(/*String*/ txt1, /*String*/ txt2)       begin       	PlaySound(ROM_plinkbeep);       	SetValue(self, 'text, txt1 && txt2 & unicodeCR & text);	// prepend       	RefreshViews();       	NIL;	// handy return val       end,     Reset:       /*void*/ func()       begin       	SetValue(self, 'text, "");       	:parent():SetOrigin(0,0);       end,     viewClickScript:       /*boolean*/ func(/*stroke*/ unit) // display picture for file clicked on       begin       	local int cpos := :PointToCharOffset(GetPoint(firstX,unit), GetPoint(firstY,unit));       	if cpos < 0       	then return TRUE;       	       	local int i, spos := 0;		// find beginning of current line       	for i:=cpos to 0 by -1       	do  if text[i]=$  or text[i]=unicodeCR       		then break spos := i+1;       	       	local int epos := CharPos(text, $;, cpos);	// filename is first item (if there's a semicolon on same line)       	if not epos or epos > CharPos(text, unicodeCR, cpos) // !!!n       	then return TRUE;              	local /*string*/ name := Substr(text,spos,epos-spos);       //Print([cpos, name]);       	local /*bitmap*/ bitmap := if EndsWith(name, kBMPExt) or EndsWith(name, kWBMExt) then :getResource(name);       	if not bitmap and (appFormat = kNTK or appformat = kPKG) and	// !!!o       		bitmap := (call kGetPartCursorFunc with (Stringer([appArgs.uniqueSymbol]), nil, nil)):?entry()       	then bitmap :=        		if StrEqual(name, kIconName)       		then bitmap.icon       		else if StrEqual(name, kIconProName) and bitmap.iconPro       		then bitmap.iconPro.unhilited;              	if IsInstance(bitmap, 'bitmap) or (IsFrame(bitmap) and bitmap.bits)       	then begin // highlight name and display picture       		:SetHilite(spos, epos, true);       		SetValue(iconView, 'icon, bitmap);       		base:Dirty();       		Sleep(10);       		call kClearSelectionHilitesFunc with (self);       		end;              	TRUE;       end,     text: "",     viewClass: 81 /* clParagraphView */    };AddStepForm(infoScroll, infoPara);StepDeclare(WabaTester, infoPara, 'infoPara);// After Script for WabaTesterthisView := WabaTester;begin	// for convenience (used in setAppClasses, etc.) & debugging	thisView.ByteBeginsWith := kByteBeginsWith;	thisView.ExtractString 	:= kExtractString;	thisView.ExtractRWord 	:= kExtractRWord;	thisView.ExtractRLong 	:= kExtractRLong;	thisView.ByteEqual		:= kByteEqual;	// === these are identical for now (so, share for maintenance/code size)	thisView.getWabaClass				:= thisView.getResource;	kNewtPackApp.viewSetupFormScript	:= thisView.appLaunch;	kNewtPackApp.viewQuitScript			:= thisView.appShutdown;	kNewtPackApp.VMExited				:= thisView.VMExited;	kNewtPackApp.getResource			:= thisView.getResource;	kNewtPackApp.getWabaClass			:= thisView.getWabaClass;	//kNewtPackApp.setAppContext		:= thisView.setAppContext;	// for debugging only	thisView.findInboxItem	:= kFindInboxItem;	//RemoveSlot(thisView, 'getPkgItems);	//thisView.addIcon := kWabaIconAddW;endconstant |layout_WabaTester.lyt| := WabaTester;// End of file WabaTester.lyt