/////////////////////   CatalogCreateFromPDB: Creates a catalog object which reads from embedded PDB FilesDefGlobalFn('CatalogCreateFromPDB,func(pdb)	{	/*binary*/ data: nil,	/*int*/ dataLength: nil,	/*int*/ recordStart: -1,	/*int*/ recordStop: -1,	/*int*/ recordSize: -1,	/*int*/ recordCount: -1,	/*int*/ entryPos: 0,		/*frame*/ init: func(/*frame*/ pdb) // called via CatalogCreate		begin		data := pdb.class;		dataLength := pdb.length;		recordCount := ExtractWord(data, 76);		return self;	end,		/*boolean*/ CatalogIsOpen: func()		return IsBinary(data),			/*void*/ CatalogDestroy: func()		data := nil,		/*boolean*/ CatalogClose: func()	begin		data := nil;		return true;	end,		/*int*/ CatalogGetRecordCount: func()		return if data then recordCount else -1,		/*int*/ CatalogGetRecordSize: func()		return if data then recordSize else -1,		/*boolean*/ CatalogSetRecordPos: func(int pos)	if pos = -1	// set/unset. ignore	then return true	else if pos < 0 or pos >= recordCount	// error	then return nil	else begin		local int offset := 78+(pos*8);		recordStart := ExtractLong(data, offset);		recordStop  := if (pos = recordCount-1) then dataLength else ExtractLong(data,offset+8);		recordSize  := recordStop - recordStart;		entryPos    := recordStart;		return true;		end,		/*byteFrame*/ CatalogRead: func(int count)	if data and count >= 0	then begin		count := min(count, recordStop - entryPos);		local byteFrame := {data: data, offset: entryPos, length: count}; // ok to use direct since copied??		//local byteFrame := {data: MakeBinary(count,'binary), offset: 0, length: count};		//BinaryMunger(buf, start, count, data, entryPos, count);		entryPos := entryPos + count;		return byteFrame;		end	else return {data: nil, offset: -1, length: -1},		/*int*/ CatalogSkipBytes: func(int count)	begin		count := min(count,			(if count < 0 then recordStart else recordStop) - entryPos); 		entryPos := entryPos + count;		return count;	end,		// 'ERRORS' for read only	/*int*/ CatalogAddRecord: func(int size)		return -1,	/*boolean*/ CatalogResizeRecord: func(int size)		return nil,	/*boolean*/ CatalogDelete: func()		return nil,	/*boolean*/ CatalogDeleteRecord: func()		return nil,	/*int*/ CatalogWrite: func(/*byteFrame*/ byteFrame)		return -1,	// listCatalogs ?	}:init(pdb));/////////////////////   CatalogCreateFromSoup: Creates a catalog object which reads/writes Soups///// Note: This one needs some work, it's not the true linked-list arrangement that///// the catalog class really defines.  I'm trying to get the catalog class redefined,///// but it's an uphill battle. --- SeanDefGlobalFn('CatalogCreateFromSoup,func(/*string*/ uniqueSym, /*string*/ name, /*int*/ mode)	// we ignore the mode	begin	// build a catalog from the name.  To start, we register the catalog.		local soupName := "waba:"&uniqueSym&":"&name;		local mySoupDef := 		{		name: soupName,		userName: name&&"("&uniqueSym&")",		ownerApp: kAppSym,		userDescr: "A soup created by the Waba application" && uniqueSym,		indexes: nil,		};			// register the soup definition	local myUnionSoup := RegUnionSoup(kAppSym,mySoupDef);		// Query the soup	local cursor := nil; 	if (myUnionSoup) then cursor := myUnionSoup:Query(nil);		// go before the first entry	cursor:Reset();	cursor:Prev();	// Prepare the soup frame  -- closures are kewl...			{		// our global data		soupOpen: if (myUnionSoup) then true else nil,	// is the catalog usable at this point?		currentEntry: nil,	// our current soup entry		entryPos: 0,			// where in the entry's binary data are we reading from?		// a byte frame cache for small stuff		byteFrame: { data: MakeBinary(kSmallByteFrameLen,'bytes), offset: 0, Length: kSmallByteFrameLen },		// entries are of the form:		// { data: <binary> }				// the following method is called when the Catalog object is about to		// get GC'd.  We really don't need to do anything here, but let's close		// the soup anyway				CatalogDestroy: func()			begin			soupOpen := nil;			end,		// Read and Write functions communicate with the underlying C++ system using		// a "byte frame".  This is defined as follows:		// { data: <binary>, offset: <int>, length: <int> }		// data is the an object holding the bytes,		// offset is the position in the data where the bytes start,		// length is the length of the bytes, or else -1 if there's an error.		// Note that data must be at *least* offset+length in size./** * Adds a record to the end of the catalog. If this operation is successful, * the position of the new record is returned and the current position is * set to the new record. If it is unsuccessful the current position is * unset and -1 is returned.  <p><b><font color=red>NOTE: This is a worthless method.  Writing should autoresize.</font></b> * @param size the size in bytes of the record to add *///public native int addRecord(int size);				CatalogAddRecord: func(size)			begin						// unfortunately, finding the record again will likely be an O(n^2)			// operation without the use of indexes.  So this is gonna be			// expensive.  :-(						local result := -1;						if (size > kLargestCatalogRecord or size <= 0) then 				begin				cursor:Reset();				currentEntry := cursor:Prev();				entryPos := 0;				return result;				end;			if (not soupOpen) then 				begin				cursor:Reset();				currentEntry := cursor:Prev();				entryPos := 0;				return result;				end;						try				cursor:GoTo(					currentEntry := myUnionSoup:AddToDefaultStoreXmit(						{ data: MakeBinary(size,'bytes) }, nil));				entryPos := 0;				result := size;						onexception |evt.ex| do				begin				throw(|evt.ex|,nil);				soupOpen := nil;  // close the soup				end;						return result;				end,/** * Resizes a record. This method changes the size (in bytes) of the current record. * The contents of the existing record are preserved if the new size is larger * than the existing size. If the new size is less than the existing size, the * contents of the record are also preserved but truncated to the new size. * Returns true if the operation is successful and false otherwise.  <p><b><font color=red>NOTE: This is a worthless method.  Writing should autoresize.</font></b> * @param size the new size of the record *///public native boolean resizeRecord(int size);		CatalogResizeRecord: func(size)			begin						// unfortunately, finding the record again will likely be an O(n^2)			// operation without the use of indexes.  So this is gonna be			// expensive.  :-(						local result := nil;						if (size > kLargestCatalogRecord or size <= 0) then return nil;			if (not soupOpen or not currentEntry) then return nil;						try				if (size < Length(currentEntry.data)) then					BinaryMunger(currentEntry.data,0,size,nil,0,size);  // truncate to size				else  // make a new binary					begin					local dat2 := MakeBinary(size,'bytes);					BinaryMunger(dat2,0,Length(currentEntry.data),						currentEntry.data,0,Length(currentEntry.data));					currentEntry.data := dat2;					end;				// reset pos?  Nah...it'll get handled by read/write								// update				EntryChangeXmit(currentEntry,nil);				result := true;							onexception |evt.ex| do				begin				throw(|evt.ex|,nil);				soupOpen := nil;  // close the soup				end;						return result;				end,/** * Closes the catalog. Returns true if the operation is successful and false * otherwise. *///public native boolean close();				CatalogClose: func()			begin			soupOpen := nil;			return true;			end,/** * Deletes the catalog. Returns true if the operation is successful and false * otherwise. *///public native boolean delete();		CatalogDelete: func()			begin			local result := nil;			soupOpen := nil;						try				// yank the soup from all the stores				local stores := GetStores();				local x;				for x:= 0 to Length(stores) do					begin					local soup := stores[x]:GetSoup(soupName);					if soup and soup:IsValid() then						soup:RemoveFromStoreXmit(nil);					end;				// unregister the soup				UnRegUnionSoup(soupName,kAppSym);				result := true;								onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					end;				return result;			end,		/** * Deletes the current record and sets the current record position to -1. * The record is immediately removed from the catalog and all subsequent * records are moved up one position. *///public native boolean deleteRecord(); 		CatalogDeleteRecord: func()			begin			local result := nil;			if (not soupOpen or not currentEntry) then return nil;						try				// delete the current entry				EntryRemoveFromSoupXmit(currentEntry,nil);				cursor:Reset();				currentEntry := cursor:Prev();				entryPos := 0;				result := true;								onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					end;				return result;			end,/** * Returns the number of records in the catalog or -1 if the catalog is not open. *///public native int getRecordCount();				CatalogGetRecordCount: func()			begin			local result := -1;			if (not soupOpen) then return nil;						try				result := cursor:CountEntries();								onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					end;				return result;			end,/** * Returns the size of the current record in bytes or -1 if there is no * current record.  <p><b><font color=red>NOTE: A procedure should be available to get the maximum  permitted size.</font></b> *///public native int getRecordSize();		CatalogGetRecordSize: func()			begin			local result := -1;			if (not soupOpen or not currentEntry) then return nil;						try				result := Length(currentEntry.data);								onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					end;				return result;			end,/** * Returns true if the catalog is open and false otherwise. This can * be used to check if opening or creating a catalog was successful. *///public native boolean isOpen();		CatalogIsOpen: func()			begin			return soupOpen;			end,/** * Sets the current record position and locks the given record. The value * -1 can be passed to unset and unlock the current record. If the operation * is succesful, true is returned and the read/write cursor is set to * the beginning of the record. Otherwise, false is returned.   <p><b><font color=red>NOTE: You should be able to skip negative bytes; this method should  return simply the number of bytes skipped successfully, error or not.</font></b> *///public native boolean setRecordPos(int pos);		CatalogSetRecordPos: func(pos)			begin			local result := nil;			if (not soupOpen) then return nil;						try				if (pos < 0) then // unset					begin					cursor:reset();					currentEntry := cursor:prev();					end;				else					begin					cursor:reset();					currentEntry:= cursor:move(pos);					end;				entryPos := 0;								onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					end;				return result;						end,/** * Reads bytes from the current record into a byte array. Returns the * number of bytes actually read or -1 if an error prevented the * read operation from occurring. After the read is complete, the location of * the cursor in the current record (where read and write operations start from) * is advanced the number of bytes read. * @param buf the byte array to read data into * @param start the start position in the array * @param count the number of bytes to read *///public native int readBytes(byte buf[], int start, int count);		CatalogRead: func(count)	// returns a byte frame, see top			begin			if (not soupOpen or not currentEntry) then return { data: nil, offset: -1, length: -1} ;						try				local myframe;				local mycount := Min(count,Length(currentEntry.data)-entryPos);				if (mycount < 0) then return { data: nil, offset: -1, length: -1};  // shouldn't ever happen!								if mycount <= kSmallByteFrameLen then					begin					byteFrame.length := kSmallByteFrameLen;					byteFrame.offset := 0;					myframe := byteFrame;					end;				else myframe := { data: MakeBinary(mycount,'bytes), offset:0, length: mycount};								BinaryMunger(myframe.data,0,mycount,currentEntry.data,entryPos,count);				entryPos := entryPos + mycount;				myframe.length := mycount;				return myframe;								onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					return { data: nil, offset: -1, length: -1};					end;						end,/** * Advances the cursor in the current record a number of bytes. The cursor * defines where read and write operations start from in the record. Returns * the number of bytes actually skipped or -1 if an error occurs.  <p><b><font color=red>NOTE: You should be able to skip negative bytes; this method should  return simply the number of bytes skipped successfully, error or not.</font></b> * @param count the number of bytes to skip *////public native int skipBytes(int count);		CatalogSkipBytes: func(count)			begin			if (not soupOpen or not currentEntry) then return -1;			if (count < 0) then return -1;  // ARGH, this isn't the way it oughta be!			entryPos := entryPos + (count := Min(count,Length(currentEntry.data) - entryPos));			return count;			end,/** * Writes to the current record. Returns the number of bytes written or -1 * if an error prevented the write operation from occurring. * After the write is complete, the location of the cursor in the current record * (where read and write operations start from) is advanced the number of bytes * written.  <p><b><font color=red>NOTE: if writing will go off the end of the record, we oughta try to gracefully resize it, and if it gets too big, then we issue an error.</font></b> * @param buf the byte array to write data from * @param start the start position in the byte array * @param count the number of bytes to write *///public native int writeBytes(byte buf[], int start, int count);		CatalogGetByteFrameForWrite: func(count)					begin			if (count <= kSmallByteFrameLen) then				begin				byteFrame.length := kSmallByteFrameLen;				byteFrame.offset := 0;				return byteFrame;				end;			else 		// I guess we'll just have to make one...				return { data: MakeBinary(count, 'bytes), offset: 0, length: count }			end,					CatalogWrite: func(byteFrame)			begin			local result := -1;						if (not soupOpen or not currentEntry) then return result;						try				local count := Min(byteFrame.length,Length(currentEntry.data)-entryPos);				if (count < 0) then return result;  // shouldn't ever happen!								local j;								BinaryMunger(currentEntry.data,entryPos,count,byteFrame.data,byteFrame.offset,count);				entryPos := entryPos + count;				// update				EntryChangeXmit(currentEntry,nil);				result := count;				onexception |evt.ex| do					begin				throw(|evt.ex|,nil);					soupOpen := nil;  // close the soup					end;				return result;						end,	}end);