// debugging?//constant debug := true;constant debug := nil;//constant debug := kDebugOn;// registered symbols for GetRootconstant kAppSym := '|VM:waba|;constant kRegisterSym := '|RegisteredVMs:waba|;// The name of the Waba appconstant kWabaName := "Waba";// A description of soups made by Waba appsconstant kWabaSoupDescription := "Created by the Waba application ";// DoDrawing() at event time or at draw time?// constant doDrawingAtEventTime := nil;// what version am I, as a number?  This should get bumped to 1 and synchronized with kVersion as of the Betaconstant kVersionNumber := 4;// what version am I, as a string?DefineGlobalConstant('kVersion, (SPrintObject(kVersionNumber)) && "(Beta)");  // as of the beta, this should read SPrintObject(kVersionNumber) && "(Beta)";// should I play sound tones (other than system beeps?)// this generally should be NO because Sean can't figure out how to get the// Newton to produce asynchronous sound tones without slowing down and using up C++ heap// in weird ways.  It looks like we're gonna have to be silent. constant produceSoundTones := nil;//constant produceSoundTones := true;// event typesconstant KEY_PRESS := 100;constant PEN_DOWN  := 200;constant PEN_MOVE  := 201;  // never happens on the Newton (mouse moves without button pressed)constant PEN_UP    := 202;constant PEN_DRAG  := 203;constant PRESSED   := 300;  // a UI element (like a button) got pressed -- we'd only care about this later if we're implementing Newton UI widgets rather than Waba onesconstant FOCUS_IN  := 301;  // sets the key focus for UI elements in the window -- I don't think we care about this either for nowconstant FOCUS_OUT := 302;  // sameconstant TIMER     := 303;constant REPAINT   := 4001; // our "event" for when we need repaintingconstant CALLBACK  := 4002; // our "event" for Newton API callbacks/*To send events to PulseNewton, we need to pass ita frame.  Here are typical frames:PEN_DOWN (also PEN_MOVE, PEN_UP, PEN_DRAG):	{event:PEN_DOWN, x:xPenPosition, y:yPenPosition, modifiers:currentModifiers}KEY_PRESS (I guess capital letters get the shift modifier set :-):	{event:PEN_DOWN, key:currentKey, modifiers:currentModifiers}TIMER:	{event:TIMER}REPAINT (rect should be in local coordinates for the view):	{event:REPAINT, x:RectX, y:RectY, width:RectWidth, height:RectHeight}CALLBACK	{evvent:REPAINT, callbackid:int}*/// Newton's standard unicode values for control keys:constant uBACKSPACE := $\08;constant uDELETE := $\7F;constant uENTER := $\03;		// same as return for our purposesconstant uRETURN := $\0D;		// same as return for our purposesconstant uTAB := $\09;constant uLEFT := $\1C;constant uRIGHT := $\1D;constant uESCAPE := $\1B;// unicode values for various weird keys://constant uUP := $\uF721;constant uUP := $\1E;//constant uDOWN := $\uF722;constant uDOWN := $\1F;constant uPAGE_UP := $\uF723;constant uPAGE_DOWN := $\uF724;constant uHOME := $\uF725;constant uEND := $\uF726;constant uINSERT := $\uF727;constant uMENU := $\uF728;constant uCOMMAND := $\uF729;// all keys are simple ASCII values except for:constant keyPAGE_UP   := 75000;constant keyPAGE_DOWN := 75001;constant keyHOME      := 75002;constant keyEND       := 75003;constant keyUP        := 75004;constant keyDOWN      := 75005;constant keyLEFT      := 75006;constant keyRIGHT     := 75007;constant keyINSERT    := 75008;constant keyENTER     := 75009;constant keyTAB       := 75010;constant keyBACKSPACE := 75011;constant keyESCAPE    := 75012;constant keyDELETE    := 75013;constant keyMENU      := 75014;constant keyCOMMAND   := 75015; // return values from PulseNewton:constant evtNO_WINDOW := -1;constant evtNO_METHOD := -2;constant evtSUCCESS   := 0;// default sizesconstant vmStackSize    := 1500;constant nmStackSize    := 300;constant classHeapSize  := 14000;constant objectHeapSize := 8000;// Supported Newton typesconstant NEWTONTYPE_MP2100	:= 1;constant NEWTONTYPE_MP2000	:= 2;constant NEWTONTYPE_EMATE	:= 3;constant NEWTONTYPE_MP130	:= 4;constant NEWTONTYPE_MP120	:= 5;DefineGlobalConstant('kDefaultPrefs,	{	vmStackSize: 1500,	nmStackSize: 300,	classHeapSize: 14000,	objectHeapSize: 8000,	ignoreVmStackSizeDefault:nil,	ignoreNmStackSizeDefault:nil,	ignoreClassHeapDefault:nil,	ignoreObjectHeapDefault:nil,	wantsGray: nil,	useCPlusPlusHeap: nil,	// old, but we keep it here	doubleBuffer: nil,	doDrawingAtEventTime: true,	x: nil,	y: nil	});	// what's the largest catalog record that Newton Waba will permit?// Remember that soup entries can be no larger than 32K all toldconstant kLargestCatalogRecord := 30000;// how big should we make little byte frames?  I say 64 bytesconstant kSmallByteFrameLen := 64;// sound tones -- stolen from Apple's Serenade example// There's an art to creating good samples.  The ones below are quite simplistic but will hopefully// illustrate some of the possibilities.  They are defined in this slot because the function must// change them - and how they are changed depends on which synth type they are.// The cryptic comments above the hex are a quick reference to the order of the synthesizer parameters, lined up// with their values in the string right below. Check the documentation for explanations of what they mean.// (The "\" is above the last character in a field; for example, "amp" (i.e. Amplitude) is set to 0x4710.)// This defines a simple sine wave toneDefConst('kSimpleTone, MakeBinaryFromHex(// header            \freq   \amp\lds\atk\dcy\sus\rel\pek\trl//"0001000000000000000103E800004710000000A000A012C000A5D00000", 'TDTMFCodec));  "0001000000000000000103E80000471000000010001012C00015D00000", 'TDTMFCodec));