// =========== Header ===========// File:				NewtSerial.cp// Project:				Waba// Written by:			Paul Guyot (pguyot@kallisys.net)//// Created on:			05/01/2001// Internal version:	1//// Copyright:			© 2001 by Paul Guyot.// 						All rights reserved worldwide.// ===========// =========== Change History ===========// 06/04/2001	v1	[PG]	I now close the endpoint before deleting it.//							I pass 1 as the thresh for TEndpoint::Rcv.// 05/01/2001	v1	[PG]	Creation of the file// ===========// I preferred to move the serial code out of the nmnewt_c.cp source file.// I need some Newton headers:#ifndef __NSANDDDKINCLUDES__	#include "NSandDDKIncludes.h"#endif#ifndef __COMMMANAGERINTERFACE_H	#include <CommManagerInterface.h>#endif#ifndef	__COMMSERVICES_H	#include <CommServices.h>#endif#ifndef __ENDPOINT_H	#include <Endpoint.h>#endif#ifndef	__SERIALOPTIONS_H	#include <SerialOptions.h>#endif#ifndef	__HALOPTIONS_H	#include <HALOptions.h>#endif//// SerialPort//// The SerialPort object has two 32 bits native variables.// 1/ the pointer to the TEndpoint object. It's nil if the object wasn't properly allocated.// 2/ the timeout in NewtonOS TimeUnits.// Serial port number strategy.// Poor devices only support 1 serial port. The doc says 0 should be the default serial port// and apparently, if we have 3 serial ports, we should have 0, 1, 2 and 3.// Here, the default port is determined by the system (it will be the external port most of the time).// There are two ways to specify the port:// Either provide an ID from 1 to 7 or provide the Newton HW Loc ID which will be directly passed.//	1 - External Serial		'extr'	(SCC channel 0)//	2 - Build In IR			'infr'	(SCC channel 1)//	3 - Built In Modem		'mdem'	(SCC channel 2)//	4 - PCMCIA Slot 1		'slt1'//	5 - PCMCIA Slot 2		'slt2'//	6 - PCMCIA Any Slot		'slot'//	7 - Built In Extra		'tblt'	(SCC channel 3 ?)#define WOBJ_SerialPortTEndpoint(o) (objectPtr(o))[1].intValue#define WOBJ_SerialPortTimeout(o) (objectPtr(o))[2].intValue// Cf waba/io/SerialPort.java// ============================================================	//// ¥ÊSerialPortCreate( Var [] )// ============================================================	//// Opens the serial port and create the serial port object.// I modify stack[0].// int number// int baudRate// int bits// boolean parity// int stopBits// --> voidVarVM::SerialPortCreate( Var stack[] ){	PRINTF2( "SerialPortCreate( stack = %.8X, stack[0] = %.8X )\n", stack, stack[0].obj );	// I first create the endpoint and if it succeed, I fill the ref num.		TEndpoint* myEndpointPtr = nil;	NewtonErr myErr;		do {	// Fake loop for errors.		TOptionArray myOptions;		myErr = myOptions.Init();		if (myErr) break;		// I select the transport: raw async.		// There is also basic serial, but it's not documented (and raw async works properly).		{			TOption theService;			theService.SetAsService( kCMSAsyncSerial );			myErr = myOptions.AppendOption( &theService );		}		if (myErr) break;		// If needed, I choose the HW location		// I read it from the 1st parameter.		if (stack[1].intValue)	// not the default port.		{			TCMOSerialHWChipLoc theHWChipLoc;			theHWChipLoc.SetOpCode( opSetRequired );						switch (stack[1].intValue)			{				case 1:					theHWChipLoc.fHWLoc = kHWLocExternalSerial;					break;									case 2:					theHWChipLoc.fHWLoc = kHWLocBuiltInIR;					break;									case 3:					theHWChipLoc.fHWLoc = kHWLocBuiltInModem;					break;									case 4:					theHWChipLoc.fHWLoc = kHWLocPCMCIASlot1;					break;									case 5:					theHWChipLoc.fHWLoc = kHWLocPCMCIASlot2;					break;									case 6:					theHWChipLoc.fHWLoc = kHWLocPCMCIAAnySlot;					break;									case 7:					theHWChipLoc.fHWLoc = kHWLocBuiltInExtra;					break;								default:					theHWChipLoc.fHWLoc = kHWLocExternalSerial;					//theHWChipLoc.fHWLoc = stack[1].intValue;                                        break;			}			myErr = myOptions.AppendOption( &theHWChipLoc );			if (myErr) break;		} // if (stack[1].intValue)		// Final configuration of the endpoint.		{			TCMOSerialIOParms theIOParms;			theIOParms.SetOpCode( opSetRequired );			// The speed:			// I read it from the 2nd parameter.			switch (stack[2].intValue)			{				// The switch may seem useless since the constants are set to the given value.				// Umm. If it's not one of these, I'll use the parameter directly.				// It's not because Apple killed the Newton that I will write dirty programs.								case 300:					theIOParms.fSpeed = k300bps;					break;									case 600:					theIOParms.fSpeed = k600bps;					break;				case 1200:					theIOParms.fSpeed = k1200bps;					break;				case 2400:					theIOParms.fSpeed = k2400bps;					break;				case 4800:					theIOParms.fSpeed = k4800bps;					break;				case 7200:					theIOParms.fSpeed = k7200bps;					break;				case 0:					// cf nmpalm_c.c although it's not documented.				case 9600:					theIOParms.fSpeed = k9600bps;					break;				case 12000:					theIOParms.fSpeed = k12000bps;					break;				case 14400:					theIOParms.fSpeed = k14400bps;					break;				case 19200:					theIOParms.fSpeed = k19200bps;					break;				case 38400:					theIOParms.fSpeed = k38400bps;					break;				case 57600:					theIOParms.fSpeed = k57600bps;					break;				case 115200:					theIOParms.fSpeed = k115200bps;					break;				case 230400:					theIOParms.fSpeed = k230400bps;					break;				default:					theIOParms.fSpeed = stack[2].intValue;					break;								}			// data bits: I read it from the third parameter.			switch (stack[3].intValue)			{				case 5:					theIOParms.fDataBits = k5DataBits;					break;									case 6:					theIOParms.fDataBits = k6DataBits;					break;				case 7:					theIOParms.fDataBits = k7DataBits;					break;				case 8:					theIOParms.fDataBits = k8DataBits;					break;				default:					theIOParms.fDataBits = stack[3].intValue;					break;			}			// Parity: I read it from the fourth parameter.			// Waba only supports even parity.			if (stack[4].intValue)			{				theIOParms.fParity = kEvenParity;			} else {				theIOParms.fParity = kNoParity;			}						// stop bits: I read it from the fifth parameter.			// Waba apparently doesn't support 1.5 stop bits.			switch (stack[5].intValue)			{				case 1:					theIOParms.fStopBits = k1StopBits;					break;								case 2:					theIOParms.fStopBits = k2StopBits;					break;				default:					theIOParms.fStopBits = stack[5].intValue;					break;							}			// And finally, I append the option.			myErr = myOptions.AppendOption( &theIOParms );		}		if (myErr) break;		// I select the flow control.		{			TCMOOutputFlowControlParms theFlowControlParms;			// Waba doesn't allow software flow control.			// Hardware flow control is turned on by default.			theFlowControlParms.useSoftFlowControl = false;			theFlowControlParms.useHardFlowControl = true;						myErr = myOptions.AppendOption( &theFlowControlParms );		}		if (myErr) break;				// Final configuration of the endpoint.				myErr = ::CMGetEndpoint( &myOptions, &myEndpointPtr );		if (myErr) break;		if (myEndpointPtr == nil)			break;		// I tell the endpoint that I want sync operations. (I think it's the default, but we never know)		(void) myEndpointPtr->SetSync( true );				myErr = myEndpointPtr->EasyOpen( 0 );	// yes, I'm lazy, so I let the system do the work.		// if (myErr) break;	} while (0);		if (myErr)	{		if (myEndpointPtr)		{			myEndpointPtr->Delete();			myEndpointPtr = nil;		}	}		// I set the timeout to the default ("The default timeout is 100 milliseconds.")	WObject thePort = stack[0].obj;	WOBJ_SerialPortTEndpoint( thePort ) = (int32) myEndpointPtr;		WOBJ_SerialPortTimeout( thePort ) = 100 * kMilliseconds;	PRINTF1( "SerialPortCreate> the endpoint ptr is %.8X\n", myEndpointPtr );	// Return void. Uhuh.		Var theResult;	theResult.intValue = 0;	return theResult;}// ============================================================	//// ¥ÊSerialPortDestroy( WObject )// ============================================================	//// I wonder why this functions was commented out.// I think rather that I need it to clean up the serial port stuff, don't I?voidVM::SerialPortDestroy( WObject port ){	PRINTF1( "SerialPortDestroy( port = %.8X )\n", port );	// I extract the TEndpoint*.	TEndpoint* myEndpointPtr = (TEndpoint*) WOBJ_SerialPortTEndpoint( port );		PRINTF1( "SerialPortDestroy> myEndpointPtr is %.8X\n", myEndpointPtr );	// Then I delete the endpoint object if not done yet. I ignore the error.	if (myEndpointPtr)	{		(void) myEndpointPtr->EasyClose();		myEndpointPtr->Delete();	}		// I set the TEndpoint to nil (so I won't destroy it again, useful because the dtor is called from the Close method)	WOBJ_SerialPortTEndpoint( port ) = nil;}// ============================================================	//// ¥ÊSerialPortIsOpen( Var [] )// ============================================================	//// // --> boolean//// Returns true if the port is open and false otherwise. This can// be used to check if opening the serial port was successful.//// It's basically what I'm going to do. If the ref num is 0, I say false. It it's not, I say true.// I guess that I should simply consider the boolean as an int32.VarVM::SerialPortIsOpen( Var stack[] ){	Var theResult;	if (WOBJ_SerialPortTEndpoint(stack[0].obj))	{		theResult.intValue = 1;	// true	} else {		// The TEndpoint wasn't allocated (or was destroyed): something wrong happened in the constructor.		theResult.intValue = 0;	// false	}	return theResult;}// ============================================================	//// ¥ÊSerialPortSetReadTimeout( Var [] )// ============================================================	//////// Sets the timeout value for read operations. The value specifies// the number of milliseconds to wait from the time of last activity// before timing out a read operation. Passing a value of 0 sets// no timeout causing any read operation to return immediately with// or without data. The default timeout is 100 milliseconds. This// method returns true if successful and false if the value passed// is negative or the port is not open.// @param millis timeout in milliseconds//VarVM::SerialPortSetReadTimeout( Var stack[] ){	Var theResult;	int theValue = stack[1].intValue;	WObject thePort = stack[0].obj;	if ((WOBJ_SerialPortTEndpoint( thePort ) == nil) || (theValue < 0))	{		WOBJ_SerialPortTimeout( thePort ) = theValue * kMilliseconds;		theResult.intValue = 1;	// true	} else {		// The TEndpoint wasn't allocated (or was destroyed): something wrong happened in the constructor.		// Or ... the argument is negative.		theResult.intValue = 0;	// false	}	return theResult;}// ============================================================	//// ¥ÊSerialPortReadCheck( Var [] )// ============================================================	//////// Returns the number of bytes currently available to be read from the// serial port's queue. This method only works under PalmOS and not WinCE// due to limitations in the Win32 CE API. Under Win32 and Java,// this method will always return -1.//// If the serial tool doesn't process our request (we never know), or if an error// occurs, we output -1 like Win32 CE or Java.VarVM::SerialPortReadCheck( Var stack[] ){	Var theResult;	theResult.intValue = -1;	do {		// I extract the TEndpoint*.		TEndpoint* myEndpointPtr = (TEndpoint*) WOBJ_SerialPortTEndpoint( stack[0].obj );			if (myEndpointPtr == nil)			break;	// Port not open.		TOptionArray myOptions;			NewtonErr myErr = myOptions.Init();		if (myErr) break;		// I ask the endpoint.		{			TCMOSerialBytesAvailable theBytesAvail;			theBytesAvail.SetOpCode( opGetCurrent );			myErr = myOptions.AppendOption( &theBytesAvail );		}					if (myErr) break;					myErr = myEndpointPtr->OptMgmt( opProcess, &myOptions );		if (myErr) break;					// Then I read the result.		TCMOSerialBytesAvailable* theOption = (TCMOSerialBytesAvailable*) myOptions.OptionAt( 0 );	// I retrieve it back.		// I check it has been processed.		if (theOption->IsProcessed())		{			theResult.intValue = theOption->fBytesAvailable;		}	} while (0);		return theResult;}// ============================================================	//// ¥ÊSerialPortSetFlowControl( Var [] )// ============================================================	//////// Turns RTS/CTS flow control (hardware flow control) on or off.// @param on pass true to set flow control on and false to set it off//// Undocumented (cf nmpalm_c.c): return true if everything worked properly.VarVM::SerialPortSetFlowControl( Var stack[] ){	Var theResult;	theResult.intValue = 0;	Boolean theNewFC = (stack[0].intValue != 0);	do {		// I extract the TEndpoint*.		TEndpoint* myEndpointPtr = (TEndpoint*) WOBJ_SerialPortTEndpoint( stack[0].obj );			if (myEndpointPtr == nil)			break;	// Port not open.		TOptionArray myOptions;			NewtonErr myErr = myOptions.Init();		if (myErr) break;		// I tell the endpoint to change the flow control in each direction.		{			TCMOInputFlowControlParms theInputFCParms;			theInputFCParms.SetOpCode( opSetRequired );			theInputFCParms.useHardFlowControl = theNewFC;			myErr = myOptions.AppendOption( &theInputFCParms );		}		if (myErr) break;					{			TCMOOutputFlowControlParms theOutputFCParms;			theOutputFCParms.SetOpCode( opSetRequired );			theOutputFCParms.useHardFlowControl = theNewFC;			myErr = myOptions.AppendOption( &theOutputFCParms );		}		if (myErr) break;		myErr = myEndpointPtr->OptMgmt( opProcess, &myOptions );		if (myErr) break;					// Then I check they were processed properly.		// First option		TOption* theOption = myOptions.OptionAt( 0 );		if (!theOption->IsProcessed())		{			break;		}		// Second option		theOption = myOptions.OptionAt( 1 );		if (theOption->IsProcessed())		{			theResult.intValue = 1;		}	} while (0);		return theResult;}	// ============================================================	//// ¥ÊSerialPortReadWriteBytes( Var [], int )// ============================================================	////VarVM::SerialPortReadWriteBytes( Var stack[], int isRead ){	PRINTF1( "SerialPortReadWriteBytes( stack, isRead = %i )\n", isRead );	Var theResult;	theResult.intValue = -1;	do { // fake loop		WObject thePort = stack[0].obj;		// I extract the TEndpoint*.		TEndpoint* myEndpointPtr = (TEndpoint*) WOBJ_SerialPortTEndpoint( thePort );			if (myEndpointPtr == nil)		{			PRINTF( "SerialPortReadWriteBytes> Port not open.\n" );			break;	// Port not open.		}		WObject theByteArray = stack[1].obj;		int32 theStart = stack[2].intValue;		Size theCount = stack[3].intValue;		if ( arrayRangeCheck( theByteArray, theStart, theCount) == 0 )		{			PRINTF3( "SerialPortReadWriteBytes> array null or range invalid, array is %.8X, start is %i, count is %i\n", theByteArray, theStart, theCount );			break; // array null or range invalid		}				UByte* theBuffer = (UByte *) WOBJ_arrayStart( theByteArray );		ULong flags = 0;		NewtonErr myErr;		if (isRead)			myErr = myEndpointPtr->Rcv( &theBuffer[theStart], theCount, 1, &flags, WOBJ_SerialPortTimeout( thePort ) );		else			myErr = myEndpointPtr->Snd( &theBuffer[theStart], theCount, 0, 0 );		if (myErr && myErr != -10021)	// -10021 is simply timeout.		{			PRINTF1( "SerialPortReadWriteBytes> Rcv/Snd returned an error: %i\n", myErr );			break;	// Port not open.		}#ifdef DEBUGGING_NEWTOS                PRINTF1( "SerialPortReadWriteBytes> %i bytes: ", theCount );		if (theCount)		{			int index_i;			for (index_i = 0; index_i < theCount; index_i++)			{				PRINTF1( "%.2X", theBuffer[theStart + index_i] );			}			PRINTF( "\n" );		}#endif		theResult.intValue = theCount;	} while (0);		return theResult;}// ============================================================	//// ¥ÊSerialPortRead( Var [] )// ============================================================	//////// Reads bytes from the port into a byte array. Returns the// number of bytes actually read or -1 if an error prevented the read// operation from occurring. The read will timeout if no activity// takes place within the timeout value for the port.// @param buf the byte array to read data into// @param start the start position in the byte array// @param count the number of bytes to read// @see #setReadTimeout//VarVM::SerialPortRead( Var stack[] ){	return SerialPortReadWriteBytes( stack, 1 );}// ============================================================	//// ¥ÊSerialPortWrite( Var [] )// ============================================================	//////// Writes to the port. Returns the number of bytes written or -1// if an error prevented the write operation from occurring. If data// can't be written to the port and flow control is on, the write// operation will time out and fail after approximately 2 seconds.// @param buf the byte array to write data from// @param start the start position in the byte array// @param count the number of bytes to write//VarVM::SerialPortWrite( Var stack[] ){	return SerialPortReadWriteBytes( stack, 0 );}// ============================================================	//// ¥ÊSerialPortClose( Var [] )// ============================================================	//////// Closes the port. Returns true if the operation is successful// and false otherwise.//VarVM::SerialPortClose( Var stack[] ){	// Check if the port was already open (I say that closing it was successful in this case)	WObject thePort = stack[0].obj;	Var theResult;		if (thePort)		theResult.intValue = 1;	else		theResult.intValue = 0;		SerialPortDestroy( thePort );	return theResult;}// ===================== //// You're at Witt's End. //// ===================== //