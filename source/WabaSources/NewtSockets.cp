// =========== Header ===========// File:				NewtSockets.cp// Project:				Waba// Written by:			Paul Guyot (pguyot@kallisys.net)//// Created on:			06/02/2001// Internal version:	1//// Copyright:			© 2001 by Paul Guyot.// 						All rights reserved worldwide.// ===========// =========== Change History ===========// 06/02/2001	v1	[PG]	Creation of the file// ===========// Just like NewtSerial, I preferred to move the socket code out of the nmnewt_c.cp source file.// I need some Newton headers:#ifndef __NSANDDDKINCLUDES__	#include "NSandDDKIncludes.h"#endif#ifndef __COMMMANAGERINTERFACE_H	#include <CommManagerInterface.h>#endif#ifndef	__COMMSERVICES_H	#include <CommServices.h>#endif#ifndef __ENDPOINT_H	#include <Endpoint.h>#endif#ifndef	__NIE__	#include <NIE.h>#endif//// Socket//// Socket is based on the code for Serial.// The Socket object has two 32 bits native variables.// 1/ the pointer to the TEndpoint object. It's nil if the object wasn't properly allocated.// 2/ the timeout in NewtonOS TimeUnits.#define WOBJ_SocketTEndpoint(o) (objectPtr(o))[1].intValue#define WOBJ_SocketTimeout(o) (objectPtr(o))[2].intValue// Link & DNS strategy://	For the moment, I grab it using a NewtonScript function (which MUST be defined in Waba app).//	This function returns a frame with the link ID and the host IP.//	The link is disposed when the window is closed rather than when the app no longer needs the link.//	It's simpler like this for the user and it is more Newton-like.// Cf waba/io/Socket.java// ============================================================	//// ¥ÊSocketCreate( Var [] )// ============================================================	////// Opens a socket. This method establishes a socket connection by// looking up the given host and performing the 3 way TCP/IP handshake.// @param host the host name or IP address to connect to// @param port the port number to connect to//// I modify stack[0].// String host// int port// --> voidVarVM::SocketCreate( Var stack[] ){	TEndpoint* myEndpointPtr = nil;	ULong theLinkID = 0;		NewtonErr myErr;		do {	// Fake loop for errors.		UChar theIP[4];	// The IP (4 bytes)				{			// Very first operation: get the link ID and the host IP.			// Dispose will be called even if an error is returned.						RefVar theInetFrame = NSSend(				GetFrameSlot( NSCallGlobalFn(SYM(GetRoot)), SYM(VM:waba) ),				SYM(InetGrabLinkAndGetIP),				WabaStringToNewtonString( stack[1].obj ) );				// If I got an integer, then it's the error code.			if ( ISINT(theInetFrame) )			{				myErr = RINT( theInetFrame );				break;			}			// Otherwise, I guess I got a frame. If I haven't, an exception will be thrown.			// I grab the link ID.					theLinkID = RINT( GetFrameSlot( theInetFrame, SYM(LinkID) ) );					// And the IP.			{				// I save the array in a temp variable.				RefVar theArray = GetFrameSlot( theInetFrame, SYM(HostIP) );				int index_i;	// Cursor on the IP bytes.				for (index_i = 0; index_i < 4; index_i++)				{					theIP[index_i] = RINT( GetArraySlot(theArray, index_i) );				}			}		}		{					TOptionArray myOptions;				myErr = myOptions.Init();			if (myErr) break;				// I select the transport: inet			{				TOption theService;				theService.SetAsService( KNIEConsts::kNIEServiceID );				myErr = myOptions.AppendOption( &theService );			}			if (myErr) break;				// The link ID			{				TITOPhysicalLinkIdentifier theLinkIDOption;				theLinkIDOption.SetOpCode( opSetRequired );				theLinkIDOption.SetLinkID( theLinkID );								myErr = myOptions.AppendOption( &theLinkIDOption );			}			if (myErr) break;					// The service: TCP			{				TITOTransportServiceType theServiceOption;				theServiceOption.SetOpCode( opSetRequired );				theServiceOption.SetServiceType( KNIEConsts::kTCP );								myErr = myOptions.AppendOption( &theServiceOption );			}			if (myErr) break;			myErr = ::CMGetEndpoint( &myOptions, &myEndpointPtr );			if (myErr) break;			if (myEndpointPtr == nil)				break;		}				// I tell the endpoint that I want sync operations. (I think it's the default, but we never know)		(void) myEndpointPtr->SetSync( true );		myErr = myEndpointPtr->Open();		if (myErr) break;		myErr = myEndpointPtr->Bind();	// Default. No timeout.		if (myErr) break;		// I need a new option object.		{			TOptionArray myConnectionOptions;			// I add the address & the remote port.			{				TITOTCPRemoteSocket theRemoteSocketOption;							theRemoteSocketOption.SetOpCode( opSetRequired );				theRemoteSocketOption.SetRemoteHostIP( theIP );				theRemoteSocketOption.SetRemoteHostPort( stack[2].intValue );							myErr = myConnectionOptions.AppendOption( &theRemoteSocketOption );			}			if (myErr) break;			myErr = myEndpointPtr->Connect( nil, &myConnectionOptions );	// No timeout.		}		//		if (myErr) break;	} while (0);		if (myErr)	{		if (myEndpointPtr)		{			myEndpointPtr->Delete();			myEndpointPtr = nil;		}		// I also tell the app so it knows how many times the link is used.		(void) NSSend(			GetFrameSlot( NSCallGlobalFn(SYM(GetRoot)), SYM(VM:waba) ),			SYM(InetDisposeLink) );	}		// I set the timeout to the default ("The default timeout is 100 milliseconds.")	WObject theSocket = stack[0].obj;	WOBJ_SocketTEndpoint( theSocket ) = (int32) myEndpointPtr;		WOBJ_SocketTimeout( theSocket ) = 100 * kMilliseconds;	// Return void. Uhuh.		Var theResult;	theResult.intValue = 0;	return theResult;}// ============================================================	//// ¥ÊSocketDestroy( WObject )// ============================================================	//voidVM::SocketDestroy( WObject port ){	// I extract the TEndpoint*.	TEndpoint* myEndpointPtr = (TEndpoint*) WOBJ_SocketTEndpoint( port );		// Then I delete the endpoint object if not done yet. I ignore the error.	if (myEndpointPtr)	{		(void) myEndpointPtr->EasyClose();		myEndpointPtr->Delete();				// I also tell the app so it knows how many times the link is used.		(void) NSSend(			GetFrameSlot( NSCallGlobalFn(SYM(GetRoot)), SYM(VM:waba) ),			SYM(InetDisposeLink) );	}		// I set the TEndpoint to nil (so I won't destroy it again, useful because the dtor is called from the Close method)	WOBJ_SocketTEndpoint( port ) = nil;}// ============================================================	//// ¥ÊSocketIsOpen( Var [] )// ============================================================	//// // --> boolean//// Returns true if the socket is open and false otherwise. This can// be used to check if opening the socket was successful.//// It's basically what I'm going to do. If the pointer to the endpoint is 0, I say false. It it's not, I say true.// I guess that I should simply consider the boolean as an int32.VarVM::SocketIsOpen( Var stack[] ){	::printf( "SocketIsOpen\n" );	Var theResult;	if (WOBJ_SocketTEndpoint(stack[0].obj))	{		theResult.intValue = 1;	// true	} else {		// The TEndpoint wasn't allocated (or was destroyed): something wrong happened in the constructor.		theResult.intValue = 0;	// false	}	return theResult;}// ============================================================	//// ¥ÊSocketSetReadTimeout( Var [] )// ============================================================	//////// Sets the timeout value for read operations. The value specifies// the number of milliseconds to wait from the time of last activity// before timing out a read operation. Passing a value of 0 sets// no timeout causing any read operation to return immediately with// or without data. The default timeout is 1500 milliseconds. This// method returns true if successful and false if the value passed// is negative or the socket is not open. Calling this method// currently has no effect under Win32 or WindowsCE. The// read timeout under those platforms will remain the system default.// @param millis timeout in milliseconds//VarVM::SocketSetReadTimeout( Var stack[] ){	::printf( "SocketSetReadTimeout\n" );	Var theResult;	int theValue = stack[1].intValue;	WObject theSocket = stack[0].obj;	if ((WOBJ_SocketTEndpoint( theSocket ) == nil) || (theValue < 0))	{		WOBJ_SocketTimeout( theSocket ) = theValue * kMilliseconds;		theResult.intValue = 1;	// true	} else {		// The TEndpoint wasn't allocated (or was destroyed): something wrong happened in the constructor.		// Or ... the argument is negative.		theResult.intValue = 0;	// false	}	return theResult;}// ============================================================	//// ¥ÊSocketReadWriteBytes( Var [], int )// ============================================================	////// Read or write bytes. It's in a single func to have less code.VarVM::SocketReadWriteBytes( Var stack[], int isRead ){	Var theResult;	theResult.intValue = -1;	do { // fake loop		WObject theSocket = stack[0].obj;		// I extract the TEndpoint*.		TEndpoint* myEndpointPtr = (TEndpoint*) WOBJ_SocketTEndpoint( theSocket );			if (myEndpointPtr == nil)			break;	// Port not open.		WObject theByteArray = stack[1].obj;		int32 theStart = stack[2].intValue;		Size theCount = stack[3].intValue;		if ( arrayRangeCheck( theByteArray, theStart, theCount) == 0 )			break; // array null or range invalid				UByte* theBuffer = (UByte *) WOBJ_arrayStart( theByteArray );				ULong flags = 0;		NewtonErr myErr;		if (isRead)			myErr = myEndpointPtr->Rcv( &theBuffer[theStart], theCount, 1, &flags, WOBJ_SocketTimeout( theSocket ) );		else			myErr = myEndpointPtr->Snd( &theBuffer[theStart], theCount, 0, 2 * kSeconds );		if (myErr) break;		theResult.intValue = theCount;				if (theCount > 0)		{			if (isRead)				::printf( "Read %i bytes\n", theCount );			else				::printf( "Wrote %i bytes\n", theCount );		}	} while (0);		return theResult;}// ============================================================	//// ¥ÊSocketRead( Var [] )// ============================================================	//////// Reads bytes from the socket into a byte array. Returns the// number of bytes actually read or -1 if the server closed// the connection or an error prevented the read operation from// occurring.// @param buf the byte array to read data into// @param start the start position in the byte array// @param count the number of bytes to read//VarVM::SocketRead( Var stack[] ){	return SocketReadWriteBytes( stack, 1 );}// ============================================================	//// ¥ÊSocketWrite( Var [] )// ============================================================	//////// Writes to the socket. Returns the number of bytes written or -1// if an error prevented the write operation from occurring. If data// can't be written to the socket for approximately 2 seconds, the// write operation will time out.// @param buf the byte array to write data from// @param start the start position in the byte array// @param count the number of bytes to write//VarVM::SocketWrite( Var stack[] ){	return SocketReadWriteBytes( stack, 0 );}// ============================================================	//// ¥ÊSocketClose( Var [] )// ============================================================	//////// Closes the socket. Returns true if the operation is successful// and false otherwise.//VarVM::SocketClose( Var stack[] ){	// Check if the port was already open (I say that closing it was successful in this case)	WObject theSocket = stack[0].obj;	Var theResult;		if (theSocket)		theResult.intValue = 1;	else		theResult.intValue = 0;		SocketDestroy( theSocket );	return theResult;}// ================================================================ ////         n = ((n >>  1) & 0x55555555) | ((n <<  1) & 0xaaaaaaaa); ////         n = ((n >>  2) & 0x33333333) | ((n <<  2) & 0xcccccccc); ////         n = ((n >>  4) & 0x0f0f0f0f) | ((n <<  4) & 0xf0f0f0f0); ////         n = ((n >>  8) & 0x00ff00ff) | ((n <<  8) & 0xff00ff00); ////         n = ((n >> 16) & 0x0000ffff) | ((n << 16) & 0xffff0000); ////                                                                  ////                 -- C code which reverses the bits in a word.     //// ================================================================ //