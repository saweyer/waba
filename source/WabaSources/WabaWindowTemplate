constant decorationsLeft := 1;constant decorationsRight := 1;constant decorationsTop := 1;constant decorationsBottom := 22;constant decorationsWidth := decorationsLeft+decorationsRight;constant decorationsHeight := decorationsTop+decorationsBottom;DefineGlobalConstant('WabaDrawingArea,	    {	// you need to make the bounds one wider and one deeper than	// you'd expect -- this is because the Newton clips off one extra	// pixel on the far right and on the bottom.		//soundChannel: nil,	//sounds: nil,		viewBounds: {left: decorationsLeft, top: decorationsTop, 		right: -(decorationsRight), bottom: -(decorationsBottom)},	viewJustify: vjParentFullH + vjParentFullV,		viewQuitScript: func()		begin		local result := inherited:?viewQuitScript();		//if soundChannel then soundChannel:?close();		result		end,		viewSetupDoneScript: func()		begin		local result := inherited:?viewSetupDoneScript();		// declare myself to my parent view so it knows who I am.		:Parent().wabaDrawingArea := self;		SetKeyView(self,nil);		return result;		end,		     viewFlags: vClickable+vClipping+vVisible+vStrokesAllowed+vNumbersAllowed+vLettersAllowed+vPunctuationAllowed,     viewFormat: 0,//     viewFormat: vfPen(1)+vfFrameBlack,	// thin line black frame around the edge of the drawing area, for debugging purposes	inDoDrawing: nil,	viewClickScript: func(unit)		begin		SetKeyView(self,nil);		if :Parent().routeTapsToHandwriting then return nil;  // let our stroke script handle it		if (:Parent().doDrawingAtEventTime) then			begin			inDoDrawing := true;			:DoDrawing('viewClickScriptHelper,[unit]);			inDoDrawing := nil;			end		else :viewClickScriptHelper(unit);		return true;  // we've handled it		end,     viewClickScriptHelper:       func(unit)       begin		if debug then Print("++viewClickScript++");       	InkOff(unit);  // we might need to do InkOffUnhobbled() if this isn't good enough pen resolution       	       	// Return true if click has been completely handled, nil otherwise       	local myParent := :Parent();       	local glob := :GlobalBox();       	       	// do a mouse down       	local x := GetPoint(firstX,unit) - glob.left;       	local y := GetPoint(firstY,unit) - glob.top;		if debug then Print("Mouse Down");		if debug then Print(x);		if debug then Print(y);		       	GetRoot().|VM:waba|:SendEventToVM(myParent.vmPtr,       		{       		event:PEN_DOWN,       		x:x,       		y:y       		// not checking for modifiers for now -- maybe we'll add this later   			});       	       	while (not StrokeDone(unit)) do       		begin       		// do a mouse dragged       		x := GetPoint(finalX,unit) - glob.left;       		y := GetPoint(finalY,unit) - glob.top;		if debug then Print("Mouse Dragged");		if debug then Print(x);		if debug then Print(y);       		GetRoot().|VM:waba|:SendEventToVM(myParent.vmPtr,       			{       			event:PEN_DRAG,       			x:x,       			y:y       			// not checking for modifiers for now -- maybe we'll add this later       			});       		sleep(1);  // maybe this is too low; we might be sucking too much battery power       		end;       	       	// do a mouse up       	x := GetPoint(finalX,unit) - glob.left;       	y := GetPoint(finalY,unit) - glob.top;		if debug then Print("Mouse Up");		if debug then Print(x);		if debug then Print(y);       	GetRoot().|VM:waba|:SendEventToVM(myParent.vmPtr,       		{       		event:PEN_UP,       		x:x,       		y:y       		// not checking for modifiers for now -- maybe we'll add this later       		});       	return true;       end,            Scribble: func(function,array)     	begin		if (inViewDrawScript or inDoDrawing) then // don't call DoDrawing -- dunno if this is important or not			begin	 		:DrawShape(array[0],array[1]);	 		end     	else      		begin     		// since we do a separate draw for every single item,     		// locking and unlocking the screen has almost no effect.  :-(     		// so I'm not wrapping DoDrawing in LockScreen calls; it's     		// an unnecessary addition.				:DoDrawing('DrawShape,array);  // never returns!!!     		end;     	end,		inViewDrawScript: nil,		viewDrawScript: func()		begin		inViewDrawScript := true;		if debug then Print("++ViewDrawScript++");		GetRoot().|VM:waba|:SendEventToVM(:Parent().vmPtr,			{			// repaint the whole window  -- too bad we're not told how much to repaint			// in NewtonScript.  Definitely an ugliness of the Newton system.			event:REPAINT,			x:0,  // it's (0,0) in the perception of the Java VM			y:0,			width:viewBounds.right-viewBounds.left,			height:viewBounds.bottom-viewBounds.top,			view:self			});		inViewDrawScript := nil;		end,   	textFlags: 	(1 << 10) +  // vSingleKeystrokes   				(1 << 15),   // vTakesAllKeys    	viewKeyDownScript: func(char,flags)		begin		:processKeystrokes(char,flags);		return true;		end,		viewKeyRepeatScript: func(char, flags)		begin		:processKeystrokes(char,flags);		return true;		end,		viewWordScript: func(unit)		begin		:viewKeyStringScript(GetWordArray(unit)[0]);		return true;		end,			viewKeyStringScript: func(string)		begin		if (:Parent().doDrawingAtEventTime) then 			begin			inDoDrawing := true;			:DoDrawing('viewKeyStringScriptHelper,[string]);			inDoDrawing := nil;			end;		else :viewKeyStringScriptHelper(string);		end,			viewKeyStringScriptHelper: func(string)		begin		if debug then Print(string);		local x;		local len := Strlen(string);		for x:= 0 to len-1 do			:processKeystrokesHelper(string[x],0);		end,		processKeystrokes: func(char, flags)		begin		if debug then Print(char);		if (:Parent().doDrawingAtEventTime) then 			begin			inDoDrawing := true;			:DoDrawing('processKeyStrokesHelper,[char,flags]);			inDoDrawing := nil;			end;		else :processKeyStrokesHelper(char,flags);		end,	processKeystrokesHelper: func(char, flags)		begin		if debug then Print("processKeystrokesHelper");		if (char=0) then return true;  // it's not a character				local key := Ord(char);				// ick.  Well...a case statement would revert to this		// anyway since it's not contiguous...				if (char=uBACKSPACE) then  // backspace			key:= keyBACKSPACE;		else if (char=uTAB) then // tab			key:= keyTAB;		else if (char=uENTER) then  // enter -- same as return for Java 			key:= keyENTER;		else if (char=uRETURN) then  // return 			key:= keyENTER;		else if (char=uLEFT) then // left arrow, for some reason			key := keyLEFT;		else if (char=uRIGHT) then // right arrow, for some reason			key := keyRIGHT;		else if (char=uESCAPE) then // esc			key := keyESCAPE;		else if (char=uDELETE) then // delete			key := keyDELETE;		// at this point we need to make up unicode values.		// we'll put them directly below the function-key values		else if (char=uPAGE_UP) then			key := keyPAGE_UP;		else if (char=uPAGE_DOWN) then			key := keyPAGE_DOWN;		else if (char=uHOME) then			key := keyHOME;		else if (char=uEND) then			key := keyEND;		else if (char=uUP) then			key := keyUP;		else if (char=uDOWN) then			key := keyDOWN;		else if (char=uINSERT) then			key := keyINSERT;		else if (char=uMENU) then			key := keyMENU;		else if (char=uCOMMAND) then			key := keyCOMMAND;							GetRoot().|VM:waba|:SendEventToVM(:Parent().vmPtr,			{			event:KEY_PRESS,			key: key,// it's possible our flags are just 0, because we got a string from viewKeyStringScript			option: Band(flags >> 28,0x1)=0x1,			control: Band(flags >> 29, 0x1)=0x1,			shift:	Band(flags >> 26,0x1)=0x1 or Band(flags>>27, 0x1)=0x1,			view:self			});		return true;		end,	MakeNote: func(frequency,duration,tone)		begin		// specify the note to play		local snd;				//snd:=clone(kToneArray[tone]);	// make a copy that we can modify		snd := clone(kSimpleTone);		// subtract the attack, decay and release time from duration		//duration := duration - (ExtractWord(snd, 18) + ExtractWord(snd, 20) + ExtractWord(snd,24));		//if duration <1 then duration := 1;	// don't go negative...			// change the frequency and duration as requested, for the main tone.		StuffWord(snd, 10, frequency);		StuffWord(snd, 22, duration);			/*if tone=1 then				// add in the lower frequency				StuffWord(snd, 30, frequency div 2);				if tone=1 or tone=2 then	// set the duration for the second tone			StuffWord(snd, 42, duration); */			snd		end,			/*		playScheduledSounds: func()		begin		Print("Playing sounds");		if (sounds) then			begin			soundChannel:SetVolume(GetUserConfig('soundVolume));  // just in case			local i;			local l:= Length(sounds);			for i:= 0 to l-1 do			try				soundChannel:Schedule(sounds[i]);			onexception |evt.ex| do begin Print("Synthesizer Error"); end;  // don't do anything			soundChannel:start(nil);  // start synchronously					end;		sounds := nil;		end,*/	playSoundTone: func(frequency,duration)		begin		if (not produceSoundTones) then return;				/*if soundChannel=nil then			begin			// set up my sound channel			soundChannel := {_proto:protoSoundChannel};			soundChannel:open();			end;*/					local snd := :MakeNote(frequency,duration,1);				// this procedure is gonna look weird, so here's my explanation.				/*if (sounds=nil) then				begin				//AddDelayedSend(self,playScheduledSounds,[],1);  // after-the-fact, but it doesn't work :-(				sounds := Clone([]);				end;		AddArraySlot(sounds,snd);		:playScheduledSounds();		// play right now!*/		PlaySoundSync(snd);		end,	debug: "WabaDrawingArea",     viewClass: 74, 		// clView + kFirstClassID//	viewClass: 81,			// clParagraphView + kFirstClassID    });    /*DefineGlobalConstant('WabaClipArea,	{	viewBounds: {left: decorationsLeft, top: decorationsTop, 		right: -(decorationsRight), bottom: -(decorationsBottom)},	viewJustify: vjLeftH + vjTopV,  // 0 + 0		    viewFlags: vClickable+vClipping+vVisible+vStrokesAllowed+vNumbersAllowed+vLettersAllowed+vPunctuationAllowed,    viewFormat: 0,	debug: "WabaDrawingArea",    viewClass: 74, 		// clView + kFirstClassID    viewChildren:[WabaDrawingArea],    });*//*DefineGlobalConstant('WabaKeyboardButton,    {    viewJustify: vjParentRightH + vjParentBottomV + vjCenterH + vjCenterV,	viewBounds: {left: -40, top: -16, right: -22, bottom: -3},	viewButtonScript: func()		begin		:PopupMenu(["Typewriter","Controls","Writing"],nil);		end,	pickActionScript: func(item)		begin		SetKeyView(:Parent().wabaDrawingArea,nil);		if (item=1) then // Typewriter			OpenKeypadFor(:Parent().wabaDrawingArea);		else if (item=2) then // Controls			if (not :Parent().keypad) then				begin				:Parent().keypad := BuildContext(|layout_ExtraKeypad|);				:Parent().keypad.parentview := :Parent();				end;			:Parent().keypad:Open();		else if (item=3) then // Writing			begin			if (not :Parent().lineInput) then				begin				:Parent().lineInput := BuildContext(|layout_LineInput|);				:Parent().lineInput.parentview := :Parent();				end;			:Parent().lineInput:Open();  // moves it to the front I hope			end;		end,    //_proto: @624 // protoSmallKeyboardButton     });*/DefineGlobalConstant('WabaCloseBox, 	{_proto: @163,    viewJustify: vjParentRightH + vjParentBottomV + vjCenterH + vjCenterV,	viewBounds: {left: -16, top: -16, right: -3, bottom: -3},	debug: "WabaCloseBox", 	});	DefineGlobalConstant('WabaInfo,	 {     _proto: @478, /* protoInfoButton */	 viewFlags: 515,     viewJustify: 134,     viewBounds: {left: 3, top: -16, right: 16, bottom: -3},     viewSetupFormScript: func()     	begin		inherited:?ViewSetupFormScript();		myprefs := {_proto: |layout_Prefs|};  // So I'm not scribbling over the prefs template that I was given     	end,	 doInfoAbout: func() GetRoot().|VM:waba|:Open(),	 doInfoPrefs: func() if not :Parent().preferencesOpen 	 	then begin 	 		:Parent().preferencesOpen := true; 	 		:Parent().prefsTemplate:StartPrefs(:Parent().uniqueSym,:Parent().title,:Parent());	 		end,	 	 GenInfoAuxItems: func() '["Hide"],	 DoInfoAux: func(auxArray, index)	 	begin	 	if index=0 then :Parent():Hide();	 	:Parent().action :=			GetRoot().notifyIcon:AddAction(:Parent().title,			func(mainwin)				begin					mainwin:Show();					GetRoot().notifyIcon:KillAction(mainwin.action);					mainwin.action := nil;				end,			[:Parent()]);	 	end,	 	     debug: "WabaInfo"	});DefineGlobalConstant('WabaWindowProto,    {    // route the scroll buttons to the page up, page down, and menu    // "keys".  Page up and Page down seem to be the standard keystrokes    // for when a Palm Pilot user presses the "up" and "down" buttons on    // his pilot.  Menu's another common item.  For some reason,     // plain wabaDrawingArea gives me the read-only template rather    // than the view; hence the self.wabaDrawingArea            viewScrollUpScript: func() self.wabaDrawingArea:?processKeystrokes(uPAGE_UP,(0x1)<<29),    viewScrollDownScript: func() self.wabaDrawingArea:?processKeystrokes(uPAGE_DOWN,(0x1)<<29),    viewOverviewScript: func() self.wabaDrawingArea:?processKeystrokes(uMENU,(0x1)<<29),        // protoDraggers only have the vClickable flag set.  We'll    // add vApplication to it here.    viewFlags: vClickable + vApplication,        routeTapsToHandwriting: nil,  // should we be routing our taps to handwriting or to waba?    title: "", // preferred name of program (keep short)// not using the cache right now//	SymbolCache: kSymbolCache,	spacebutton:nil,	backbutton:nil,	returnbutton:nil,	lineInput:nil,	keypad:nil,	prefsTemplate: |layout_Prefs|,  // so the VM can find me if it needs to open the prefs programmatically	preferencesOpen: nil,  // are the preferences open?  Only want one prefs window	viewJustify: vjParentCenterH + vjParentCenterV,    viewBounds: {left: 0, top: 0, right: 160+decorationsWidth, bottom: 160+decorationsHeight},     wabaDrawingArea: nil,  // this will eventually get overridden by the drawing area when the view is created     action: nil,  // for hiding and showing the window    uniqueSym:nil, // will be set by the VM    doDrawingAtEventTime: nil, // until we determine otherwise...    desiredWidth:0,	// will get set    desiredHeight:0,	// will get set        setUniqueSym: func(tothis)  		begin   		uniqueSym:=tothis; 				// first things first -- do I do optimized drawing or not?			local prefs := GetAppPrefs(uniqueSym,kDefaultPrefs);			doDrawingAtEventTime := prefs.doDrawingAtEventTime;  // hope I can do this now		end,	prepareWidthAndHeight:		func(width,height)	// called by the VM to change the width/height of window before opening		begin 			self.desiredWidth := width;			self.desiredHeight := height;			// reject invalid widths and heights -- the VM will call us with (160,160) if it doesn't know			if (width <=0 ) then width := 160;			if (height <= 0) then height := 160;						// set to maximum values if necessary, and possibly change			// the window style to look better			local b := GetAppParams();			if (width >= b.appAreaWidth and height >= b.appAreaHeight)  then // fill up entirely				begin				self.viewFormat := vfFillWhite; //  + vfFrameBlack;				self.viewBounds := Clone(viewBounds);				self.viewBounds.right := b.appAreaWidth;				self.viewBounds.bottom := b.appAreaHeight;				end			else				begin				if (width + decorationsWidth) >= b.appAreaWidth then					width := b.appAreaWidth - decorationsWidth;				if (height + decorationsHeight) > b.appAreaHeight then					height := b.appAreaHeight - decorationsHeight;								self.viewBounds := Clone(viewBounds);				self.viewBounds.right := width+decorationsWidth;				self.viewBounds.bottom := height+decorationsHeight;				end								end,     SetVMTo:       func(this)       	begin		if debug then Print("++SetVMTo++");       	if (vmPtr=nil) then vmPtr := this;       	end;,     StopVM:       func(exitCode)       	begin		if debug then Print("++StopVM++");       	if (not (vmWillStop)) then       		vmWillStop := true;       	//AddDelayedSend(self, 'TimerPulse, nil,1);	       	AddDelayedCall(func() :TimerPulse(), nil, 1);       	end,     SetTimerInterval:       func(millis)       	begin		if debug then Print("++SetTimerMillis++");       	//AddDelayedSend(self, 'TimerPulse, nil,millis);       	AddDelayedCall(func() :TimerPulse(), nil, millis);       	end,     vmWillStop: nil,     vmPtr: nil,     viewQuitScript:       // must return the value of inherited:?ViewQuitScript()       func()       begin		if debug then Print("++viewQuitScript++");       	result := inherited:?ViewQuitScript();       	lineInput:?Close();       	keypad:?Close();       	if (not closingWindow) then  // prevents infinite closing loop between me and the VM!       		begin       		closingWindow := true;       		GetRoot().|VM:waba|:shutdownWabaVM(vmPtr);       		end;       	return result;       end,     closingWindow: nil,      	TimerPulse: func()		begin		if debug then Print("++TimerPulse++");		if (closingWindow) then return;  // the VM's invalid or will soon be        	if (vmWillStop and not vmIsStopping) then  // prevents infinite closing loop between me and the VM!       		begin       		vmIsStopping := true;       		GetRoot().|VM:waba|:shutdownWabaVM(vmPtr);       		end;		else if (not vmWillStop and not vmIsStopping) then			begin			// why the "self"?  I dunno -- but for some reason just plain wabaDrawingArea gives			// me the drawing area *template*, not the view.  The template is read-only. 						if (self.doDrawingAtEventTime and Visible(self)) then 				begin				// if the window is hidden, then doDrawing doesn't work.				// dunno what the repercussions are of drawing without doDrawing...				self.wabaDrawingArea.inDoDrawing := true;					self.wabaDrawingArea:DoDrawing('TimerPulseHelper,nil);				self.wabaDrawingArea.inDoDrawing := nil;				end;			else :TimerPulseHelper();			end		end,          TimerPulseHelper: func()      	begin GetRoot().|VM:waba|:SendEventToVM(vmPtr, { event:TIMER }); end,	     vmIsStopping: nil,          Print:       func(string)       	begin       	if debug then Print(string);       	end;,     ReorientToScreen: func()      	begin      	local me := self;      	AddDeferredCall(func() me:close(), '[]);      	end,     debug: "WabaWindowProto",     _proto: @132,     viewChildren:[WabaDrawingArea,WabaInfo,WabaCloseBox,     	|layout_KeyboardButton|,|layout_HandwritingButton|,     	|layout_ReturnButton|,|layout_SpaceButton|,|layout_BackButton|]    });