package wababin;

import java.io.*;
import java.util.*; // Vector, Date

import wababin.pkg.PkgUtils; // for lib stuff

/**
 * Warp writes classes/bmps as NS hextext into .cls.txt for NTK compilation
 * Exegen writes the args & icon into .arg.txt
 *
 * @author     <A HREF="mailto:weyer@kagi.com">Steve Weyer</A>,
 * @version    1.50.0N
 *
 * 1.50.0Na 23 Dec 2000 first version
 * 1.50.0Nb 12 Jan 2001 MakeBinaryFromHex, version; remove inherited methods
 * 1.50.0Nc 10 Feb 2001 renamed from NTKClsFile; Exegen uses to write args;
 * 1.50.0Ng 29 May 2001 appReqPkgs
 *  class frame now just binary (for apps); lib support
**/
public class NTKFile extends WarpFile implements ExegenFile {
  public static final String WARP_EXT  =".cls.txt"; // !!!Nc
  public static final String EXEGEN_EXT=".arg.txt"; // !!!Nc
  boolean lib = false;            // !!!Nc

  // inherits warpFile, getFile
  // does not implement list, readHeader, readFiles

  /**
   * Constructs a new Newton NTK format text file.
   */
  protected NTKFile() {}

  /**
   * Constructs a new WarpFile with the given path.
   * @param path the path to this file.
   */
  public NTKFile(String path, String ext, boolean libformat) { // !!!Nc
    if (ext != null && !isValid(path,ext))
      path+=ext;
    warpFile=new File(path);
    lib = libformat;
  }

  /**
   * Is this path a valid pdb file (ie does it end with .wrp?)
   * @returns true if it is, false otherwise
   */
  public static boolean isValid(String path,String ext) {  // !!!Nc
    int elen = ext.length();
    return path!=null && path.length() > elen &&
      path.substring(path.length()-elen).equalsIgnoreCase(ext);
  }

  /**
   * Creates this warp file with the given list of input files.
   * called by Warp
   * @param inputFiles a sorted array of files to add
   */
  public void create(InputFile[] inputFiles, Vector appReqPkgs) {
    try {
      if (!Warp.quiet)
        System.out.println("...writing "+warpFile);
      PrintStream dos = new PrintStream(new FileOutputStream(warpFile));
      writeHeader(dos,inputFiles.length);
      writeFileList(dos,inputFiles);

      for (int i = 0; i < inputFiles.length; i++)
        writeRecord(dos, inputFiles[i], appReqPkgs);

      dos.close();
      if (!Warp.quiet)
        System.out.println("...done");
    }
    catch (FileNotFoundException fnfe) {
      Warp.errExit("can't create file "+warpFile, -1);
    }
    catch (IOException ioe) {
      Warp.errExit("problem writing to file "+warpFile, -1);
    }
  }

  // !!!Nc. called by Exegen. like PrcFile -prcCreator, +defWidth, +defHeight
  public void create (String prcName, int classHeapSize, int objectHeapSize,
    int stackSize, int nativeStackSize, String className, String prcIcon,
    int defWidth, int defHeight) {

    if (lib)    // !!!Nc
      return;

    if (!Exegen.quiet)
      System.out.println("...writing " + warpFile);
    try {
      String sexpr = "kAppArgs.", aexpr = " := ", eexpr = ";";
      PrintStream ps = new PrintStream(new FileOutputStream(warpFile));
      ps.println(versionLine(Exegen.EXEGEN_VERSION));  // !!!Nc
      ps.println(sexpr + "width"  + aexpr + ((defWidth ==0) ? "nil" : "" + defWidth) + eexpr);
      ps.println(sexpr + "height" + aexpr + ((defHeight==0) ? "nil" : "" + defHeight) + eexpr);
      ps.println(sexpr + "vmStackSize" + aexpr + stackSize + eexpr);
      ps.println(sexpr + "nmStackSize" + aexpr + nativeStackSize + eexpr);
      ps.println(sexpr + "classHeapSize"  + aexpr + classHeapSize + eexpr);
      ps.println(sexpr + "objectHeapSize" + aexpr + objectHeapSize + eexpr);
      ps.println(sexpr + "title" + aexpr + '"' + prcName + '"' + eexpr);  // !!!Nc
      ps.println(sexpr + "uniqueSymbol" + aexpr + "'|" + className + ":waba|" + eexpr); // !!!Nb
      ps.println("StrMunger(kAppMainName,0,nil, \"" + className + "\",0,nil);");
      if (prcIcon != null && prcIcon.endsWith(".bmp") && new File(prcIcon).exists()) {
        ps.println("ReplaceObject(kAppIcon, call kConvertBitmap with (\"" +
          prcIcon +  "\", MakeBinaryFromHex("); // !!!Nb
        ps.print("\t\"");
        try {
          hexFile(ps, new FileInputStream(prcIcon));
        }
        catch (Exception ex) { // no rollback??
        };
        ps.println("\",");
        ps.println("\t'bmp), true));");
      };
      ps.close();
    }
    catch (FileNotFoundException fnfe) {
      Exegen.errExit("can't create file "+warpFile, -1);
    }
    catch (IOException ioe) {
      Exegen.errExit("problem writing to file "+warpFile, -1);
     };
  }

  public String versionLine (String mainVersion) {  // !!!Nc
    return "// " + warpFile + " -- generated by " + mainVersion +
      ((lib) ? " (lib)" : " (app)") + ", on " + new Date().toString();
  }

  /**
   * Writes the header of this file
   * @param dos the output stream to write to
   * @param numInputFiles the number of input files in this warp file
   */
  protected void writeHeader(PrintStream dos, int numInputFiles) throws IOException {
    dos.println(versionLine(Warp.WARP_VERSION));  // !!!Nc
    dos.println("// number of classes/resources: " + numInputFiles);
  }

  /**
   * Writes the list of files contained in this warp file.  This consists of a list
   * of offsets in the file where each file starts.
   * @param dos the output stream to write to
   * @param inputFile the sorted array of input files.
   */
  protected void writeFileList(PrintStream dos, InputFile[] inputFiles) throws IOException {
    for (int i=0;i<inputFiles.length;i++)
    {
      //int pathLen = inputFiles[i].getName().length();
      int size = inputFiles[i].getFileLength();
      dos.println("// " + inputFiles[i].getName() + "; length: " + size);
    };
  }

/*
  public static void hexChar(PrintStream ps, int ch) {
    String hex = "0123456789ABCDEF";
    ps.print(hex.charAt((ch >> 4) & 0xF));
    ps.print(hex.charAt( ch       & 0xF));
  }
*/
  // Integer.toHexString doesn't do leading zeros
  public static void hexFile(PrintStream dos, InputStream is) throws IOException {
    int br, i = 0;
    while((br=is.read())!=-1) {
      if (br < 16)
        dos.print('0'); // pad. !!!Nc
      //hexChar(dos,br);
      dos.print(Integer.toHexString(br).toUpperCase()); // !!!Nc
      i++;
    };
    if ((i % 2) > 0)
      //hexChar(dos,0);
      dos.print("00");  // !!!Nc
    is.close();         // !!!Nc
  }

  /**
   * Writes an individual input file to this warp file.
   * @param dos the output stream to write to
   * @param inputFile the inputFile to write.
   */
  protected void writeRecord(PrintStream dos, InputFile inputFile, Vector appReqPkgs) throws IOException {
    String name = inputFile.getName();
    if (!inputFile.exists())
      Warp.errExit("can't load file "+name, -1);
    if (name.equals("icon.bmp")) {
      dos.println("// skipping icon.bmp");
      return;
    };

    // note: strip doesn't work for our 'double' extension
    String warpName = warpFile.getName(), appReqPkg, appReqDir;
    warpName = warpName.substring(0, warpName.length() - WARP_EXT.length());
    for (int k=0; k < appReqPkgs.size(); k++) { // !!!Ng. files in waba/ already skipped
      appReqPkg = (String) (appReqPkgs.elementAt(k));
      appReqDir = (appReqPkg.equals("wextra")) ? "extra/" : appReqPkg + '/'; // wextra for compat
      if (name.startsWith(appReqDir)) {
        if (!Warp.quiet)
          System.out.println("...skipping (in lib): "+name);
        dos.println("SetAdd(kAppRequires, '" + appReqPkg + ", true); // " + name);
        return;
      };
    };

    if (!Warp.quiet)
      System.out.println("...adding: "+name);
    //inputFile.writeFile(dos);

    String sexpr = "MakeBinaryFromHex(", eexpr = "\t'binary)"; //!!!Nb
    if (name.endsWith(".class")) {
      name = name.substring(0,name.length()-6);
      //sexpr = "{class: " + sexpr;   // !!!Nc
      eexpr = "\t'java)";            // !!!Nc
      // this is for compatibility with 'older' Waba apps
      // after another round or two of updates, remove
      if (lib) {
        sexpr = "{class: " + sexpr;
        eexpr += ", offset: 0, length: " + inputFile.getFileLength() + '}';
      };
    }
    else if (name.endsWith(".bmp")) {
      sexpr = "call kConvertBitmap with (\"" + name + "\", " + sexpr;
      eexpr = "\t'bmp), nil)";
    };
    // ?? else error

    dos.println("kAppContext.|" + name + "| := " + sexpr);
    dos.print("\t\"");
    hexFile(dos, new FileInputStream(inputFile.file));
    dos.println("\",");
    dos.println(eexpr + ';');
  }

  public String list (boolean extract) { // !!!Nc. shouldn't be called, but just in case...
    return "";
  }
}