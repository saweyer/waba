// for integrating with WabaVM// this file concatenates/consolidates separate files from waba.io project// Socket inlines code/docs originally shared with Serial// intended as an interim version (Paul's eventual version should supercede)// if not, probably want to also copy method documentation from Serial// ==========  waba.Objectconstant _DEBUG := true;constant false := nil;constant null := nil;DefineGlobalConstant('|waba.Object|, {_className: "waba.Object",	// *** override for each class/*retVal*/ _notifyErr: func(/*String*/ errMsg, retVal)begin	GetRoot():Notify(kNotifyAlert, EnsureInternal(_className), EnsureInternal(errMsg));	//call kFixRootParent with (nil);	return retVal;end,});// ==========  waba.io.Stream// abstract (more for docs)// ?? generate error for any method actually called hereDefineGlobalConstant('|waba.io.Stream|, {_proto: |waba.Object|,/** * Reads bytes from the stream. Returns the * number of bytes actually read or -1 if an error prevented the * read operation from occurring. * @param buf the byte array to read data into * @param start the start position in the array * @param count the number of bytes to read *//*int*/ readBytes: func(/*byte[]*/ buf, int start, int count) nil,/** * Writes bytes to the the stream. Returns the * number of bytes actually written or -1 if an error prevented the * write operation from occurring. * @param buf the byte array to write data from * @param start the start position in the byte array * @param count the number of bytes to write *//*int*/ writeBytes: func(/*byte[]*/ buf, int start, int count) nil,/** * Closes the stream. Returns true if the operation is successful * and false otherwise. *//*boolean*/ close: func() nil,});// ==========  ns.serialDeclareGlobalFn('ClearVBOCache, 1);constant kEventDisconnect	:= 2;constant kEventRelease		:= 3;constant kBinaryFormat := true;DefineGlobalConstant('kSetClone, func(obj, ARRAY path, val)begin	if isReadonly(obj)	then obj := Clone(obj);	local nobj := obj;	local INT i, last := Length(path)-1;	foreach i,path1 in path	do nobj := nobj.(path1) := if i=last then val else Clone(nobj.(path1));	obj;end);// ==========  ns.SocketDefineGlobalConstant('kSocketEndPoint, {_proto: protoBasicEndPoint,       configOptions: [	{label:	"inet",	type:	'service,	opCode:	opSetRequired,	result:	nil,	},	{label:	"ilid",			// set the link id	type:	'option,	opCode:	opSetRequired,	result:	nil,	form:	'template,	data:	{		arglist: [nil],		// ** linkID		typelist:	[			'struct,			'ulong,			],		},	},			{label:	"itsv",			// set the transport protocol (TCP or UCP)	type:	'option,	opCode:	opSetRequired,	result:	nil,	form:	'template,	data: {		arglist: [1],		// **?? protocol (here TCP)		typelist: [			'struct,			'ulong,			],		},	}],bindOptions: [	{label:		"ilpt",				// set the local port	type:		'option,	opCode:		opSetRequired,	result:		nil,	form:		'template,	data:	{		arglist: [			0,				// local port number /**/			true,			// use default port	 /**/			],		typelist:	[			'struct,			'short,			'boolean,			],		},	}],connectOptions: [	{label:	"itrs",			// set the TCP remote socket	type:	'option,	opCode:	opSetRequired, //***	result:	nil,	form:	'template,	data:	{		arglist: nil,		/**/		/*	[			remoteAddr[0],	// remote host addr - byte 1			remoteAddr[1],	// remote host addr - byte 2			remoteAddr[2],	// remote host addr - byte 3			remoteAddr[3],	// remote host addr - byte 4			remotePort,		// remote port number 			],			*/				typelist: [			'struct,			'byte,			'byte,			'byte,			'byte,			'short,			],		},	}],//exceptionHandler: func(ex) Print(ex),eventHandler: //kSerialEndPoint.eventHandler,func(ev)if premDisc and	(ev.eventCode = kEventDisconnect or	ev.eventCode = kEventRelease)then begin	premDisc := nil;	// only once	try :Input()	onexception |evt.ex|	do nil;	end,premDisc: true,/*byte[]*/ data: nil,/*int*/ offset: 0,/*int*/ length: 0,/*int*/ total: 0, // mainly for debug (see CompletionScript)/*boolean*/ eof: nil,/*void*/ addBytes: //kSerialEndPoint.addBytes,func(bytes, int len)begin	local int pos := offset + length;	length := length + len;	total := total + len;	if not data	then data := MakeBinary(128,'bytes)	else if pos < Length(data)	then nil	// ok	else if pos < 2048 or IsVBO(data)	then SetLength(data, pos+128) // extend current data	else begin // alloc vbo, copy prev data		local vbo := GetDefaultStore():NewVBO(EnsureInternal('bytes), 4096);		BinaryMunger(vbo, offset, length, data, offset, length);		ClearVBOCache(vbo);		data := vbo;		end;//GetRoot():Notify(kNotifyMessage, "addBytes", offset && length);	if kBinaryFormat	then if len=1		then StuffByte(data, pos, ExtractByte(bytes,0))		else BinaryMunger(data,pos,len, bytes,0,len)	else begin		local int i;		for i:=0 to len-1		do StuffByte(data, pos+i, bytes[i]);		end;end,});// _very_ inefficient, but should avoid problems with waiting synchronously, partial input and unknown total lengthDefineGlobalConstant('kInputSpec, {	async:		true,	reqTimeout:	60000, // kNoTimeout 	form: 		if kBinaryFormat then 'binary else 'bytes,	termination: {byteCount: 1},	InputScript: func(ep, data, terminator, options)		ep:addBytes(data, terminator.byteCount),	CompletionScript: func(ep, options, result)	beginGetRoot():Notify(kNotifyQAlert, EnsureInternal("CompletionScript"), "err: " && result & "; total:" && ep.total);//call kFixRootParent with (nil);		ep.eof := true;	end,});// ==========  waba.io.SocketDeclareGlobalFn('InetOpenConnectionSlip, 3);DeclareGlobalFn('InetGrabLink, 3);DeclareGlobalFn('InetIsValidIPAddressStr, 1);DeclareGlobalFn('InetIPStringToAddress, 1);DeclareGlobalFn('DNSGetAddressFromName, 3);DeclareGlobalFn('InetReleaseLinkVerbose, 3);/** * Socket is a TCP/IP network socket. * <p> * Under Java and Windows CE, if no network is present, the socket * constructor may hang for an extended period of time due to the * implementation of sockets in the underlying OS. This is a known * problem. * <p> * Here is an example showing data being written and read from a socket: * * <pre> * Socket socket = new Socket("www.yahoo.com", 80); * if (!socket.isOpen()) *   return; * byte buf[] = new byte[10]; * buf[0] = 3; * buf[1] = 7; * socket.writeBytes(buf, 0, 2); * int count = socket.readBytes(buf, 0, 10); * if (count == 10) *   ... * socket.close(); * </pre> */DefineGlobalConstant('|waba.io.Socket|, {_proto: |waba.io.Stream|,_className: "waba.io.Socket",_endPoint: nil,_timeout: 1500,/** * Opens a socket. This method establishes a socket connection by * looking up the given host and performing the 3 way TCP/IP handshake. * @param host the host name or IP address to connect to * @param port the port number to connect to */SocketCreate: func(/*String*/ host, int port)	return {_proto: self}:_init(host, port),_address: nil,_linkID: nil,_status: nil,progressOptions: {	closebox: nil,	titleText: "init",	statusText: "waba.io.Socket",	barber: true,	},_init: func(/*String*/ host, int port)	// INTERNALbegin	local kWaitFunc := func(view)		begin			//call kFixRootParent with (view);			while (_status <> 'error and _status <> 'done)			do begin				view:setStatus('vBarber, {barber: true, titleText: SPrintObject(_status)});				sleep(10);				end;		end;if _DEBUG then Print([host,port]);	local state := "NIE", options, view;	_status := 'waiting;if _DEBUG then Print([_status, state]);	if view := InetOpenConnectionSlip(nil, self, '_connectionSlipCallback)	then begin		view:hide();		//if view:parent() <> GetRoot() then view._parent := GetRoot(); // see kFixRootParent		view:ModalDialog();		//view:SyncView();		end;	if _status = 'error	then return :_notifyErr(state, nil);if _DEBUG then Print([_status, state]);	_status := 'waiting;	state := "GrabLink";if _DEBUG then Print([_status, state]);	InetGrabLink(_linkID, self, '_grabLinkCallback);	if DoProgress('vBarber, {_proto: progressOptions, statusText: state}, kWaitFunc) = 'cancelled	then _status := 'error;	if _status = 'error or not _linkID	then return :_notifyErr(state, nil);if _DEBUG then Print([_status, state, _linkID]);	_status := 'waiting;	state := "DNS:" && host;if _DEBUG then Print([_status, state]);	if InetIsValidIPAddressStr(host)	// e.g., 205.134.252.158	then _address := InetIPStringToAddress(host);	else begin		DNSGetAddressFromName(host, self, '_getAddressCallback);		if DoProgress('vBarber, {_proto: progressOptions, statusText: state}, kWaitFunc)  = 'cancelled		then _status := 'error;		end;	if _status = 'error or not IsArray(_address)	then return :_notifyErr(state, NIL);if _DEBUG then Print([_status, state, _address]);	state := "Instantiate";if _DEBUG then Print([state]);	_endPoint := {        	_proto:	kSocketEndPoint,      	};	options := call kSetClone with (_endPoint.configOptions, '[pathExpr: 1,data,arglist], [_linkID]);	try _endPoint:Instantiate(_endPoint, options);	onexception |evt.ex|	do return :_notifyErr(state, NIL);	state := "Bind";if _DEBUG then Print([state]);	try _endPoint:Bind(_endPoint.bindOptions, nil)	onexception |evt.ex|	do return :_notifyErr(state, NIL);	state := "Connect";if _DEBUG then Print([state]);	options := call kSetClone with (_endPoint.connectOptions, '[pathExpr: 0,data,arglist], SetAdd(Clone(_address), port, nil));	try _endPoint:Connect(options, nil);	onexception |evt.ex|	do return :_notifyErr(state, NIL);if _DEBUG then Print(["inputSpec"]);	_endPoint:setInputSpec(		if kBinaryFormat		then {			_proto: kInputSpec,			target: {data: MakeBinary(1,'bytes)}, // for form: binary			}		else kInputSpec);if _DEBUG then Print(["init done"]);	return self;end,_connectionSlipCallback: func(what)begin	_status :=		if what = 'connect		then 'done		else if what = 'close		then 'error		else what;end,_grabLinkCallback: func(linkID, status, error)	if error	then _status := 'error	else if status.linkStatus = 'Connected	then begin		_linkID := linkID;		_status := 'done;		end	else _status := status.linkStatus,_getAddressCallback: func(results, error)begin	if error		or not results		or Length(results) < 1	then return _status := 'error;		_address := results[0].resultIPAddress;	_status := 'done;end,_releaseLinkCallback: func(linkID, newStatus, error)	nil,	// ignore/** * Closes the socket. Returns true if the operation is successful * and false otherwise. *//*boolean*/ SocketClose: //_close: // |waba.io.SerialPort|.SerialPortClose, // *** INTERNALfunc()if _endPointthen begin	// ?? just ignore errors	try _endPoint:Cancel(nil)	onexception |evt.ex.comm|	do nil; //:_notifyErr("Cancel", nil);	_endPoint:setInputSpec(nil);	try _endPoint:Disconnect(nil,nil)	onexception |evt.ex.comm|	do nil; //:_notifyErr("Disconnect", nil);	try _endPoint:UnBind(nil)	onexception |evt.ex.comm|	do nil; //:_notifyErr("Unbind", nil);	try _endPoint:Dispose()	onexception |evt.ex.comm|	do nil; //:_notifyErr("Dispose", nil);	_endPoint := nil;	if _linkID	then InetReleaseLinkVerbose(_linkID, self, '_releaseLinkCallback);	return true;	endelse return false,/** * Returns true if the socket is open and false otherwise. This can * be used to check if opening the socket was successful. *//*boolean*/ SocketIsOpen: // |waba.io.SerialPort|.SerialPortIsOpen,  // *** func() return _endPoint <> nil,func()	return _endPoint <> nil,/** * Sets the timeout value for read operations. The value specifies * the number of milliseconds to wait from the time of last activity * before timing out a read operation. Passing a value of 0 sets * no timeout causing any read operation to return immediately with * or without data. The default timeout is 1500 milliseconds. This * method returns true if successful and false if the value passed * is negative or the socket is not open. Calling this method * currently has no effect under Win32 or WindowsCE. The * read timeout under those platforms will remain the system default. * @param millis timeout in milliseconds *//*boolean*/ SocketSetReadTimeout: // |waba.io.SerialPort|.SerialPortSetReadTimeout,	// ***func(int millis)if (millis >= 0 and _endPoint)then begin	_timeout := millis;	return true;	endelse return false,_writeFrame: nil,_readFrame: // |waba.io.SerialPort|._readFrame,	{data: MakeBinary(0,'bytes), offset: 0, length: -1},/** * Reads bytes from the port into a byte array. Returns the * number of bytes actually read or -1 if an error prevented the read * operation from occurring. The read will timeout if no activity * takes place within the timeout value for the port. * @param buf the byte array to read data into * @param start the start position in the byte array * @param count the number of bytes to read * @see #setReadTimeout *//*byte_frame*/ SocketRead: 					//|waba.io.SerialPort|.SerialPortRead,		// ***func(int count)if _endPointthen begin	local int avail := _endPoint.length, offset := _endPoint.offset;	if avail=0 and _endPoint.eof	then return _readFrame;	local /*byte[]*/ data := _endPoint.data;	//GetRoot():Notify(kNotifyQAlert, "SocketRead", count && offset && avail);	local /*byte_frame*/ bframe := {		data: if data then data else _readFrame.data, offset: offset, length: min(count,avail)};	if avail > 0	then begin // return just what's already avail (ignore timeout)		if count < avail		then begin			_endPoint.offset := offset + count;			_endPoint.length := avail  - count;			end		else // read all of current buffer (reset ptrs)			_endPoint.offset := _endPoint.length := 0;		end;	return bframe;	endelse	return _readFrame,/*When the Waba user tries to write N bytes, I get handed a byte array and alength N and an offset F.  Here's what I do:	myFrame <- SerialPortGetByteFrame(N)	for x=0 to N		fill in myFrame.data[x] with byteArray[x+F]	myFrame.len = N	realAmountWrittenOrError <- SerialPortWrite(myFrame)	return realAmountWrittenOrError as the Waba method's return valueSo I call FooGetByteFrameForWrite(...) every single time I callFooWrite(...).  Then I forget about the frame.  This allows you to reusethe same frame (and its binary object) in a cache under the assumptionthat I might do multiple writes in quick succession, so you don't have toreallocate a binary object for every single write.*//*byte_frame*/ SocketGetByteFrameForWrite: 	//|waba.io.SerialPort|.SerialPortGetByteFrameForWrite,	// *** INTERNALfunc(int count)	// VM INTERNALbegin	if not _writeFrame or Length(_writeFrame.data) < count	then _writeFrame := {data: MakeBinary(count,'binary), offset: 0, length: count}	else begin		_writeFrame.offset := 0;		_writeFrame.length := count;		end;	return _writeFrame;end,/** * Writes to the port. Returns the number of bytes written or -1 * if an error prevented the write operation from occurring. If data * can't be written to the port and flow control is on, the write * operation will time out and fail after approximately 2 seconds. * @param buf the byte array to write data from * @param start the start position in the byte array * @param count the number of bytes to write *//*int*/ SocketWrite: 						//|waba.io.SerialPort|.SerialPortWrite,	// ***func(/*byte_frame*/ frame)if _endPointthen begin	_endPoint:Output(frame.data, nil, frame); // frame has offset:, length:	return frame.length;	endelse	return frame.length := -1,/** * Reads bytes from the socket into a byte array. Returns the * number of bytes actually read or -1 if the server closed * the connection or an error prevented the read operation from * occurring. * @param buf the byte array to read data into * @param start the start position in the byte array * @param count the number of bytes to read *//*int*/ readBytes:  // |waba.io.SerialPort|.readBytes	func(/*byte[]*/ buf, int start, int count)	begin		local /*byte_frame*/ bframe := :SocketRead(count); // !!		count := bframe.length;		if count > 0		then BinaryMunger(buf,start,count, bframe.data,bframe.offset,count);		return count;	end,/** * Writes to the socket. Returns the number of bytes written or -1 * if an error prevented the write operation from occurring. If data * can't be written to the socket for approximately 2 seconds, the * write operation will time out. * @param buf the byte array to write data from * @param start the start position in the byte array * @param count the number of bytes to write *//*int*/ writeBytes: // |waba.io.SerialPort|.writeBytes	func(/*byte[]*/ buf, int start, int count)	if _endPoint	then begin		_endPoint:Output(buf, nil, if start > 0 or count <> Length(buf) then {offset: start, length: count});		return count;		end	else		return -1,});/*void*/ |waba.io.Socket|.SocketDestroy 	:= |waba.io.Socket|.SocketClose;	// ***. share// *** for "Waba direct" testing w/o VM/*Socket*/ |waba.io.Socket|.new 			:= |waba.io.Socket|.SocketCreate;/*void*/ |waba.io.Socket|.close 			:= |waba.io.Socket|.SocketClose;/*boolean*/ |waba.io.Socket|.isOpen 		:= |waba.io.Socket|.SocketIsOpen;/*boolean*/ |waba.io.Socket|.setReadTimeout := |waba.io.Socket|.SocketSetReadTimeout;/*GetRoot().|VM:waba|.SocketCreate :=	func(host, port)	// |waba.io.Socket|:SocketCreate(host, port);	GetRoot().|waba.io:TKnollSys|.Socket:SocketCreate(host, port);GetRoot().|waba.io:TKnollSys|.Socket*/