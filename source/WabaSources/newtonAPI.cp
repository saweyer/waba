/*NewtonScript API FunctionsThese functions define the basic access functions for creating, destroying,modifying, and calling NewtonScript objects in the NewtonScript interpreter.You access this API through the newton/Ref and newton/Callback Java classes.*/ // The definition of WOBJ_Ref has been moved to waba.h since it's used// both here and in nmnewt_b.cpvoid VM::RefDestroy(WObject obj)    {	deleteRefStruct(WOBJ_Ref(obj));    }// We know that *some* buiding function will be used// to create the Ref, so we can safely assume that we// can freely initialize in these functionsVar VM::RefBuildArray(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    int size = stack[1].intValue;    if (size<0) size=0;    setRefStruct(ref,AllocateArray(SYM(array), size));    return result;    }Var VM::RefBuildBinary(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    int size = stack[1].intValue;    if (size<0) size=0;    setRefStruct(ref,AllocateBinary(getRefStruct(WOBJ_Ref(stack[2].obj)), size));    return result;    }Var VM::RefBuildChar(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);        /// ... what a hack!  Because there's no MakeUniChar function in    /// C++ API.  :-(        setRefStruct(ref,MAKEINT(stack[1].intValue));    setRefStruct(ref,NSCallGlobalFn(SYM(Char),getRefStruct(ref)));        return result;    }Var VM::RefBuildFloat(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    // NewtonScript reals are doubles -- we just pass in a float    setRefStruct(ref,MakeReal(stack[1].floatValue));    return result;    }Var VM::RefBuildFrame(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    setRefStruct(ref,AllocateFrame());    return result;    }Var VM::RefBuildInt(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    // NewtonScript ints are only 30 bytes -- I don't know what    // will happen if we try to set a bigger int to it!    setRefStruct(ref,MAKEINT(stack[1].intValue));    return result;    }Var VM::RefBuildNil(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    setRefStruct(ref,NILREF);    return result;    }Var VM::RefBuildString(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    setRefStruct(ref,WabaStringToNewtonString(stack[1].obj));    return result;    }Var VM::RefBuildSymbol(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    initRefStruct(ref);    // we could have just returned Intern(string), but    // that wouldn't have allowed for unicode symbols    setRefStruct(ref,NSCallGlobalFn(SYM(intern),WabaStringToNewtonString(stack[1].obj)));    return result;    }Var VM::RefCall(Var stack[])    {    Var result; result.obj = 0;    RefStruct** func= WOBJ_Ref(stack[0].obj);    Var* arrayptr= objectPtr(stack[1].obj);    int arraylen= WOBJ_arrayLenP(arrayptr);    WObject* array= (WObject*)WOBJ_arrayStartP(arrayptr);        RefStruct** callResult = WOBJ_Ref(stack[2].obj);    volatile Ref callResult2;  // it ain't good to be using Ref, but                               // the compiler refuses to allow volatile RefVars    volatile int resultSet = 0;    // first question: am I a function pointer or a symbol  Is arraylen right?    if (IsSymbol(getRefStruct(func)) && arraylen >= 0)        {                // if we're passing in an arg array, here's how we'll do it...        RefVar args;        if (arraylen > 6)            {            args = AllocateArray(SYM(array),arraylen);            for(int x=0;x<arraylen;x++)                SetArraySlot(args,x,getRefStruct(WOBJ_Ref(array[x])));            }                    newton_try        {        // we can call up to 6 long with a switch, else we'll        // have to build an array        switch(arraylen)            {            case 0:            //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func)             callResult2 = NSCallGlobalFn(getRefStruct(func)                ); break;            case 1:                //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func),                callResult2 = NSCallGlobalFn(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0]))                ); break;            case 2:                //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func),                callResult2 = NSCallGlobalFn(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1]))                ); break;            case 3:                //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func),                callResult2 = NSCallGlobalFn(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2]))                ); break;            case 4:                //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func),                callResult2 = NSCallGlobalFn(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3]))                ); break;            case 5:                //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func),                callResult2 = NSCallGlobalFn(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3])),                    getRefStruct(WOBJ_Ref(array[4]))                ); break;            case 6:                //setRefStruct(callResult,NSCallGlobalFn(getRefStruct(func),                callResult2 = NSCallGlobalFn(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3])),                    getRefStruct(WOBJ_Ref(array[4])),                    getRefStruct(WOBJ_Ref(array[5]))                ); break;            default:                // we made an array first.                // now make the call                //setRefStruct(callResult,NSCallGlobalFnWithArgArray(getRefStruct(func),                callResult2 = NSCallGlobalFnWithArgArray(getRefStruct(func),                    args); break;            }            }        newton_catch_all  // any exception            {            resultSet = 1;            setRefStruct(callResult, Intern(CurrentException()->name));            }        end_try;        if (!resultSet)            {            RefVar tmpref = callResult2;            setRefStruct(callResult,tmpref);            }                    return stack[2];        }    else if (IsFunction(getRefStruct(func)) && arraylen >= 0)        {        // if we're passing in an arg array, here's how we'll do it...        RefVar args;        if (arraylen > 6)            {            args = AllocateArray(SYM(array),arraylen);            for(int x=0;x<arraylen;x++)                SetArraySlot(args,x,getRefStruct(WOBJ_Ref(array[x])));            }                    // we can call up to 6 long with a switch, else we'll        // have to build an array        newton_try            {        switch(arraylen)            {            case 0:                //setRefStruct(callResult,NSCall(getRefStruct(func)                callResult2 = NSCall(getRefStruct(func)                ); break;            case 1:                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCall(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0]))                ); break;            case 2:                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCall(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1]))                ); break;            case 3:                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCall(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2]))                ); break;            case 4:                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCall(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3]))                ); break;            case 5:                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCall(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3])),                    getRefStruct(WOBJ_Ref(array[4]))                ); break;            case 6:                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCall(getRefStruct(func),                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3])),                    getRefStruct(WOBJ_Ref(array[4])),                    getRefStruct(WOBJ_Ref(array[5]))                ); break;            default:                // we already made the array                // now make the call                //setRefStruct(callResult,NSCall(getRefStruct(func),                callResult2 = NSCallWithArgArray(getRefStruct(func),                    args); break;            }            }        newton_catch_all  // any exception            {            resultSet = 1;            setRefStruct(callResult, Intern(CurrentException()->name));            }        end_try;        if (!resultSet)            {            RefVar tmpref = callResult2;            setRefStruct(callResult,tmpref);            }                    return stack[2];        }    return result;    }Var VM::RefCharValue(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    if (ISCHAR(getRefStruct(ref)))        result.intValue = RCHAR(getRefStruct(ref));    return result;    }Var VM::RefGetBytes(Var stack[])    {    Var result; result.intValue = -1;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    int refStart = stack[1].intValue;    int putInStart = stack[2].intValue;    int numBytesToGet = stack[3].intValue;    Var* arrayptr = objectPtr(stack[4].obj);    signed char* putInHere = (signed char*) WOBJ_arrayStartP(arrayptr);    int putInHereLen = WOBJ_arrayLenP(arrayptr);        if (IsBinary(getRefStruct(ref)))        {        // get the length of the binary in bytes        int len = Length(getRefStruct(ref))-refStart;        if (len > putInHereLen - putInStart) len = putInHereLen - putInStart;        if (len > numBytesToGet) len = numBytesToGet;        if (len >= 0)  // there's a valid length            {            WITH_LOCKED_BINARY(getRefStruct(ref),refptr)            xmemmove(&arrayptr[putInStart],&((signed char*)refptr)[refStart],len);            END_WITH_LOCKED_BINARY(getRefStruct(ref))            result.intValue = len;            }        }    return result;    }Var VM::RefGetClass(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** place = WOBJ_Ref(stack[1].obj);    if (IsBinary(getRefStruct(ref)) || IsFrame(getRefStruct(ref)) ||         IsArray(getRefStruct(ref)) ||         IsReal(getRefStruct(ref)) || IsString(getRefStruct(ref)))            { result = stack[1]; setRefStruct(place,ClassOf(getRefStruct(ref))); }       return result;    }Var VM::RefGetLength(Var stack[])    {    Var result; result.intValue = -1;  // our default return value    RefStruct** ref = WOBJ_Ref(stack[0].obj);    if (IsBinary(getRefStruct(ref)) ||        IsArray(getRefStruct(ref)) ||        IsString(getRefStruct(ref)))            result.intValue = Length(getRefStruct(ref));        return result;    }Var VM::RefGetPath(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** path = WOBJ_Ref(stack[1].obj);    RefStruct** place = WOBJ_Ref(stack[2].obj);    if (IsFrame(getRefStruct(ref)) && IsSymbol(getRefStruct(path)))        { result = stack[2]; setRefStruct(place,GetFramePath(getRefStruct(ref),getRefStruct(path))); }    return result;    }Var VM::RefGetArraySlot(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** place = WOBJ_Ref(stack[1].obj);    int slot = stack[1].obj;    if (IsArray(getRefStruct(ref)) &&        slot >= 0 &&         slot < RINT(Length(getRefStruct(ref))))        { result = stack[1]; setRefStruct(place,GetArraySlot(getRefStruct(ref),slot)); }    return result;    }Var VM::RefGetFrameSlot(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** slot = WOBJ_Ref(stack[1].obj);    RefStruct** place = WOBJ_Ref(stack[2].obj);    if (IsFrame(getRefStruct(ref)) &&        IsSymbol(getRefStruct(slot)))        { result = stack[2]; setRefStruct(place,GetFrameSlot(getRefStruct(ref),getRefStruct(slot))); }    return result;    }Var VM::RefIntValue(Var stack[])    {    Var result; result.intValue = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    if (ISINT(getRefStruct(ref)))        result.intValue = RINT(getRefStruct(ref));    return result;    }Var VM::RefFloatValue(Var stack[])    {    Var result; result.intValue = -1;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    if (IsReal(getRefStruct(ref)))        {        WITH_LOCKED_BINARY(getRefStruct(ref),refptr)        result.floatValue = (float)*((double*)refptr);                END_WITH_LOCKED_BINARY(getRefStruct(ref))        }    return result;    }Var VM::RefPush(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** val = WOBJ_Ref(stack[1].obj);    if (IsArray(getRefStruct(ref)))        {        result = stack[0]; // return me        AddArraySlot(getRefStruct(ref),getRefStruct(val));        }    return result;    }Var VM::RefSend(Var stack[])    {    // must declare them  because we're using newton_try     Var result;    result.obj = 0;     RefStruct** myself = WOBJ_Ref(stack[0].obj);     RefStruct** func = WOBJ_Ref(stack[1].obj);     Var* arrayptr = objectPtr(stack[2].obj);     int arraylen = WOBJ_arrayLenP(arrayptr);     WObject* array = (WObject*)WOBJ_arrayStartP(arrayptr);          RefStruct** callResult = WOBJ_Ref(stack[3].obj);    volatile Ref callResult2;  // it ain't good to be using Ref, but                               // the compiler refuses to allow volatile RefVars    volatile int resultSet = 0;   // Make sure I'm a frame and the method is a symbol    if (IsFrame(getRefStruct(myself)) && IsSymbol(getRefStruct(func)) && arraylen >= 0)        {                // if we're passing in an arg array, here's how we'll do it...        RefVar args;        if (arraylen > 6)            {            args = AllocateArray(SYM(array),arraylen);            for(int x=0;x<arraylen;x++)                SetArraySlot(args,x,getRefStruct(WOBJ_Ref(array[x])));            }                    newton_try            {        // we can call up to 6 long with a switch, else we'll        // have to build an array        switch(arraylen)            {            case 0:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func)                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                ); break;            case 1:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                    getRefStruct(WOBJ_Ref(array[0]))                ); break;            case 2:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1]))                ); break;            case 3:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2]))                ); break;            case 4:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3]))                ); break;            case 5:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3])),                    getRefStruct(WOBJ_Ref(array[4]))                ); break;            case 6:                callResult2 = NSSend(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSend(getRefStruct(myself),getRefStruct(func)                    getRefStruct(WOBJ_Ref(array[0])),                    getRefStruct(WOBJ_Ref(array[1])),                    getRefStruct(WOBJ_Ref(array[2])),                    getRefStruct(WOBJ_Ref(array[3])),                    getRefStruct(WOBJ_Ref(array[4])),                    getRefStruct(WOBJ_Ref(array[5]))                ); break;            default:                // we already made the array                // now make the call                callResult2 = NSSendWithArgArray(getRefStruct(myself),getRefStruct(func),                //setRefStruct(callResult,NSSendWithArgArray(getRefStruct(myself),getRefStruct(func),                    args); break;            }            }        newton_catch_all  // any exception            {            resultSet = 1;            setRefStruct(callResult, Intern(CurrentException()->name));            }        end_try;        if (!resultSet)            {            RefVar tmpref = callResult2;            setRefStruct(callResult,tmpref);            }                    return stack[3];        }        else if (!IsFrame(getRefStruct(myself)))            PRINTSTR("Send sent to non-frame!");        else PRINTSTR("Send used non-symbol!");    return result;    }Var VM::RefSetBytes(Var stack[])    {    Var result; result.intValue = -1;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    int refStart = stack[1].intValue;    int getFromStart = stack[2].intValue;    int numBytesToGet = stack[3].intValue;    Var* arrayptr = objectPtr(stack[4].obj);    Var* putInHere = WOBJ_arrayStartP(arrayptr);    int putInHereLen = WOBJ_arrayLenP(arrayptr);        if (IsBinary(getRefStruct(ref)))        {        // get the length of the binary in bytes        int len = Length(getRefStruct(ref))-refStart;        if (len > putInHereLen - getFromStart) len = putInHereLen - getFromStart;        if (len > numBytesToGet) len = numBytesToGet;        if (len >= 0)  // there's a valid length            {            WITH_LOCKED_BINARY(getRefStruct(ref),refptr)            // an ugly approach but unfortunately Waba uses            // int arrays for byte arrays :-(                for(int x=0;x<len;x++)                    ((signed char*)refptr)[x+refStart] = (signed char)(arrayptr[x+getFromStart].intValue) ;            END_WITH_LOCKED_BINARY(getRefStruct(ref))            result.intValue = len;            }        }    return result;    }Var VM::RefSetClass(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** val = WOBJ_Ref(stack[1].obj);    if ((IsBinary(getRefStruct(ref)) || IsFrame(getRefStruct(ref)) || IsArray(getRefStruct(ref)) ||        IsReal(getRefStruct(ref)) || IsString(getRefStruct(ref))) &&            (IsSymbol(getRefStruct(val))))        {        result = stack[0];        SetClass(getRefStruct(ref),getRefStruct(val));        }    return result;    }Var VM::RefSetLength(Var stack[])    {    Var result; result.intValue = -1;  // our return value    RefStruct** ref = WOBJ_Ref(stack[0].obj);    int len = stack[1].intValue;    if (IsArray(getRefStruct(ref)) &&        len >= 0)        {        SetLength(getRefStruct(ref),len);        result.intValue = RINT(Length(getRefStruct(ref)));        }    return result;    }Var VM::RefSetArraySlot(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    int len = stack[1].intValue;    RefStruct** val = WOBJ_Ref(stack[2].obj);    if (IsArray(getRefStruct(ref)) &&        len >= 0)        {        SetArraySlot(getRefStruct(ref),len,getRefStruct(val));        result = stack[0];        }    return result;    }Var VM::RefSetFrameSlot(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    RefStruct** sym = WOBJ_Ref(stack[1].obj);    RefStruct** val = WOBJ_Ref(stack[2].obj);    if (IsFrame(getRefStruct(ref)) && IsSymbol(getRefStruct(sym)))        {        SetFrameSlot(getRefStruct(ref),getRefStruct(sym),getRefStruct(val));        result = stack[0];        }    return result;    }Var VM::RefStringValue(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    if (IsString(getRefStruct(ref)))        result.obj = NewtonStringToWabaString(getRefStruct(ref));    return result;    }Var VM::RefSymbolValue(Var stack[])    {    Var result; result.obj = 0;    RefStruct** ref = WOBJ_Ref(stack[0].obj);    // I can't think of any better way to get the symbol value out.  :-(    if (IsSymbol(getRefStruct(ref)))        result.obj = NewtonStringToWabaString(NSCallGlobalFn(SYM(SPrintObject),(getRefStruct(ref))));    return result;    }#define _NIL 0#define _INT 1#define _CHAR 2#define _SYMBOL 3#define _FRAME 4#define _ARRAY 5#define _FLOAT 6#define _STRING 7#define _BINARY 8#define _FUNCTION 9#define _MAGIC 10#define _UNKNOWN 11Var VM::RefType(Var stack[])    {    Var result; result.intValue = _UNKNOWN;    Ref r = getRefStruct(WOBJ_Ref(stack[0].obj));    if (ISNIL(r)) result.intValue = _NIL;    else if (IsMagicPtr(r)) result.intValue = _MAGIC;    else if (IsFrame(r)) result.intValue = _FRAME;    else if (IsArray(r)) result.intValue = _ARRAY;    else if (IsString(r)) result.intValue = _STRING;    else if (ISINT(r)) result.intValue = _INT;    else if (IsSymbol(r)) result.intValue = _SYMBOL;    else if (ISCHAR(r)) result.intValue = _CHAR;    else if (IsReal(r)) result.intValue = _FLOAT;    else if (IsBinary(r)) result.intValue = _BINARY;    else if (IsFunction(r)) result.intValue = _FUNCTION;    return result;    }Var VM::CallbackFunc(Var stack[])    {    // get our VM pointer stored in a RefVar    RefVar _vm = AllocateBinary(SYM(vm),4);  // 4 bytes of class 'vm    WITH_LOCKED_BINARY(_vm,vmptr)		*(VM**)vmptr = this;	END_WITH_LOCKED_BINARY(_vm)        // get our id    int id = WOBJ_CallbackID(stack[0].obj);    RefStruct** func = WOBJ_Ref(stack[1].obj);    // get our num args    WObject array = WOBJ_CallbackArgs(stack[0].obj);    int len;    if (array==0)  // oops        {        PRINTSTR("Bad Array in CallbackFunc!");        len = 0;  // we'll deal with this later, yikes!        }    else len = WOBJ_arrayLen(array);        // set the func	RefVar mainVmApp = GetFramePath(NSCallGlobalFn(SYM(GetRoot)),Intern("VM:waba"));    setRefStruct(func,NSSend(mainVmApp,SYM(buildCallbackFunc),_vm,MAKEINT(id),MAKEINT(len)));        // return our func, such as it is    return stack[1];    }#define NSOBJECT_VM 100#define NSOBJECT_WINDOW 101#define NSOBJECT_NEWTONTYPE 200Var VM:: NSObject(Var stack[])    {    Var result; result.obj = 0;    int val = stack[0].intValue;    RefStruct** ref = WOBJ_Ref(stack[1].obj);    RefVar me = NULL;    switch(val)        {        case NSOBJECT_VM:         	me = AllocateBinary(SYM(vm),4);  // 4 bytes of class 'vm                WITH_LOCKED_BINARY(me,meptr)                    *(VM**)meptr = this;                END_WITH_LOCKED_BINARY(me)                setRefStruct(ref,me);                return stack[1];                break;        case NSOBJECT_WINDOW:                setRefStruct(ref,getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin)));                return stack[1];                break;        case NSOBJECT_NEWTONTYPE:                setRefStruct(ref,MAKEINT(newtonType));                return stack[1];                break;        }    return result;    }    Var VM:: NSProto(Var stack[])    {    Var result; result.obj = 0;    RefVar sym = getRefStruct(WOBJ_Ref(stack[0].intValue));    RefStruct** ref = WOBJ_Ref(stack[1].obj);        RefVar mainVmApp = GetFramePath(NSCallGlobalFn(SYM(GetRoot)), Intern("VM:waba"));    setRefStruct(ref, NSSend(mainVmApp,SYM(GetProto),sym));        return stack[1];    }    