/*Copyright (C) 1998, 1999, 2000 WabasoftThis program is free software; you can redistribute it and/or modify it underthe terms of the GNU General Public License as published by the Free SoftwareFoundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANYWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along withthis program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave,Cambridge, MA 02139, USA. *//*If you're looking here, you've probably already looked at (or worked on) thenm<platform>_a.c file.This file is the second step in porting the VM. In it, you need to place themain application loop and class loader. If you get through this, you'll havea basic VM running and from there you can implement the native functionsso you can actually see something on the screen.The WabaVM, like other applications, needs some type of main application loopwhere the OS sends it key clicks, mouse presses, etc. The VM also needs toload classes from memory or disk or wherever.Different platforms have different main application loops. For example, underWin32, a program has a WinMain() function. Under PalmOS, applications havea PilotMain() function.You'll want to implement a main application loop for the platform you areporting to. Then, when things start up (initialization), you need to:- parse the launch command and then call VmInit()- call VmStartApp passing the class name of the program's main windowYou'll also need to figure out how programs will launch the VM. The VMis normally passed parameters telling it what class heap, class name, etc.to use. It's usually another program that does this but you could do itby building a waba launcher that draws a tray of icons and when you clickone, it runs the WabaVM with various parameters as an example of somethingdifferent. Whatever you do for this is platform-specific.Just before the program exits, you'll should call VmStopApp(mainWinObj);That's it for initialization and exit, then you need to do some work tohook up key presses, mouse presses, etc. to the VM. When a key is pressed,you'll want to invoke the main window's onEvent() method. Here's anexample of how to do that:	mainWinObj = globalMainWin;	if (!mainWinObj)		return;	vclass = WOBJ_class(mainWinObj); // get runtime class	method = getMethod(vclass, createUtfString("_postEvent"),		createUtfString("(IIIIII)V"), &vclass);	if (method != NULL)		{		params[0].obj = mainWinObj;		params[1].intValue = type; // type		params[2].intValue = key; // key		params[3].intValue = 0; // x		params[4].intValue = 0; // y		params[5].intValue = 0; // modifiers		params[6].intValue = 0; // timeStamp		executeMethod(vclass, method, params, 7);		}This gets the runtime class of the main window object, gets areference to the _postEvent method, fills in an array of parametersto pass and then calls executeMethod() to execute the method.There is also a quickbind version of this which is quicker than theabove. You can look at nmpalm_b.c or nmwin32_b.c to get an idea howthat works (look for the #ifdef QUICKBIND) but you should startwithout using the quickbind method.You'll want to hook up mouse or pen click, key presses, calls fromthe OS to repaint the window (which should call the main window's_doPaint routine).Overall, you need to make sure the following main window functionsget called:_onTimerTick()_postEvent() for key presses and mouse/pen clicks and movesYou'll need to map special keys (escape, etc.) if the device hasthem to suitable numbers for waba. To do this, you can see how theother native implementations do key mapping (a big switch statement).The _onTimerTick() one can be tricky for devices that don't havea built in timer (like PalmOS). When using one of those devices,copy the code from the nmpalm_b.c to deal with timers. Basically,this consists of getting the current time and looking for an eventup until the time the next timer period expires.The VM only needs a single timer, the waba core classes have thecode to support multiple timers even though the underlying systemonly supports a single one.The last code you need to implement is:nativeLoadClass()This is the function that load a class from memory, disk or whatever.It looks like this:static uchar *nativeLoadClass(UtfString className, uint32 *size)and it is passed a class name (not zero terminated, the UtfStringcontains the len in:className.lenand it returns a pointer to the class in memory after it is loadedand fills in the *size variable with the size of the class in bytes.	-- NOTE FROM SEAN: This is incorrect.  NULL is passed in for	   size.  See waba.cppThe classes loaded are classes that are compiled by a java compileror other compiler that can generate code in the subset of javabytecode that waba supports.*/// return predicates#define NO_WINDOW -1#define NO_METHOD -2#define SUCCESS 0// types/** The event type for a key press event. */#define KEY_PRESS 100/** The event type for a pen or mouse down event. */#define PEN_DOWN 200/** The event type for a pen or mouse move event. */#define PEN_MOVE 201/** The event type for a pen or mouse up event. */#define PEN_UP 202/** The event type for a pen or mouse drag event. */#define PEN_DRAG 203/** The event type for a pressed event. */  // I have absolutely no idea what this is#define PRESSED 300/** The event type for a focus in event. */#define FOCUS_IN 301/** The event type for a focus out event. */#define FOCUS_OUT 302/** The event type for a timer event. */#define TIMER 303// special Newton "event" for repainting  -- specify repaint rect as x,y,width,height#define REPAINT 4001// special Newton "event" for API callbacks#define CALLBACK 4002// modifiers  --- I assume that you OR these together/** modifier for alt key */#define ALT     (1 << 0)/** modifier for control key */#define CONTROL (1 << 1)/** modifier for shift key */#define SHIFT   (1 << 2)// keys -- the key value is the ASCII value of its character, except// for the following keys:/** special key */#define PAGE_UP  75000/** special key */#define PAGE_DOWN 75001/** special key */#define HOME     75002/** special key */#define END      75003/** special key */#define UP       75004/** special key */#define DOWN     75005/** special key */#define LEFT     75006/** special key */#define RIGHT    75007/** special key */#define INSERT   75008/** special key */#define ENTER    75009/** special key */#define TAB      75010/** special key */#define BACKSPACE 75011/** special key */#define ESCAPE   75012/** special key */#define DELETE   75013/** special key */#define MENU     75014/** special key */#define COMMAND  75015// timestamps are, I believe, in milliseconds// (x,y) values are from the top-left cornerextern "C" Ref PulseNewton(RefArg rcvr, RefArg _vm, RefArg event)    {	// PRINTF( "PulseNewtonÉ\n" );    RefVar result = NILREF;        WITH_LOCKED_BINARY(_vm,vmptr)	    VM* vm = *(VM**)vmptr;	    result = MAKEINT(vm->PulseNewton(event));    END_WITH_LOCKED_BINARY(_vm)	// PRINTF( "ÉPulseNewton\n" );    return result;    }    int VM::PulseNewton(RefArg event)	{    TRACE("==PulseNewton==");        /* event is a frame of the following ints or non-nil/nil flags:	    {	    type:	type (int)	    key:	optional key (int)	    x:		optional x (int)	    y:		optional y (int)	    width:	optional width (int)	    height:	optional height (int)	    option:	optional option (flag if option key is down)	    control:	optional control (flag if control key is down)	    shift:	optional shift (flag if shift key is down)	    view:	view where the event occurred	    }	    */    int modifiers = 0;    int type=0;    int key=0;    int x=0;    int y=0;    int width=0;    int height=0;        RefVar tmp;        // extract data from frame (ick)        tmp = GetFramePath(event,SYM(event));    if (ISINT(tmp)) type = RINT(tmp);    tmp = GetFramePath(event,SYM(key));    if (ISINT(tmp)) key = RINT(tmp);    tmp = GetFramePath(event,SYM(x));    if (ISINT(tmp)) x = RINT(tmp);    tmp = GetFramePath(event,SYM(y));    if (ISINT(tmp)) y = RINT(tmp);    tmp = GetFramePath(event,SYM(width));    if (ISINT(tmp)) width = RINT(tmp);    tmp = GetFramePath(event,SYM(height));    if (ISINT(tmp)) height = RINT(tmp);    tmp = GetFramePath(event,SYM(option));    if (ISINT(tmp)) modifiers |= ALT;    tmp = GetFramePath(event,SYM(control));    if (ISINT(tmp)) modifiers |= CONTROL;    tmp = GetFramePath(event,SYM(shift));    if (ISINT(tmp)) modifiers |= SHIFT;        RefVar eventview = GetFramePath(event,SYM(view));        // okay, we'll not shut down at this point.  :-)    int timestamp = GetTimeStamp();    if (!globalMainWin) return NO_WINDOW;    WClass* vclass = WOBJ_class(globalMainWin);  // get runtime class    if (type==REPAINT)    	{	PRINTSTR("Event: Repaint");	// presently our flag to see if the window's been opened is stored in	// the VM proper because we only have one main window.  But ultimately	// we'll have to mark this flag on a per-window basis    	if (windowOpened && doubleBuffer)		{		SplatBufferIntoWindow(globalMainWin,NILREF);		return SUCCESS;			}	else windowOpened = 1;	WClassMethod* method = getMethod(vclass, createUtfString("_doPaint"),				createUtfString("(IIII)V"), &vclass);    		// Repaint should ONLY happen from within ViewDrawScript, so	// GetDrawBox is valid. 	RefVar drawbox = NSSend(eventview,SYM(GetDrawBox));	    	// GetDrawBox is a globalbox.  So we need to move that to a localbox	RefVar globalbox = NSSend(eventview, SYM(GlobalBox));		Var params[5];	params[0].obj = globalMainWin;	params[1].intValue = RINT(GetFrameSlot(drawbox,SYM(left))) - RINT(GetFrameSlot(globalbox,SYM(left)));	params[2].intValue = RINT(GetFrameSlot(drawbox,SYM(top))) - RINT(GetFrameSlot(globalbox,SYM(top)));	// not sure if I need to add 1 or not -- I'll assume I do	params[3].intValue = RINT(GetFrameSlot(drawbox,SYM(right))) - RINT(GetFrameSlot(drawbox,SYM(left))) + 1;	params[4].intValue = RINT(GetFrameSlot(drawbox,SYM(bottom))) - RINT(GetFrameSlot(drawbox,SYM(top))) + 1;	executeMethod(vclass,method,params,5);	PRINTSTR("Event Done: Repaint");	return SUCCESS;	}    else if (type!=TIMER)        {        WClassMethod* method = getMethod(vclass, createUtfString("_postEvent"),            createUtfString("(IIIIII)V"), &vclass);        if (method != NULL)            {            Var params[7];            params[0].obj = globalMainWin;            params[1].intValue = type;            params[2].intValue = key;            params[3].intValue = x;            params[4].intValue = y;            params[5].intValue = modifiers;            params[6].intValue = timestamp;            executeMethod(vclass,method,params,7);	    PRINTSTR("Event Done: Mouse/Key");            return SUCCESS;            }        }    else // type==TIMER        {	PRINTSTR("Event: Timer");        WClassMethod* method = getMethod(vclass, createUtfString("_onTimerTick"),            createUtfString("()V"), &vclass);        if (method != NULL)            {            Var params[1];            params[0].obj = globalMainWin;            executeMethod(vclass,method,params,1);	    PRINTSTR("Event Done: Timer");            return SUCCESS;            }        }    return NO_METHOD;    }        extern "C" Ref CallbackNewton(RefArg rcvr, RefArg _vm, RefArg id, RefArg args)    {	// PRINTF( "CallbackNewtonÉ\n" );    RefVar result = NILREF;        WITH_LOCKED_BINARY(_vm,vmptr)	    VM* vm = *(VM**)vmptr;	    result = vm->CallbackNewton(RINT(id),args);    END_WITH_LOCKED_BINARY(_vm)	// PRINTF( "ÉCallbackNewton\n" );	    return result;    }Ref VM::CallbackNewton(int id, RefArg args)    {    // first, load callbackClass and refClass if not already loaded        if (callbackClass==NULL)        {        refClass = getClass(createUtfString("newton/Ref"));        callbackClass = getClass(createUtfString("newton/Callback"));        }            WClass* vclass = callbackClass;    WClass* rclass = refClass;    RefVar returnValue = NILREF;  // default        if (vclass!=NULL && rclass!=NULL && IsArray(args))        {        // First find the callback for the given id        WClassMethod* method = getMethod(vclass, createUtfString("callbackForID"),            createUtfString("(I)Lnewton/Callback;"), &vclass);        if (method != NULL)            {            Var params[1];            // static method, so we don't include the instance as the first item            // instead we go right to the parameters            params[0].intValue = id;            Var ereturnValue;            executeAndReturn(vclass,method,params,1,&ereturnValue);            if (ereturnValue.obj)  // it's not null                {                // our callback is supposedly still alive.                // call the callback and get a response                vclass = WOBJ_class(ereturnValue.obj);                int len = Length(args);                WObject argarray = WOBJ_CallbackArgs(ereturnValue.obj);                if (argarray)  // it's non-null -- it better be!                    {                    if (WOBJ_arrayLen(argarray) == len)  // if not, something broke                        {                        WObject* argarray_ptr = (WObject*) WOBJ_arrayStart(argarray);                        for(int x=0;x<len;x++)                            setRefStruct(WOBJ_Ref(argarray_ptr[x]),                                GetArraySlot(args,x));                                            // call the "call" method on the callback                        method = getMethod(vclass, createUtfString("call"),                            createUtfString("([Lnewton/Ref;)Lnewton/Ref;"), &vclass);                        Var params[2];                        params[0] = ereturnValue;                        params[1].obj = argarray;                        Var finalRef;                        executeAndReturn(vclass,method,params,2,&finalRef);                        if (finalRef.obj)  // it's not null, so return it!                            returnValue = getRefStruct(WOBJ_Ref(finalRef.obj));                        }                    else PRINTSTR("In Callback, arg lengths not equal");                    }                else PRINTSTR("In Callback, argarray was null");                }            else PRINTSTR("In Callback, returnValue.obj was null");            }        else PRINTSTR("In Callback, callbackForID method was null");        }    else PRINTSTR("In Callback, vclass or rclass was null, or args wasn't an array!");    return returnValue;	  // returns NILREF if something went wrong (of course,                          // NILREF may be a valid return value as well...)    }        extern "C" Ref StopAppNewton(RefArg rcvr, RefArg _vm)    {	// PRINTF( "StopAppNewtonÉ\n" );//    TRACE("==StopAppNewton==");    	// delete the vm    	WITH_LOCKED_BINARY(_vm,vmptr)    	VM* vm = *(VM**)vmptr;	vm->VmStopAppNewton();                // vm doesn't have a destructor, so this is the final count        PRINTSTR("Final Malloc Count:");        PRINTOBJ(MAKEINT(vm->mallocCount));	delete vm;	END_WITH_LOCKED_BINARY(_vm)	// PRINTF( "ÉStopAppNewton\n" );	return NILREF;        }// Cover function created by Sean -- this is the actual function we'll usevoid VM::VmStopAppNewton()    {    TRACE("==VmStopAppNewton==");    VmStopApp(globalMainWin);    // close down classFetcher        PRINTSTR("Telling App that VMExited");NSSendIfDefined(getRefStruct(&classFetcher),SYM(VMExited),getRefStruct(&vmReference));    // deallocate my stuff  -- dunno how GC'ing works for structs, let's be careful        PRINTSTR("Freeing Java Instances...");    VmFree();  // closes the main window if it's not been closed        PRINTSTR("Deleting Newton-Specific Structures in Waba VM");    // now we can free everything else    deleteRefStruct(&classFetcher);    deleteRefStruct(&windowProto);    deleteRefStruct(&vmReference);    deleteRefStruct(&options);    deleteRefStruct(&drawArray);    deleteRefStruct(&bufferStyleFrame);    deleteRefStruct(&uniqueSymbol);    deleteRefStruct(&title);        freeClasses();    PRINTSTR("All done");    }    /* */// returns the virtual machine as a Ref, which you can pass in to// stop the Newton with StopAppNewton(vm).  If the user closes the// main window, then the virtual machine will stop itself, so your// pointer may be bad because the machine deletes itself too.// it turns out that you can't have but so many arguments to a C// function to be called from NewtonScript.  What a joke!/*New options frame:	{	// the following four items will be ignored if the	// user specifies preferences for them	vmStackSize: <int>,	// default: 1500	nmStackSize: <int>,	// default: 300	classHeapSize: <int>,	// default: 14000	objectHeapSize: <int>,	// default: 8000		// this item is optional, but if users have more than	// one app with the same initial classname, it'll be important.	// I recommend you come up with a unique symbol for the app	// as a matter of principle.	uniqueSymbol: <sym>	// the symbol that preferences for the 				// java app will be based on.			     	// default: |wabaApp-CLASSNAMEHERE:waba|    	// The app will always start by displaying the window centered.	// But when the user moves the window, the app will remember	// where it was, so that way I'm getting rid of the location	// parameter, and just leaving these two:	width: <int>,		// requested width of the JAVA area				// Default: 160	height: <int>,		// requested height of the JAVA area				// Default: 160	}optionsFrame is presently:	{	uniqueSymbol: <sym>		// the symbol that preferences for the app will be based on.				    	// default: |wabaApp-CLASSNAMEHERE:waba|	//vmStackSize: <int>,		// default: 1500	//nmStackSize: <int>,		// default: 300	//classHeapSize: <int>,		// default: 14000	//objectHeapSize: <int>,	// default: 8000	//newtonType: <int>, 		// default: MP120, so you will want to set this!	//				// one of:	//	#define NEWTONTYPE_MP2100	1	//	#define NEWTONTYPE_MP2000	2	//	#define NEWTONTYPE_EMATE	3	//	#define NEWTONTYPE_MP130	4	//	#define NEWTONTYPE_MP120	5		// NewtonType is no longer used as the type is determined in C++	wantsGray: <int 1 or 0>,		// if I'm MP130 or MP120 and want gray, TOUGH LUCK! :-) Default: 0	useCPlusPlusHeap: <int 1 or 0>,		// allocate Java classes on the C++ heap?  Default: 0	doubleBuffer: <int 1 or 0>,		// double-buffer?  (permits grabbing bitmaps from windows)  Default: 0		// We have window decorations, but the underlying Java system doesn't	// know that, which makes it a little complicated to come up with    	// a flexible but usable mechanism for specifying window position and size.	// So here's how I'm doing it.  You specify a "location" for the window to	// pop up, and you also specify a *requested* width and height.  The system	// will give you that width and height, else it will give you something	// smaller than that.		location: <int>,		// one of:		(default: LOCATION_CENTERED)		#define LOCATION_CENTERED	00		#define LOCATION_LEFTCENTERED	10		#define LOCATION_RIGHTCENTERED	20		#define LOCATION_TOPCENTERED	01		#define LOCATION_BOTTOMCENTERED	02		#define LOCATION_TOPLEFT	11		#define LOCATION_TOPRIGHT	21		#define LOCATION_BOTTOMLEFT	12		#define LOCATION_BOTTOMRIGHT	22	width: <int>,			// requested width of the JAVA drawing area	Default: 160	height: <int>,			// requested height of the JAVA drawing area 	Default: 160	}*/extern "C" Ref StartAppNewton(RefArg rcvr, 	RefArg className,	RefArg windowProto, 	RefArg classFetcher, 	RefArg optionsFrame)    {	// PRINTF( "StartAppNewtonÉ\n" );   	VM* vm = new VM();		    	char* buf;	// figure out classname in ASCII	WITH_LOCKED_BINARY(className,classNameptr)		unsigned short* cnp = (unsigned short*)classNameptr;		buf = new char[Ustrlen(cnp)+1];		ConvertFromUnicode(cnp,buf,kASCIIEncoding,			Ustrlen(cnp));	END_WITH_LOCKED_BINARY(className)	// figure my unique symbol.  If it's not specified in the options frame,	// then I will derive it from the class name.  This is also donw	// in the VMWin (NewtonScript) browser function RemovePreferences, so don't change	// it here unless you change it there too.		RefVar uniqueSymbol = GetFramePath(optionsFrame,SYM(uniqueSymbol));	if (ISNIL(uniqueSymbol))		{		char buf2[256];		sprintf(buf2,"wabaApp-%s:waba",buf);		uniqueSymbol = Intern(buf2);		}			// we need to stash the uniqueSymbol BEFORE VmInit in case there's	// a memory error on allocation.		setRefStruct(&(vm->uniqueSymbol),uniqueSymbol); // our preferences symbol        // also we need to set the title.  If there's no title, we'll use the class name        RefVar title = GetFramePath(optionsFrame,SYM(title));    if (ISNIL(title)) title = Intern(buf);   // use the main class name    setRefStruct(&(vm->title),title);	// set our title    		// we need to stash the windowProto BEFORE VmInit in case there's	// a memory error on allocation.	setRefStruct(&(vm->windowProto),windowProto);    	// Here we look up our defaults for sizes	RefVar mainVmApp = GetFramePath(NSCallGlobalFn(SYM(GetRoot)),					SYM(VM:waba));	RefVar prefs = GetFramePath(mainVmApp,SYM(prefsTemplate));	RefVar prefsframe = NSSend(prefs,SYM(getPreferences),uniqueSymbol);	int vmStackSize = 1500;	int nmStackSize = 300;	int classHeapSize = 14000;	int objectHeapSize = 8000;	// first check the options frame	RefVar _vmStackSize = GetFramePath(optionsFrame,SYM(vmStackSize));	if (ISINT(_vmStackSize)) vmStackSize = RINT(_vmStackSize);	RefVar _nmStackSize = GetFramePath(optionsFrame,SYM(nmStackSize));	if (ISINT(_nmStackSize)) nmStackSize = RINT(_nmStackSize);	RefVar _classHeapSize = GetFramePath(optionsFrame,SYM(classHeapSize));	if (ISINT(_classHeapSize)) classHeapSize = RINT(_classHeapSize);	RefVar _objectHeapSize = GetFramePath(optionsFrame,SYM(objectHeapSize));	if (ISINT(_objectHeapSize)) objectHeapSize = RINT(_objectHeapSize);    	// override with preferences -- if we're not using the default!	_vmStackSize = GetFramePath(prefsframe,SYM(vmStackSize));	if (ISINT(_vmStackSize) &&        !ISNIL(GetFramePath(prefsframe,SYM(ignoreVmStackSizeDefault))))            vmStackSize = RINT(_vmStackSize);	_nmStackSize = GetFramePath(prefsframe,SYM(nmStackSize));	if (ISINT(_nmStackSize) &&        !ISNIL(GetFramePath(prefsframe,SYM(ignoreNmStackSizeDefault))))            nmStackSize = RINT(_nmStackSize);	_classHeapSize = GetFramePath(prefsframe,SYM(classHeapSize));	if (ISINT(_classHeapSize) &&        !ISNIL(GetFramePath(prefsframe,SYM(ignoreClassHeapDefault))))            classHeapSize = RINT(_classHeapSize);	_objectHeapSize = GetFramePath(prefsframe,SYM(objectHeapSize));	if (ISINT(_objectHeapSize) &&        !ISNIL(GetFramePath(prefsframe,SYM(ignoreObjectHeapDefault))))            objectHeapSize = RINT(_objectHeapSize);	// initialize the VM	vm->VmInit(vmStackSize,nmStackSize,classHeapSize,objectHeapSize);	RefVar _vm = AllocateBinary(SYM(vm),4);  // 4 bytes of class 'vm	WITH_LOCKED_BINARY(_vm,vmptr)		*(VM**)vmptr = vm;	END_WITH_LOCKED_BINARY(_vm)	//...it *looks* like buf won't be retained, so	// we can freely stick it in here I hope	vm->VmStartAppNewton(buf,classFetcher,_vm,optionsFrame,prefsframe);	delete buf;		// PRINTF( "ÉStartAppNewton\n" );	return _vm;     }// cover function created by Sean -- this is the actual function we'll usevoid VM::VmStartAppNewton(char* className, RefArg _classFetcher, RefArg _vmPointer,RefArg optionsFrame,RefArg prefsFrame)    {    // one of the things we have to set up (and don't here, but    // we'll get to it) is a proto for our windows -- we'll use    // protoDragNGo I think.  Maybe protoDragger with a close box,    // dunno.  We should have size, location, etc. set up in the proto too.    // the window needs to have a SetVMTo(this) method which hangs onto    // a binary object for this.  Also you should have a StopVM(int_result) method    // which stops the VM on the next available event, say, a     // ViewIdleScript.  Also, you should have a SetTimerInterval(millis) method;    // if millis is <=0, there's no timer at all.  Also you should have a slot    // called vmClosingWindow which is set just before the vm closes a window    //    // The window has a clView called DrawingArea which actually is where    // the scribbling goes and where events come from.	    setRefStruct(&vmReference,_vmPointer);  // store our vm pointer    setRefStruct(&classFetcher,_classFetcher);  // store our class fetcher    setRefStruct(&options,optionsFrame);  // store our options frame        // what kind of Newton do we have?    // newtonType = RefToInt(NSSend(getRefStruct(&windowProto),SYM(NewtonType)));	// -- I wrote a C++ function to do that, and it's set at class instantiation [PG]    //...YES, but it'd be nice for Paul to actually *set* the newtonType so we can use it,    // no?  --Sean :-)    newtonType = GetNewtonType();    // set our various values    wantsGray = 0;    noSound = 0;    useCPlusPlusHeap = 0;    // for now, we don't want to make copies, so it's gonna be 0    doubleBuffer = 0;    width = 160;    height = 160;        // first set the options frame    RefVar _wantsGray = GetFramePath(optionsFrame,SYM(wantsGray));    if (ISINT(_wantsGray)) wantsGray = RINT(_wantsGray);    //RefVar _useCPlusPlusHeap = GetFramePath(optionsFrame,SYM(useCPlusPlusHeap));    //if (ISINT(_useCPlusPlusHeap)) useCPlusPlusHeap = RINT(_useCPlusPlusHeap);    RefVar _doubleBuffer = GetFramePath(optionsFrame,SYM(doubleBuffer));    if (ISINT(_doubleBuffer)) doubleBuffer = RINT(_doubleBuffer);           // then override with prefsframe -- if we're not using the default (else it's NILREF)    _wantsGray = GetFramePath(prefsFrame,SYM(wantsGray));    if (ISINT(_wantsGray)) wantsGray = RINT(_wantsGray);    //_useCPlusPlusHeap = GetFramePath(prefsFrame,SYM(useCPlusPlusHeap));    //if (ISINT(_useCPlusPlusHeap)) useCPlusPlusHeap = RINT(_useCPlusPlusHeap);    _doubleBuffer = GetFramePath(prefsFrame,SYM(doubleBuffer));    if (ISINT(_doubleBuffer)) doubleBuffer = RINT(_doubleBuffer);    // sound is solely determined by the prefsframe    RefVar _noSound = GetFramePath(prefsFrame,SYM(noSound));    if (ISNIL(_noSound)) noSound = 0; else noSound = 1;        // width and height are solely determined by the options frame    RefVar _width = GetFramePath(optionsFrame,SYM(width));    if (ISINT(_width)) width = RINT(_width);    RefVar _height = GetFramePath(optionsFrame,SYM(height));    if (ISINT(_height)) height = RINT(_height);        mainclassname = createUtfString(className);    globalMainWin = VmStartApp(className);    // the following will be null if the library isn't installed...    callbackClass = NULL;    refClass = NULL;    }#define TICKS_PER_SECOND 60int32 VM::GetTimeStamp()	{	RefVar ticks = NSCallGlobalFn(SYM(Ticks));	int stamp = (uint32)((RINT(ticks) * 1000L) / TICKS_PER_SECOND);	stamp = stamp % (uint32)(1L << 30);  // set to first 30 bits	return (int32)stamp;	}// after you push the class, the VM assumes control over it and will free it latervoid VM::pushClass(unsigned char* classptr)	{	int x;	// highly inefficient but has tight storage, and that's	// what matters!	unsigned char** newclasses = 		(unsigned char**) xmalloc(++numClassObjPtrs * sizeof(unsigned char*));	for(x=0;x<numClassObjPtrs-1;x++)		newclasses[x]=classObjPtrs[x];	newclasses[x] = classptr;	if (classObjPtrs!=NULL) xfree(classObjPtrs);	classObjPtrs=newclasses;	}	// after you push the class, the VM assumes control over it and will free it latervoid VM::pushClassRef(RefArg classref)	{#ifdef USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS    if (classObjRefs==NULL)            setRefStruct(&classObjRefs, AllocateArray(SYM(array),0));             AddArraySlot(getRefStruct(&classObjRefs),classref);    numClassObjPtrs++;#else	int x;	// highly inefficient but has tight storage, and that's	// what matters!	RefStruct** newclasses = 		(RefStruct**) xmalloc(++numClassObjPtrs * sizeof(RefStruct*));	for(x=0;x<numClassObjPtrs-1;x++)		newclasses[x]=classObjRefs[x];	RefStruct* cref;	initRefStruct(&cref);	setRefStruct(&cref,classref);	newclasses[x] = cref;	if (classObjRefs!=NULL) xfree(classObjRefs);	classObjRefs=newclasses;#endif USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS    }void VM::freeClasses()    {    if (useCPlusPlusHeap)	{	int x;	for(x=0;x<numClassObjPtrs;x++)		xfree(classObjPtrs[x]);	if (classObjPtrs!=NULL) xfree(classObjPtrs);	classObjPtrs = NULL;	numClassObjPtrs = 0;	}    else    	{	int x;	for(x=0;x<numClassObjPtrs;x++)		{#ifdef USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS        UnlockRefArg(GetArraySlot(getRefStruct(&classObjRefs),x));#else		UnlockRefArg(getRefStruct(&classObjRefs[x]));		deleteRefStruct(&classObjRefs[x]);#endif USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS		}#ifdef USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS    deleteRefStruct(&classObjRefs);#else	if (classObjRefs!=NULL) xfree(classObjRefs);	classObjRefs = NULL;#endif	numClassObjPtrs = 0;	}    }unsigned char* VM::nativeLoadClass(UtfString className, uint32 *size)    {    if (useCPlusPlusHeap)	{	unsigned char* newclass;		TRACE("==nativeLoadClass==");        PRINTOBJ(MakeString("Go figure..."));	PRINTOBJ(UtfStringToNewtonString(className));	RefVar myclassframe = NSSend(getRefStruct(&classFetcher),SYM(getWabaClass),		UtfStringToNewtonString(className));	if (ISNIL(myclassframe)) return NULL; // no class!	RefVar myclass = GetFramePath(myclassframe,SYM(class));	int offset = RINT(GetFramePath(myclassframe,SYM(offset)));	int length = RINT(GetFramePath(myclassframe,SYM(length)));	WITH_LOCKED_BINARY(myclass,classptr)	// allocate a chunk of memory for now -- maybe we'll be unsafe later	// and just use pointers directly into the VBOs if we can't do it this	// way and retain enough C++ heap		newclass = (unsigned char*) xmalloc(length);	xmemmove(newclass,&(((unsigned char*)classptr)[offset]),length);	pushClass(newclass);	END_WITH_LOCKED_BINARY(myclass)		if (size!=NULL)  // fill out size I guess		*size = length;	return newclass;	}    else	{	unsigned char* newclass;		TRACE("==nativeLoadClass==");	PRINTOBJ(UtfStringToNewtonString(className));	RefVar myclassframe = NSSend(getRefStruct(&classFetcher),SYM(getWabaClass),		UtfStringToNewtonString(className));	if (ISNIL(myclassframe)) return NULL; // no class!	RefVar myclass = GetFramePath(myclassframe,SYM(class));	int offset = RINT(GetFramePath(myclassframe,SYM(offset)));	int length = RINT(GetFramePath(myclassframe,SYM(length)));	// illegally lock myclass -- we're not going to copy into the heap but	// just keep a pointer and hope for the best	pushClassRef(myclass);  // we'll unlock it when freeing	Ptr classptr = LockedBinaryPtr(myclass);	newclass = &((unsigned char*)classptr)[offset];		if (size!=NULL)  // fill out size I guess		*size = length;	return newclass;	}    }void VM::DisplayPrefs(int error)	{	// for really weird reasons, you can get this called many times if you	// run out of memory and before you get exited.  So I'm setting it to only pop up once.	if (displayingPrefs) return;	displayingPrefs = 1;	RefVar mainVmApp = GetFramePath(NSCallGlobalFn(SYM(GetRoot)),SYM(VM:waba));	NSSend(mainVmApp,SYM(OfferToDisplayPrefs),MAKEINT(error),		getRefStruct(&title),getRefStruct(&uniqueSymbol));	}// ====================================================================	////	¥ GetNewtonType( void ) [private, static]// ====================================================================	//intVM::GetNewtonType ( void ){	// Return the Newton type using Sean's constant convention, i.e.	//	NEWTONTYPE_MP2100	//	NEWTONTYPE_MP2000	//	NEWTONTYPE_EMATE	//	NEWTONTYPE_MP130	//	NEWTONTYPE_MP120		// Additional types:	//	NEWTONTYPE_ERROR	//	NEWTONTYPE_MARTIAN	// I simply call Gestalt	TUGestalt myGestalt;				// Create a Gestalt object on the stack.	TGestaltSystemInfo mySystemInfo;	// Create a System Info structure on the stack.	NewtonErr theErr = myGestalt.Gestalt( kGestalt_SystemInfo, &mySystemInfo, sizeof(mySystemInfo) );		// Gestalt, tell me what I am running on.			int theResult = NEWTONTYPE_ERROR;	// Let's suppose something wrong happened.		if (theErr == noErr)	{		theResult = NEWTONTYPE_MARTIAN;	// Default answer.				switch (mySystemInfo.fMachineType)		{			case kMP120_130_MT:				if (mySystemInfo.fRAMSize == kMP120_RS)				{					theResult = NEWTONTYPE_MP120;				} else if (mySystemInfo.fRAMSize == kMP130_RS) {					theResult = NEWTONTYPE_MP130;				}				break;						case kMP2x00_MT:				if (mySystemInfo.fRAMSize == kMP2100_RS)				{					theResult = NEWTONTYPE_MP2100;				} else /* if (mySystemInfo.fRAMSize == kMP2000_RS) */ {					// I don't know the MP2000 RAM Size					theResult = NEWTONTYPE_MP2000;				}				break;						case kEM300_MT:				theResult = NEWTONTYPE_EMATE;		}	}		return theResult;}