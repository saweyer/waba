/*Copyright (C) 1998, 1999, 2000 WabasoftThis program is free software; you can redistribute it and/or modify it underthe terms of the GNU General Public License as published by the Free SoftwareFoundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANYWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along withthis program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave,Cambridge, MA 02139, USA. *//*If you're looking here, you've probably already looked at (or worked on) thenm<platform>_b.c file. If you've gotten the _a and _b files working, this isthe easy part. This file contains all the native functions that are part ofthe waba core framework. When you've added all the native functions then you'redone porting the VM.The native functions that need to be ported are all those listed in the waba.cnative function table. There are stubs included in this file to make thingsa bit easier than starting from scratch.Some rules:As a rule for native functions, don't hold a pointer across any callthat could garbage collect. For example, this is bad:ptr = WOBJ_arrayStart(array)...string = createString(..)ptr[0]since the createString() could GC, the ptr inside of array could be invalidafter the call since a GC would move memory around. Instead, use:ptr = WOBJ_arrayStart(array)...string = createString(..)...ptr = WOBJ_arrayStart(array)ptr[0]to recompute the pointer after the possible GC. The main thing to know there isthat when you call VM functions, it might garbage collect, so you want to recompute any pointers again after that function returns since the memorylocations might have changed. When you don't call VM functions that garbagecollect, there isn't a problem, because the VM is all single threaded. Thingsdon't move around on you unless you call a function that can garbage collect.Another thing to note is that if you subclass a class with an objectdestroy function, you must explicity call your superclasses objectsdestroy functions. This isn't done automatically. See one of the objects that doesthat in nmwin32_c.c for reference.Before jumping into writing native functions, we need to look at 'classHooks'.A classHooks array contains 'class hooks' like this:   -- NOTE FROM SEAN -- I've put a dummy ClassHook array in waba.h,   -- you need to modify it thereClassHook classHooks[] =	{	{ "waba/fx/Graphics", NULL, 11},	{ "waba/fx/Image", ImageDestroy, 1 },	{ "waba/io/Catalog", CatalogDestroy, 7 },	{ "waba/io/Socket", SocketDestroy, 2 }, 	{ "waba/io/SerialPort", SerialPortDestroy, 2 }, 	{ NULL, NULL }	};You will need to define a classHooks array. Its an array of triples:- a class name- a object destroy function- a number of native variablesYou need a class hook when an object needs to allocate some native systemresource which it needs to use later on and/or needs to be freed.For example, a Socket object will probably need to keep around a referenceto a socket descriptor around. And when a socket object is garbagecollected, it should close the socket.So, it needs a classHook. In the above, the destroy method for a socketis SocketDestroy and it will get called when the object is garbagecollected. The classHook for the Socket class above has 2 nativevariables associated with it. Each of these native variablesare 32 bit values. One could hold a socket descriptor and theother could hold something else. You can see nmpalm_c.c or nmwin32_c.cfor more on how that works for sockets.So, how do you access a class hook variable or a variable that is ina waba object? You can access a waba object's variables directly like this:#define WOBJ_RectX(o) (objectPtr(o))[1].intValueThe objectPtr(o) gets a pointer to the data in an object and the [1]references the second value in the object. The first value is a pointerto the class of the object so the WOBJ_RectX(o) above is a macro thatpulls out the first actual variable in the object which is its X value.If you look in the Rect class, you'll see that it looks like:class Rect{int x;int y;..So, the first variable - (objectPtr(o))[1].intValue is the x value.The hook variables get stuck in after all the normal variables. If you look in thenmwin32_c.c or nmpalm_c.c code, you'll see things like this://// Graphics//// var[0] = Class// var[1] = Surface// var[2] = hook var - 1 for window surface and 2 for image// var[3] = hook var - rgb// var[4] = hook var - has clip// var[5] = hook var - clipX// ...and then:#define WOBJ_GraphicsSurface(o) (objectPtr(o))[1].obj#define WOBJ_GraphicsSurfType(o) (objectPtr(o))[2].intValue#define WOBJ_GraphicsRGB(o) (objectPtr(o))[3].intValue#define WOBJ_GraphicsHasClip(o) (objectPtr(o))[4].intValue#define WOBJ_GraphicsClipX(o) (objectPtr(o))[5].intValue#define WOBJ_GraphicsClipY(o) (objectPtr(o))[6].intValue#define WOBJ_GraphicsClipWidth(o) (objectPtr(o))[7].intValueSee how the hook variables start right after the last variable in theclass. The above are macros that access the value of a waba object in C code.Making macros like the above makes the code easier to read.With the macros, we can inspect a graphic's object clipX with:int32 x = WObjectGraphicClipX(object);Of course, if you change the Graphics object and add a new variable before thesurface variable or if you add a new variable in a base class, you need torecompute those mappings or everything will get messed up.The best way to port the native functions is to start out by making somethingthat doesn't work but does compile and then take code from the other nativeVM's implementations and hack it up one class at a time. It's probably bestto start with the window and drawing classes so you can see something whenyou start out.*/// WHEN PORTING: You'll probably need classHooks for these things when you get// things going. Here we've allocate no hook variables for each object but have// assigned some object destructor functions so when you actually hook some// data in there, you'll need to set the 0 values to something else// -- ClassHooks array moved to waba.h by Sean  (NewtOS)//// Rect//// var[0] = Class// var[1] = int x// var[2] = int y// var[3] = int width// var[4] = int height#define WOBJ_RectX(o) (objectPtr(o))[1].intValue#define WOBJ_RectY(o) (objectPtr(o))[2].intValue#define WOBJ_RectWidth(o) (objectPtr(o))[3].intValue#define WOBJ_RectHeight(o) (objectPtr(o))[4].intValue//// Control//// var[0] = Class// var[1] = int x// var[2] = int y// var[3] = int width// var[4] = int height#define WOBJ_ControlX(o) (objectPtr(o))[1].intValue#define WOBJ_ControlY(o) (objectPtr(o))[2].intValue#define WOBJ_ControlWidth(o) (objectPtr(o))[3].intValue#define WOBJ_ControlHeight(o) (objectPtr(o))[4].intValue	// Presently Waba applications may have only a single window.// That totally sucks!//// Window//// since Window inherits from other classes, we need to calculate the// right base offset to start with when reading/writing to variables#define WOBJ_Window_NewtonWindow(o) &((objectPtr(o))[_winHookOffset+0].refStruct)#define WOBJ_Window_NewtonWindowBuffer(o) &((objectPtr(o))[_winHookOffset+1].refStruct)#define WOBJ_WindowHookVars 2  // window, buffer Var VM::WindowCreate(Var stack[])	{	TRACE("==WindowCreate==");	WObject win;	Var v;	win = stack[0].obj;		if (_winHookOffset == -1)	    {	    WClass *wc;	    wc = getClass(createUtfString("waba/ui/Window"));	    _winHookOffset = 1 + wc->numVars - WOBJ_WindowHookVars;	    // I believe this value should be 18:	    // 0 class obj	    // 1-17 vars for container, control, window	    // 18 hook	    }	    	// we assume that at this point windowProto was set up for us	// in NewtonStart.  We have to set it up there because it uses	// the magic pointer "protoDragNGo", which we can't access from C++	// and have to have handed to us, sorry.		RefVar mywin = NSCallGlobalFn(SYM(BuildContext),getRefStruct(&windowProto));        // set up width and height    NSSend(mywin,SYM(prepareWidthAndHeight), MAKEINT(width), MAKEINT(height));    	initRefStruct(WOBJ_Window_NewtonWindow(win));  // just in case	setRefStruct(WOBJ_Window_NewtonWindow(win), mywin);  // put window in our hook	NSSend(mywin,SYM(Open));  // display the window  -- this apparently only QUEUES a ViewDrawScript,				  // but it's gotta be here before we compute LocalBox	RefVar drawArea = GetFramePath(mywin,SYM(wabaDrawingArea));		// you'd think that this circular reference (a mainwindow has a pointer to us,	// and we have a pointer to it) wouldn't go unnoticed by the NewtonScript	// garbage collector, but windows are also pointed to by the root	// NewtonScript view because they are created using BuildContext.	// They won't go away until we close them.	// Now we need to set the control variables -- but we don't tell the	// window where it's *actually* located.  Waba has a bug that doesn't do	// that right.  Instead we tell the window that it's at 0,0 and has a given	// height and width	RefVar viewbounds = NSSend(drawArea,SYM(LocalBox));	WOBJ_ControlX(win) = 0;  // LocalBox always returns 0 anyway	WOBJ_ControlY(win) = 0;  // LocalBox always returns 0 anyway	// don't add one to the following below, because the Newton's clipping routine	// clips one extra pixel off the right-hand and bottom sides	WOBJ_ControlWidth(win) = RINT(GetFramePath(viewbounds,SYM(right))) -  				    RINT(GetFramePath(viewbounds,SYM(left)));	WOBJ_ControlHeight(win) = RINT(GetFramePath(viewbounds,SYM(bottom))) - 				    RINT(GetFramePath(viewbounds,SYM(top)));				    	if (doubleBuffer)    		{		// if we're double-buffering, we need to create a buffer as big as the draw area			RefVar options = NILREF;		if (DRAW_GRAY) 			{ options = AllocateFrame(); SetFrameSlot(options,SYM(depth), MAKEINT(4)); }		int left = RINT(GetFramePath(viewbounds,SYM(left)));		int top = RINT(GetFramePath(viewbounds,SYM(top)));		int right = RINT(GetFramePath(viewbounds,SYM(right)));		int bottom = RINT(GetFramePath(viewbounds,SYM(bottom)));		initRefStruct(WOBJ_Window_NewtonWindowBuffer(win));  // just in case		setRefStruct(WOBJ_Window_NewtonWindowBuffer(win),		    NSCallGlobalFn(SYM(MakeBitmap),MAKEINT(right-left), MAKEINT(bottom-top),options));		}			v.obj = 0;	return v;	}void VM::WindowDestroy(WObject win)	{	TRACE("==WindowDestroy==");	RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(win));	// for the moment, due to an apparent Waba bug, we'll set it to:	//RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin));	// because the window's not declared, this *should* destroy it	// as well as close it.  According to p. 3-29 of the Newton Programmer's Guide    if (ISNIL(GetFramePath(mywin,SYM(closingWindow)))) // prevents infinite closing fights with NewtonScript        {	PRINTSTR("Looks like I've been programmatically shut down");        SetFrameSlot(mywin,SYM(closingWindow),SYM(true));        NSSend(mywin,SYM(Close));        }    else { PRINTSTR("Apparently the user pressed the close box"); }    deleteRefStruct(WOBJ_Window_NewtonWindow(win));if (doubleBuffer)    deleteRefStruct(WOBJ_Window_NewtonWindowBuffer(win));	}void VM::SetTitle(UtfString str)	{	RefVar nstr = UtfStringToNewtonString(str);	RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin));    	RefVar title = GetFramePath(mywin,SYM(wabaTitle));    	NSCallGlobalFn(SYM(SetValue),title,SYM(text),nstr); 	}//// MainWindow//Var VM::MainWinCreate(Var stack[])	{	TRACE("==MainWinCreate==");	Var v;		// since this is *after* the Window creation function,	// all we need to do here is stash our main window in	// globalMainWin for convenience.	globalMainWin = stack[0].obj;	// we also need to call a method in our global window that	// tells it who we are so it can hang onto us.  We'll stash	// ourselves in a little binary object -- we don't want to	// put ourselves in an int, because its high two bits get	// weirded out.	RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin));	RefVar me = AllocateBinary(SYM(vm),4);  // 4 bytes of class 'vm	WITH_LOCKED_BINARY(me,meptr)		*(VM**)meptr = this;	END_WITH_LOCKED_BINARY(me)		// Tell our window who we are	NSSend(mywin,SYM(SetVMTo),me);		// Set the title bar of the window	WClass * wclass = WOBJ_class(globalMainWin);	UtfString className = getUtfString(wclass, wclass->classNameIndex);	// Search for the last "/" to get the classname proper	const char* str = className.str;	int len = className.len;	for(int x=1; x<className.len;x++)		if (className.str[x-1]=='/')			{			str=&(className.str[x]);			len = className.len - x;			}	    // we need to set the title and unique symbol here so that when the user chooses    // preferences from the "i" menu, it can get this info without having to ask    // the VM for it.        // set the title    SetFrameSlot(mywin,SYM(title),getRefStruct(&title));    	// set up the unique symbol for preferences -- ultimately this should be something	// I look up in the appargs 	NSSend(mywin,SYM(setUniqueSym),getRefStruct(&uniqueSymbol));		v.obj = 0;	return v;	}Var VM::MainWinExit(Var stack[])	{	TRACE("==MainWinExit==");	Var v;	// I guess that this is supposed to close the window	// and return an exit code, then exit the app.  	// exit codes are not the Newton's style.  Window closing	// will be done automagically.  So I'm not sure what we need	// to do here -- perhaps we should register an event which	// kills the system somehow, and then on the next pulseNewton	// it calls VmStopAppNewton() instead and quits.		int exitCode = stack[1].intValue;	RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin));	NSSend(mywin,SYM(StopVM),MAKEINT(exitCode));		v.obj = 0;	return v;	}Var VM::MainWinSetTimerInterval(Var stack[])	{	TRACE("==MainWinSetTimerInterval==");	Var v;#ifdef NO_TIMER	v.obj = 0;	return v;#endif NO_TIMER		RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin));	int millis = stack[1].intValue;	if (millis!=0)  // They actually want a delayed send set up		NSSend(mywin,SYM(SetTimerInterval),MAKEINT(millis));	v.obj = 0;	return v;	}//// Surface//// Standard method -- I've modified it so that if we ever get to// draw directly in non-main windows, we'll know that they're// windows and not images. #define SURF_WINDOW 3#define SURF_MAINWIN 1#define SURF_IMAGE 2int VM::SurfaceGetType(WObject surface)    {    TRACE("==SurfaceGetType==");    WClass *wclass;        if (surface == 0)	return 0;        // cache class pointers for performance    if (!mainWinClass)	mainWinClass = getClass(createUtfString("waba/ui/MainWindow"));#ifdef NEWTOS    if (!winClass)	winClass = getClass(createUtfString("waba/ui/Window"));#endif    if (!imageClass)	imageClass = getClass(createUtfString("waba/fx/Image"));        wclass = WOBJ_class(surface);    if (compatible(wclass, mainWinClass))	return SURF_MAINWIN;#ifdef NEWTOS    if (compatible(wclass, winClass))    	return SURF_WINDOW;#endif    if (compatible(wclass, imageClass))	return SURF_IMAGE;    return 0;    }//// Font//// var[0] = Class// var[1] = String name// var[2] = int size// var[3] = int style//#define WOBJ_FontName(o) (objectPtr(o))[1].obj#define WOBJ_FontStyle(o) (objectPtr(o))[2].intValue#define WOBJ_FontSize(o) (objectPtr(o))[3].intValue #define Font_PLAIN 0#define Font_BOLD 1// no functions defined here.  Odd./* Newton Font Styles are an OR of the following:Newton Styles:0	Plain1	Bold2	Italic4	Underline8	Outline128	Superscript256	Subscript... we need to convince WabaSoft that they should include these    by default as these values.  They're already doing this for    plain and bold.  :-)*/#define WABA_SYSTEM_FONT_NAME "NewtonDefault"#define HACKED_WABA_SYSTEM_FONT_NAME "Helvetica"// we need to define these two at some point...:-(#define strncasecmp strncmp#define strcasecmp strcmpRef lookupFont(const char* family)	{    TRACE("==lookupFont==");		// Basic system for the moment	if (family==NULL) 			return SYM(espy);	if (!strlen(family))			return SYM(espy);	if (!strcasecmp(family, WABA_SYSTEM_FONT_NAME)) 	return SYM(espy);	if (!strcasecmp(family, HACKED_WABA_SYSTEM_FONT_NAME)) 	return SYM(espy);		// Geneva	if (!strcasecmp(family,"Geneva"))		return SYM(geneva);	if (!strcasecmp(family,"Simple"))		return SYM(geneva);	if (!strcasecmp(family,"Arial"))		return SYM(geneva);	// New York	if (!strcasecmp(family,"Fancy"))		return SYM(newYork);	if (!strncasecmp(family,"Times",5))		return SYM(newYork);	if (!strcasecmp(family,"New Times Roman"))	return SYM(newYork);	if (!strcasecmp(family,"New York"))		return SYM(newYork);	if (!strcasecmp(family,"NewYork"))		return SYM(newYork);		// Casual	if (!strcasecmp(family,"Handwriting"))	return SYM(handwriting);	if (!strcasecmp(family,"Casual"))		return SYM(handwriting);		// Espy	if (!strcasecmp(family,"Espy"))		return SYM(espy);	if (!strcasecmp(family,"System"))		return SYM(espy);		// default situation -- unknown font, convert it into a symbol	// for some reason MakeSymbol doesn't take a const char*!!// what the heck is up with that?  I have to hope that it's// still copying the char*, otherwise how in the world do I keep// track of the buffer after allocating it?// Sean: since there is the SYM macro which is Intern(#name), I guess that we don't need to copy the string [PG]// #define BIG_ENOUGH_FOR_ANY_FONT_NAME 128//	char fontname[BIG_ENOUGH_FOR_ANY_FONT_NAME];//	strcpy(fontname,family);	RefVar sym = Intern( (char*) family);	return sym;	}		Ref VM::FontSpecForFont(WObject font)	{	TRACE("==FontSpecForFont==");	RefVar family;	RefVar size;	RefVar style;	RefVar isSystem;		if (font==NULL)		{		family = lookupFont(WABA_SYSTEM_FONT_NAME);		size = MAKEINT(9);		style = MAKEINT(0);		isSystem = SYM(true);	    }	else		{		UtfString s = stringToUtf(WOBJ_FontName(font), STU_NULL_TERMINATE | STU_USE_STATIC);		family = lookupFont(s.str);		size = MAKEINT(WOBJ_FontSize(font));		style = MAKEINT(WOBJ_FontStyle(font));		// indicate that I believe it to be the Waba system font,		// for which the Newton is using Espy 9		if ((!strcmp(s.str,HACKED_WABA_SYSTEM_FONT_NAME) ||                    (!strcmp(s.str,WABA_SYSTEM_FONT_NAME)))                   && WOBJ_FontSize(font)<=12)			{			size=MAKEINT(9);  // fix it to 9			isSystem = SYM(true);			}		else isSystem = NILREF;		}			RefVar spec = AllocateFrame();	SetFrameSlot(spec,SYM(family),family);	SetFrameSlot(spec,SYM(face),style);	SetFrameSlot(spec,SYM(size),size);	if (!ISNIL(isSystem)) SetFrameSlot(spec,SYM(system),isSystem);	return spec;	}//// FontMetrics//// var[0] = Class// var[1] = Font// var[2] = Surface// var[3] = int ascent// var[4] = int descent// var[5] = int leading//#define WOBJ_FontMetricsFont(o) (objectPtr(o))[1].obj#define WOBJ_FontMetricsSurface(o) (objectPtr(o))[2].obj#define WOBJ_FontMetricsAscent(o) (objectPtr(o))[3].intValue#define WOBJ_FontMetricsDescent(o) (objectPtr(o))[4].intValue#define WOBJ_FontMetricsLeading(o) (objectPtr(o))[5].intValueVar VM::FontMetricsCreate(Var stack[])	{	TRACE("==FontMetricsCreate==");	Var v;	WObject font, fontMetrics, surface;	fontMetrics = stack[0].obj;	font = WOBJ_FontMetricsFont(fontMetrics);	surface = WOBJ_FontMetricsSurface(fontMetrics);	if (font == 0 || surface == 0)		{		WOBJ_FontMetricsAscent(fontMetrics) = 0;		WOBJ_FontMetricsDescent(fontMetrics) = 0;		WOBJ_FontMetricsLeading(fontMetrics) = 0;		v.obj = 0;		return v;		}	RefVar spec = FontSpecForFont(font);	WOBJ_FontMetricsAscent(fontMetrics) = 		RINT(NSCallGlobalFn(SYM(FontAscent),spec));	WOBJ_FontMetricsDescent(fontMetrics) =		RINT(NSCallGlobalFn(SYM(FontDescent),spec));	WOBJ_FontMetricsLeading(fontMetrics) =		RINT(NSCallGlobalFn(SYM(FontLeading),spec));	// we hack the ascent so that it's slightly smaller -- the Newton	// has too high an ascent as far as Waba is concerned.  The only	// critical item is Espy 10, which we use for our controls.	// -- NOT ANY MORE -- we're using Espy 9	if (!ISNIL(GetFrameSlot(spec,SYM(system))))		WOBJ_FontMetricsAscent(fontMetrics) -=2 ;	v.obj = 0;	return v;	}#define FM_STRINGWIDTH 1#define FM_CHARARRAYWIDTH 2#define FM_CHARWIDTH 3Var VM::FontMetricsGetWidth(int type, Var stack[])	{	TRACE("==FontMetricsGetWidth==");#ifdef CATCH_NEWTON_EXCEPTIONS	DECLARE_VOLATILE(Var,v);#else        Var v;#endif CATCH_NEWTON_EXCEPTIONS	WObject font, fontMetrics, surface, string, charArray;	uint16* chars;	uint16 t_chars[2];	int start;	int count;	fontMetrics = stack[0].obj;	font = WOBJ_FontMetricsFont(fontMetrics);	surface = WOBJ_FontMetricsSurface(fontMetrics);	if (font == 0 || surface == 0)		v.intValue = 0;	else		{		RefVar spec = FontSpecForFont(font);		switch(type)		    {		    case FM_STRINGWIDTH:                string = stack[1].obj;                if (string==NULL) break;                charArray=WOBJ_StringCharArrayObj(string);                if (charArray==NULL) break;                start=0;                count= WOBJ_arrayLen(charArray);                chars = (uint16 *)WOBJ_arrayStart(charArray);                chars = &chars[start];		    	break;		    case FM_CHARARRAYWIDTH:		    	charArray=stack[1].obj;                start = stack[2].intValue;                count = stack[3].intValue;                if (arrayRangeCheck(charArray, start, count) == 0)                    break; // array null or range invalid                chars = (uint16 *)WOBJ_arrayStart(charArray);                chars = &chars[start];                    break;		    case FM_CHARWIDTH:		    	t_chars[0] = stack[1].intValue;                t_chars[1] = 0;		    	chars = t_chars;                start=0;                count=1;		    	break;		    }		// because we cannot be certain that there's		// a terminator (due to CHARARRAY), we have to copy		// the string over.  :-(		                uint16* newchars = new uint16[count+1];#ifdef CATCH_NEWTON_EXCEPTIONS		unwind_protect                    {#endif CATCH_NEWTON_EXCEPTIONS                    Ustrncpy(newchars,chars,count);                    v.intValue = RINT(NSCallGlobalFn(SYM(StrFontWidth),			    MakeString(newchars), FontSpecForFont(font)));#ifdef CATCH_NEWTON_EXCEPTIONS                    }                on_unwind                    {#endif CATCH_NEWTON_EXCEPTIONS                    delete newchars;#ifdef CATCH_NEWTON_EXCEPTIONS                    }                end_unwind;#endif CATCH_NEWTON_EXCEPTIONS		}	return v;	}Var VM::FontMetricsGetStringWidth(Var stack[])	{	TRACE("==FontMetricsGetStringWidth==");	return FontMetricsGetWidth(FM_STRINGWIDTH, stack);	}Var VM::FontMetricsGetCharArrayWidth(Var stack[])	{	TRACE("==FontMetricsGetCharArrayWidth==");	return FontMetricsGetWidth(FM_CHARARRAYWIDTH, stack);	}Var VM::FontMetricsGetCharWidth(Var stack[])	{	TRACE("==FontMetricsGetCharWidth==");	return FontMetricsGetWidth(FM_CHARWIDTH, stack);	}//// Image//// var[0] = Class// var[1] = width// var[2] = height//#define WOBJ_ImageWidth(o) (objectPtr(o))[1].intValue#define WOBJ_ImageHeight(o) (objectPtr(o))[2].intValue#define WOBJ_NewtonBitmap(o) &((objectPtr(o))[3].refStruct)#define WOBJ_NewtonImagePromoted(o) (objectPtr(o))[4].intValueVar VM::ImageFree(Var stack[])	{	TRACE("==ImageFree==");	Var v;	WObject image = stack[0].obj;	setRefStruct(WOBJ_NewtonBitmap(image),NILREF);  // let it GC        WOBJ_NewtonImagePromoted(image) = 0;	v.obj = 0;	return v;	}	Var VM::ImageLoad(Var stack[])	{	TRACE("==ImageLoad==");	Var v;	WObject image = stack[0].obj;	WObject pathString = stack[1].obj;	RefVar bitmap = NSSend(getRefStruct(&classFetcher),		SYM(getResource), WabaStringToNewtonString(pathString));        	if (!ISNIL(bitmap))		{		RefVar bounds = NSCallGlobalFn(SYM(ShapeBounds),bitmap);		int left = RINT(GetFramePath(bounds,SYM(left)));		int top = RINT(GetFramePath(bounds,SYM(top)));		int right = RINT(GetFramePath(bounds,SYM(right)));		int bottom = RINT(GetFramePath(bounds,SYM(bottom)));                setRefStruct(WOBJ_NewtonBitmap(image),bitmap);                WOBJ_NewtonImagePromoted(image) = 0;				// set the new width and height		WOBJ_ImageWidth(image) = right-left;		WOBJ_ImageHeight(image) = bottom-top;				}	else // issue an error		{		UtfString s1 = createUtfString("Couldn't Load Bitmap: ");		UtfString s2 = stringToUtf(pathString,STU_NULL_TERMINATE | STU_USE_STATIC);		VmError(ERR_NewtOSError,NULL, &s1, &s2);		}	v.obj = 0;	return v;	}Var VM::ImageCreate(Var stack[])	{	TRACE("==ImageCreate==");	Var v;	// For now we'll assume that we're allocating the	// bitmaps on the NewtonScript heap.  That could get	// very expensive, so maybe later we should set this	// to have an options frame that stashes the image in	// a store (see p. 10-20 of the Newton Programmer's Reference)  --	// I really don't know the efficiency ramifications off this tho.		WObject image = stack[0].obj;	RefVar options = NILREF;	if (DRAW_GRAY) 		{ options = AllocateFrame(); SetFrameSlot(options,SYM(depth),MAKEINT(4)); }	initRefStruct(WOBJ_NewtonBitmap(image));  // just in case		// ImageCreate is only called when the width and height are already known	setRefStruct(WOBJ_NewtonBitmap(image),NSCallGlobalFn(SYM(MakeBitmap),		MAKEINT(WOBJ_ImageWidth(image)),MAKEINT(WOBJ_ImageHeight(image)),		options));        WOBJ_NewtonImagePromoted(image) = 1;		v.obj = 0;	return v;	}void VM::ImageDestroy(WObject image)	{	deleteRefStruct(WOBJ_NewtonBitmap(image));        WOBJ_NewtonImagePromoted(image) = 0;	}// yuck, there's no easy way to draw a scanline into a bitmap.// -- remember to ask Steve about the best way to deal with this Var VM::ImageSetPixels(Var stack[])	{	TRACE("==ImageSetPixels==");	Var v;	v.obj = 0;	return v;	}//// Rect//// var[0] = Class// var[1] = int x// var[2] = int y// var[3] = int width// var[4] = int height#define WOBJ_RectX(o) (objectPtr(o))[1].intValue#define WOBJ_RectY(o) (objectPtr(o))[2].intValue#define WOBJ_RectWidth(o) (objectPtr(o))[3].intValue#define WOBJ_RectHeight(o) (objectPtr(o))[4].intValue//// Graphics//// var[0] = Class// var[1] = Surface//#define WOBJ_GraphicsSurface(o) (objectPtr(o))[1].obj// If NewtonClippingX==CLIPPING_UNDEFINED, then we have no clipping#define WOBJ_NewtonClippingX(o) (objectPtr(o))[2].intValue#define WOBJ_NewtonClippingY(o) (objectPtr(o))[3].intValue#define WOBJ_NewtonClippingWidth(o) (objectPtr(o))[4].intValue#define WOBJ_NewtonClippingHeight(o) (objectPtr(o))[5].intValue#define WOBJ_NewtonTranslateX(o) (objectPtr(o))[6].intValue#define WOBJ_NewtonTranslateY(o) (objectPtr(o))[7].intValue// for rects and polygons#define WOBJ_NewtonDrawStyleFrame(o) &((objectPtr(o))[8].refStruct)// for lines, dots, filled rects, and filled polygons#define WOBJ_NewtonFillStyleFrame(o) &((objectPtr(o))[9].refStruct)// for drawing the "cursor", oh brother#define WOBJ_NewtonCursorStyleFrame(o) &((objectPtr(o))[10].refStruct)// for drawing text#define WOBJ_NewtonFontStyleFrame(o) &((objectPtr(o))[11].refStruct)// is my clipping dirty?#define WOBJ_NewtonClippingDirty(o) (objectPtr(o))[12].intValue#define DRAW_OVER 1#define DRAW_AND 2#define DRAW_OR 3#define DRAW_XOR 4#define GR_FILLRECT   0#define GR_DRAWLINE   1#define GR_FILLPOLY   2#define GR_DRAWCHARS  3#define GR_DRAWSTRING 4#define GR_DOTS       5#define GR_COPYRECT   6#define GR_DRAWCURSOR 7#define CLIPPING_UNDEFINED -1// Pen and fill patterns (colors)#define vfNone 0   // clear#define vfWhite 1#define vfLtGray 2#define vfGray 3#define vfDkGray 4#define vfBlack 5// The Newton's transfer modes, from the Newton 2.0 defs#define modeCopy 0#define modeOr 1#define modeXor 2#define modeBic 3#define modeNotCopy 4#define modeNotOr 5#define modeNotXor 6#define modeNotBic 7/*Because the Newton's graphics mechanism is different from Waba's,we need a bunch of different style frames.  :-(  Our style framesare as follows:Frame	Items Defined	============================================Draw		clip,   penPattern:color, 			transferMode:modeFill		clip,   fillPattern:color, penPattern:color, 	transferMode:modeFont (2.0)	clip,	font:2.0fontSpec,			transferMode:(color=white?modeBic:modeCopy)Font (2.1)	clip,	font:2.1fontSpecWithColor		transferMode:modeCopyCursor		clip,						transferMode:modeXorDraw is for: filled rects and polygons, lines and dotted lines, and bitmaps.Cursors are rectangles which Xor on and then Xor off again.2.1 Fonts SUPPOSEDLY can draw in different grays.  But not over black!At least, not in the way expected by Waba.So it looks like we'll have to forego that for now and assume that all textdrawing uses the 2.0 font frame.*/Var VM::GraphicsCreate(Var stack[])	{	TRACE("==GraphicsCreate==");	Var v;	WObject graphics = stack[0].obj;		RefVar fontframe = AllocateFrame();	RefVar drawframe = AllocateFrame();	RefVar fillframe = AllocateFrame();	RefVar cursorframe = AllocateFrame();		// make the graphics style frames	initRefStruct(WOBJ_NewtonFillStyleFrame(graphics));  // just in case	initRefStruct(WOBJ_NewtonDrawStyleFrame(graphics));  // just in case	initRefStruct(WOBJ_NewtonFontStyleFrame(graphics));  // just in case	initRefStruct(WOBJ_NewtonCursorStyleFrame(graphics));  // just in case	setRefStruct(WOBJ_NewtonDrawStyleFrame(graphics),drawframe);	setRefStruct(WOBJ_NewtonFillStyleFrame(graphics),fillframe);	setRefStruct(WOBJ_NewtonFontStyleFrame(graphics),fontframe);	setRefStruct(WOBJ_NewtonCursorStyleFrame(graphics),cursorframe);	// set our cursor frame's transfer mode to XOR    // and the default color to black	SetFrameSlot(cursorframe,SYM(transferMode), MAKEINT(modeXor));    SetFrameSlot(cursorframe,SYM(fillPattern),MAKEINT(vfBlack));    SetFrameSlot(cursorframe,SYM(penPattern),MAKEINT(vfBlack));	// set the default transfer mode of our drawing style to COPY,    // and the default color to black	SetFrameSlot(drawframe,SYM(transferMode), MAKEINT(modeCopy));    SetFrameSlot(drawframe,SYM(fillPattern),MAKEINT(vfNone));    SetFrameSlot(drawframe,SYM(penPattern),MAKEINT(vfBlack));    	// set the default transfer mode of our drawing style to COPY,    // and the default color to black	SetFrameSlot(fillframe,SYM(transferMode), MAKEINT(modeCopy));    SetFrameSlot(fillframe,SYM(fillPattern),MAKEINT(vfBlack));    SetFrameSlot(fillframe,SYM(penPattern),MAKEINT(vfBlack));        // set the default font and "color" (and mode for NOS 2.0)	// for our Newton Font Style Frame	RefVar spec = FontSpecForFont(NULL);  // default font spec	if (DRAW_GRAY)		SetFrameSlot(spec,SYM(color), 0);  // black by default	SetFrameSlot(fontframe,SYM(font), spec);	SetFrameSlot(fontframe,SYM(mode),MAKEINT(modeOr));			// set initial values for our coordinate transforms and clips	WOBJ_NewtonClippingX(graphics) = CLIPPING_UNDEFINED;	WOBJ_NewtonClippingY(graphics) = 0;  // default values, we rely on ClippingX to be undefined	WOBJ_NewtonClippingWidth(graphics) = 0;	WOBJ_NewtonClippingHeight(graphics) = 0;	WOBJ_NewtonTranslateX(graphics) = 0;  // the default values	WOBJ_NewtonTranslateY(graphics) = 0;	WOBJ_NewtonClippingDirty(graphics) = 0; // I'm not dirty, undefined is correct!	v.obj = 0;	return v;	}void VM::GraphicsDestroy(WObject graphics)	{	TRACE("==GraphicsDestroy==");	deleteRefStruct(WOBJ_NewtonFillStyleFrame(graphics));	deleteRefStruct(WOBJ_NewtonCursorStyleFrame(graphics));	deleteRefStruct(WOBJ_NewtonFontStyleFrame(graphics));        deleteRefStruct(WOBJ_NewtonDrawStyleFrame(graphics));	}Var VM::GraphicsFree(Var stack[])	{	TRACE("==GraphicsFree==");	Var v;	WObject graphics = stack[0].obj;	setRefStruct(WOBJ_NewtonFillStyleFrame(graphics),NILREF);  // let it GC	setRefStruct(WOBJ_NewtonCursorStyleFrame(graphics),NILREF);  // let it GC	setRefStruct(WOBJ_NewtonFontStyleFrame(graphics),NILREF);  // let it GC	v.obj = 0;	return v;	}Var VM::GraphicsSetFont(Var stack[])	{	TRACE("==GraphicsSetFont==");	WObject graphics = stack[0].obj;	WObject font = stack[1].obj;	Var v;	// we only care about fontstyleframe, because that's what text is drawn with	RefVar fontstyleframe = getRefStruct(WOBJ_NewtonFontStyleFrame(graphics));	if (ISNIL(fontstyleframe)) {v.obj = 0; return v;} // graphics no longer valid	RefVar fontspec = FontSpecForFont(font);	// retain the font color if it's NOS 2.1	if (DRAW_GRAY)		{		RefVar oldspec = GetFrameSlot(fontstyleframe,SYM(font));		if (!ISNIL(oldspec))			{			RefVar color = GetFrameSlot(oldspec,SYM(color));			if (!ISNIL(color)) SetFrameSlot(fontspec,SYM(color),color);			}		}	SetFrameSlot(fontstyleframe,SYM(font), fontspec);	v.obj = 0;	return v;	}Var VM::GraphicsSetColor(Var stack[])	{	TRACE("==GraphicsSetColor==");	WObject graphics = stack[0].obj;	int r = stack[1].intValue;	int g = stack[2].intValue;	int b = stack[3].intValue;	int colortag;	Var v;	// right now because we're just doing b/w, we'll do just	// what's provided in p. 10-2 of the Programmer's Reference,	// namely white, ltgray, gray, dkgray, and black.    	// I'm setting them to the average of the three colors:	// white: 204-255	// ltgray: 153-203	// gray: 102-152	// dkgray: 51-101	// black: 0-50		RefVar drawstyleframe = getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics));	RefVar fillstyleframe = getRefStruct(WOBJ_NewtonFillStyleFrame(graphics));	RefVar fontstyleframe = getRefStruct(WOBJ_NewtonFontStyleFrame(graphics));		if (ISNIL(fillstyleframe)) {v.obj = 0; return v;} // graphics no longer valid	// int avgcolor = (r + g + b) / 3;  // simple averaging	int avgcolor = (30 * r + 59 * g + 11 * b) / 100;  // NTSC standard color to grayscale weighted averaging,  see p. 304 of the PostScript Language Reference Manual (Second Edition)		if (DRAW_GRAY)		{#define RGB_PACKEDINTEGER (0x10000000)#define GRAYINCREMENT (0x00111111)		// divide avgcolor by 16 to bin it		avgcolor /= 16;		colortag = RGB_PACKEDINTEGER + GRAYINCREMENT * avgcolor;  // See Newton 2.1 defs		RefVar fontspec = GetFrameSlot(fontstyleframe,SYM(font));		RefVar color = MAKEINT(colortag);		SetFrameSlot(fillstyleframe,SYM(fillPattern),color);		SetFrameSlot(fillstyleframe,SYM(penPattern),color);		SetFrameSlot(drawstyleframe,SYM(penPattern),color);				// presently it does not appear that font color works correctly		// if blitted over black areas etc on NOS 2.1.  So I'm going to only		// allow font color to be black or white, just like it's done for		// NOS 2.0.  What we'll do is: if my avgcolor is >= 8, I'm modebic				// turn this off for now, it doesn't work right		// SetFrameSlot(fontspec,SYM(color),color);	    	if (avgcolor >= 8)		    	SetFrameSlot(fontstyleframe,SYM(transferMode),MAKEINT(modeBic));		else SetFrameSlot(fontstyleframe,SYM(transferMode),MAKEINT(modeOr));  // assume it's black		}	else		{		// most common item first: black		if (avgcolor <= 50)		    colortag = vfBlack;		else if (avgcolor >= 204)		    colortag = vfWhite;		else if (avgcolor >= 153)		    colortag = vfLtGray;		else if (avgcolor >= 102)		    colortag = vfGray;		else if (avgcolor >= 51)		    colortag = vfDkGray;		else  // should never reach here		    colortag = vfBlack;		// set the color for both the pen and the fill for now		RefVar color = MAKEINT(colortag);		SetFrameSlot(fillstyleframe,SYM(fillPattern),color);		SetFrameSlot(fillstyleframe,SYM(penPattern),color);		SetFrameSlot(drawstyleframe,SYM(penPattern),color);				// NewtOS 2.1 lets you set the colors of fonts.  But NewtOS 2.0 does NOT.		// so to do this for now what we'll have to do is: if it's vfWhite then		// we set the font style frame to have modeBic, otherwise it's set to		// modeOr	    	if (colortag==vfWhite || colortag==vfLtGray)  // light stuff.  Dark stuff is vfGray, vfDkGray, vfBlack		    	SetFrameSlot(fontstyleframe,SYM(transferMode),MAKEINT(modeBic));		else SetFrameSlot(fontstyleframe,SYM(transferMode),MAKEINT(modeOr));		}			v.obj = 0;	return v;	}Var VM::GraphicsSetDrawOp(Var stack[])	{	TRACE("==GraphicsSetDrawOp==");	Var v;	WObject graphics = stack[0].obj;	int op = stack[1].intValue;	int transfermode;	RefVar fillstyleframe = getRefStruct(WOBJ_NewtonFillStyleFrame(graphics));	RefVar drawstyleframe = getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics));	// don't grab the cursor style frame	// don't grab the bitmap style frame	if (ISNIL(fillstyleframe)) {v.obj = 0; return v;} // graphics no longer valid	switch(op)	    {	    case DRAW_OVER:		transfermode = modeCopy;		break;	    case DRAW_AND:	    	transfermode = modeNotBic;		break;	    case DRAW_OR:	    	transfermode = modeOr;	    	break;	    case DRAW_XOR:	    	transfermode = modeXor;		break;	    default:	    	transfermode = modeCopy;	    	break;	    }		RefVar mode = MAKEINT(transfermode);	SetFrameSlot(fillstyleframe,SYM(transferMode),mode);	SetFrameSlot(drawstyleframe,SYM(transferMode),mode);	if (DRAW_GRAY)		SetFrameSlot(getRefStruct(WOBJ_NewtonFontStyleFrame(graphics)),			SYM(transferMode),mode);	v.obj = 0;	return v;	}/*if maxright==-1 or maxbottom==-1, both are ignored.Otherwise, we clip to the clipping region, PLUS the clipping regionformed by {top:0, left:0, right:maxright, bottom:maxbottom}*/void VM::GraphicsCreateClippingRegion(WObject graphics)	{	TRACE("==GraphicsCreateClippingRegion==");	// The Newton has very powerful clipping abilities, but we're only going	// to use a rectangle to clip.  We need to maintain the clipping information	// for GraphicsGetClip below also, hence the four additional ints as hooks		RefVar fillstyleframe = getRefStruct(WOBJ_NewtonFillStyleFrame(graphics));	RefVar drawstyleframe = getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics));	RefVar cursorstyleframe = getRefStruct(WOBJ_NewtonCursorStyleFrame(graphics));	RefVar fontstyleframe = getRefStruct(WOBJ_NewtonFontStyleFrame(graphics));	if (ISNIL(fillstyleframe)) return;  // graphics no longer valid	if (WOBJ_NewtonClippingX(graphics)==CLIPPING_UNDEFINED)	    {	    RemoveSlot(fillstyleframe,SYM(clipping));            RemoveSlot(drawstyleframe,SYM(clipping));	    RemoveSlot(cursorstyleframe,SYM(clipping));	    RemoveSlot(fontstyleframe,SYM(clipping));	    PRINTSTR("--Removed");	    }	else		{		int left = WOBJ_NewtonClippingX(graphics);		int top = WOBJ_NewtonClippingY(graphics);		// it turns out that the Newton doesn't clip right -- it yanks		// off one extra col/row on all sides.  So		// here we WON'T subtract 1 to get right and bottom, which is		// what would normally be done.        		int right = WOBJ_NewtonClippingWidth(graphics) + left;		int bottom = WOBJ_NewtonClippingHeight(graphics) + top;		RefVar rect = NSCallGlobalFn(SYM(MakeRect),MAKEINT(left-1),MAKEINT(top-1),					MAKEINT(right),MAKEINT(bottom));		SetFrameSlot(fillstyleframe,SYM(clipping),rect);                SetFrameSlot(drawstyleframe,SYM(clipping),rect);		SetFrameSlot(cursorstyleframe,SYM(clipping),rect);		SetFrameSlot(fontstyleframe,SYM(clipping),rect);		}	}	Var VM::GraphicsSetClip(Var stack[])	{	TRACE("==GraphicsSetClip==");	Var v;	WObject graphics = stack[0].obj;	int x = stack[1].intValue;	int y = stack[2].intValue;	int width = stack[3].intValue;	int height = stack[4].intValue;		// translate the clipping	int newX = x + WOBJ_NewtonTranslateX(graphics);	int newY = y + WOBJ_NewtonTranslateY(graphics);        	// it'd be nice here to also check to see if the clipping is out	// of bounds for the window, but we don't have the window here so	// we'll delay that until drawing-time if we do it at all...		// next we need to see if this clip is different from our previous clip.	// if it is, we register ourselves as dirty and we'll get a new clip	// when we draw next time.		if (WOBJ_NewtonClippingX(graphics) != newX ||   	// ClippingX could be CLIPPING_UNDEFINED (-1) (no clip)	    WOBJ_NewtonClippingY(graphics) != newY ||	    WOBJ_NewtonClippingWidth(graphics) != width ||	    WOBJ_NewtonClippingHeight(graphics) != height)		{		WOBJ_NewtonClippingDirty(graphics) = 1;		WOBJ_NewtonClippingX(graphics) = newX;		WOBJ_NewtonClippingY(graphics) = newY;	    WOBJ_NewtonClippingWidth(graphics) = width;		WOBJ_NewtonClippingHeight(graphics) = height;		}	v.obj = 0;	return v;	}Var VM::GraphicsGetClip(Var stack[])	{	TRACE("==GraphicsGetClip==");	Var v;	WObject graphics = stack[0].obj;	WObject rect = stack[1].obj;	if (rect==NULL || WOBJ_NewtonClippingX(graphics)==CLIPPING_UNDEFINED)		{v.obj = NULL; return v; }  // no clipping or user passed in a null rect	WOBJ_RectX(rect) = WOBJ_NewtonClippingX(graphics) - WOBJ_NewtonTranslateX(graphics);	WOBJ_RectY(rect) = WOBJ_NewtonClippingY(graphics) - WOBJ_NewtonTranslateY(graphics);	WOBJ_RectWidth(rect) = WOBJ_NewtonClippingWidth(graphics);	WOBJ_RectHeight(rect) = WOBJ_NewtonClippingHeight(graphics);		v.obj = rect;	return v;	}Var VM::GraphicsClearClip(Var stack[])	{	TRACE("==GraphicsClearClip==");	Var v;	WObject graphics = stack[0].obj;	if (WOBJ_NewtonClippingX(graphics) != CLIPPING_UNDEFINED)		{		WOBJ_NewtonClippingDirty(graphics) = 1;		WOBJ_NewtonClippingX(graphics) = CLIPPING_UNDEFINED;		}	v.obj = 0;	return v;	}Var VM::GraphicsTranslate(Var stack[])	{	TRACE("==GraphicsTranslate==");	Var v;	WObject graphics = stack[0].obj;	int x = stack[1].intValue;	int y = stack[2].intValue;	// for some reason our translation mechanism is relative,	// not absolute.  So we have to do a +=, not an =	WOBJ_NewtonTranslateX(graphics) += x;	WOBJ_NewtonTranslateY(graphics) += y;        v.obj = 0;	return v;	}void VM::SplatBufferIntoWindow(WObject window, RefArg clipframe)	{	RefVar win = getRefStruct(WOBJ_Window_NewtonWindow(window));	RefVar buffer = getRefStruct(WOBJ_Window_NewtonWindowBuffer(window));        RefVar s_clipping = SYM(clipping);        		// clip to smaller area -- perhaps this will make things faster (?)	if (!ISNIL(clipframe))		{		RefVar clip = GetFrameSlot(clipframe,s_clipping);                if (!ISNIL(clip)) SetFrameSlot(getRefStruct(&bufferStyleFrame),s_clipping,clip);                else SetFrameSlot(getRefStruct(&bufferStyleFrame),s_clipping,NILREF);  // we're global -- need to reset to the default		}        else SetFrameSlot(getRefStruct(&bufferStyleFrame),s_clipping,NILREF);  // we're global -- need to reset to the default		// splat image into window	if (drawArray==NULL)  // not allocated yet		setRefStruct(&drawArray,AllocateArray(SYM(array),2));	SetArraySlot(getRefStruct(&drawArray),0,buffer);	SetArraySlot(getRefStruct(&drawArray),1,getRefStruct(&bufferStyleFrame));	RefVar drawArea = GetFramePath(win,SYM(wabaDrawingArea));	NSSend(drawArea,SYM(Scribble),SYM(DrawShape),getRefStruct(&drawArray));				}void VM::DrawNewtonGraphics(RefArg shape,			    WObject graphics,  // for the clips, translates, and surface                RefArg styleframe) // the particular styleframe we want to use	{	TRACE("==DrawNewtonGraphics==");		WObject surface = WOBJ_GraphicsSurface(graphics);	if (surface==NULL || ISNIL(styleframe)) return;  // no longer valid		RefVar shape1 = shape;  // move the RefArg to a RefVar	// we could improve drawing somewhat by doing our own translating.	// but for now we'll let NewtonScript do it for us.		int transx = WOBJ_NewtonTranslateX(graphics);	int transy = WOBJ_NewtonTranslateY(graphics);	// lazily create our clipping region	if (WOBJ_NewtonClippingDirty(graphics))		{        GraphicsCreateClippingRegion(graphics);		WOBJ_NewtonClippingDirty(graphics) = 0;		}		    if (transx || transy)		shape1 = NSCallGlobalFn(SYM(OffsetShape),shape,			MAKEINT(transx),MAKEINT(transy));	if (SurfaceGetType(surface)==SURF_IMAGE)	// draw into an image		{               // PRINTSTR("--Image");                if (getRefStruct(WOBJ_NewtonBitmap(surface))!=NULL)                    {                    // promote the image if necessary                    if (!WOBJ_NewtonImagePromoted(surface))                        {                        setRefStruct(WOBJ_NewtonBitmap(surface),                            NSCallGlobalFn(SYM(MakeShape),                                getRefStruct(WOBJ_NewtonBitmap(surface))));   // promote image to writeable format                        WOBJ_NewtonImagePromoted(surface) = 1;                        }                    RefVar image = getRefStruct(WOBJ_NewtonBitmap(surface));                    NSCallGlobalFn(SYM(DrawIntoBitmap),shape1,styleframe,image);                    }		}	else if (doubleBuffer)	// draw in a buffered view		{		// PRINTSTR("--Buffered View");		RefVar buffer = getRefStruct(WOBJ_Window_NewtonWindowBuffer(surface));		NSCallGlobalFn(SYM(DrawIntoBitmap),shape1,styleframe,buffer);		SplatBufferIntoWindow(surface,styleframe);		}	else // unbuffered view		{		// PRINTSTR("--View");                RefVar win = getRefStruct(WOBJ_Window_NewtonWindow(surface));		// use my special array		if (drawArray==NULL) // not allocated yet			setRefStruct(&drawArray,AllocateArray(SYM(array),2));        SetArraySlot(getRefStruct(&drawArray),0,shape1);		SetArraySlot(getRefStruct(&drawArray),1,styleframe);		// p. 10-40 of the Programmer's guide is vague about the purpose of		// the second "parameters" argument to the DoDrawing method -- it's		// supposed to be an array, but I can't tell if the array is passed		// to the underlying method or if the arguments are removed and passed		// together to the underlying method (a-la Lisp-style @, ).  Presently		// I'm assuming the latter.  If it's the former, then we need to have		// our windows implement a little cover function.				// to do this we need to grab the drawing area view.  Presently		// it's the first item in the viewChildren array of our main proto		RefVar drawArea = GetFramePath(win,SYM(wabaDrawingArea));		NSSend(drawArea,SYM(Scribble),SYM(DrawShape),getRefStruct(&drawArray));		}	}		Var VM::GraphicsDrawRect(Var stack[])	{	TRACE("==GraphicsDrawRect==");	Var v;		WObject graphics = stack[0].obj;	int x = stack[1].intValue;	int y = stack[2].intValue;	int width = stack[3].intValue;	int height = stack[4].intValue;	DrawNewtonGraphics(NSCallGlobalFn(SYM(MakeRect),				MAKEINT(x),MAKEINT(y),				// dunno if you need to subtract 1 from each of these				MAKEINT(x+width),MAKEINT(y+height)),				graphics,				getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics)));	v.obj = 0;	return v;	}Var VM::GraphicsFillRect(Var stack[])	{	TRACE("==GraphicsFillRect==");	Var v;		WObject graphics = stack[0].obj;	int x = stack[1].intValue;	int y = stack[2].intValue;	int width = stack[3].intValue;	int height = stack[4].intValue;	DrawNewtonGraphics(NSCallGlobalFn(SYM(MakeRect),				MAKEINT(x),MAKEINT(y),				// dunno if you need to subtract 1 from each of these				MAKEINT(x+width),MAKEINT(y+height)),				graphics,				getRefStruct(WOBJ_NewtonFillStyleFrame(graphics)));	v.obj = 0;	return v;	}Var VM::GraphicsDrawLine(Var stack[])	{	TRACE("==GraphicsDrawLine==");	Var v;	WObject graphics = stack[0].obj;	int x1 = stack[1].intValue;	int y1 = stack[2].intValue;	int x2 = stack[3].intValue;	int y2 = stack[4].intValue;	DrawNewtonGraphics(NSCallGlobalFn(SYM(MakeLine),				MAKEINT(x1),MAKEINT(y1),				MAKEINT(x2),MAKEINT(y2)),				graphics,				getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics)));	v.obj = 0;	return v;	}Var VM::GraphicsDrawPolygon(Var stack[])	{	TRACE("==GraphicsDrawPolygon==");	Var v;	WObject graphics = stack[0].obj;	int xArray = stack[1].obj;	int yArray = stack[2].obj;	int count = stack[3].intValue;	if (count < 2 || count > WOBJ_arrayLen(xArray) ||		count > WOBJ_arrayLen(yArray))		{v.obj = 0; return v;} // invalid polygon			// build our polygon array -- p. 10-29 is woefully	// inadequate in describing what the array is supposed	// to look like!  I assume it's [x1,y1,x2,y2,...]		int* xx = (int32 *)WOBJ_arrayStart(xArray);	int* yy = (int32 *)WOBJ_arrayStart(yArray);	RefVar array = AllocateArray(SYM(array),count*2+2);	int i2 =0;	for(int i=0;i<count;i++)		{		SetArraySlot(array,i2++,MAKEINT(xx[i]));		SetArraySlot(array,i2++,MAKEINT(yy[i]));		}        // Duh, NewtonScript Polygons require you to specify        // the first point at the end as well, ick.        SetArraySlot(array,i2++,MAKEINT(xx[0]));        SetArraySlot(array,i2++,MAKEINT(yy[0]));			DrawNewtonGraphics(NSCallGlobalFn(SYM(MakePolygon),array),		graphics,		getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics)));	v.obj = 0;	return v;	}Var VM::GraphicsFillPolygon(Var stack[])	{	TRACE("==GraphicsFillPolygon==");	Var v;	WObject graphics = stack[0].obj;	int xArray = stack[1].obj;	int yArray = stack[2].obj;	int count = stack[3].intValue;	if (count < 2 || count > WOBJ_arrayLen(xArray) ||		count > WOBJ_arrayLen(yArray))		{v.obj = 0; return v;} // invalid polygon			// build our polygon array -- p. 10-29 is woefully	// inadequate in describing what the array is supposed	// to look like!  I assume it's [x1,y1,x2,y2,...]		int* xx = (int32 *)WOBJ_arrayStart(xArray);	int* yy = (int32 *)WOBJ_arrayStart(yArray);	RefVar array = AllocateArray(SYM(array),count*2);	int i2 =0;	for(int i=0;i<count;i++)		{		SetArraySlot(array,i2++,MAKEINT(xx[i]));		SetArraySlot(array,i2++,MAKEINT(yy[i]));		}			DrawNewtonGraphics(NSCallGlobalFn(SYM(MakePolygon),array),		graphics,		getRefStruct(WOBJ_NewtonFillStyleFrame(graphics)));	v.obj = 0;	return v;	}// somthing much larger than any screen#define BIG_NUMBER 1000000Var VM::GraphicsDrawChars(Var stack[])	{	TRACE("==GraphicsDrawChars==");	Var v;	unsigned short* chars;		WObject graphics = stack[0].obj;	WObject charArray = stack[1].obj;	int start = stack[2].intValue;	int count = stack[3].intValue;	int x = stack[4].intValue;	int y = stack[5].intValue;	if (arrayRangeCheck(charArray, start, count) == 0)		{v.obj=0; return v;} // array null or range invalid	chars = (uint16 *)WOBJ_arrayStart(charArray);	chars = &chars[start];	// because we can't be sure that there's a closing terminator,	// we have to copy it into a new array in order to make	// the string.  :-(		uint16* newchars = new uint16[count+1];#ifdef CATCH_NEWTON_EXCEPTIONS	unwind_protect            {#endif CATCH_NEWTON_EXCEPTIONS            Ustrncpy(newchars,chars,count);            // terminate just in case            newchars[count] = 0;            RefVar str = MakeString(newchars);	            RefVar fontspec = GetFramePath(getRefStruct(		WOBJ_NewtonFontStyleFrame(graphics)),SYM(font));            int baseline = 		RINT(NSCallGlobalFn(SYM(FontAscent),fontspec));	            // we hack the ascent so that it's slightly smaller -- the Newton            // has too high an ascent as far as Waba is concerned.  The only            // critical item is Espy 10, which we use for our controls.            if (!ISNIL(GetFrameSlot(fontspec,SYM(system))))		baseline--;            // Now we draw the string	            DrawNewtonGraphics(NSCallGlobalFn(SYM(MakeText),str,MAKEINT(x),MAKEINT(y),					MAKEINT(BIG_NUMBER),MAKEINT(y+baseline)),		graphics,		getRefStruct(WOBJ_NewtonFontStyleFrame(graphics)));#ifdef CATCH_NEWTON_EXCEPTIONS            }        on_unwind            {#endif CATCH_NEWTON_EXCEPTIONS            delete newchars;#ifdef CATCH_NEWTON_EXCEPTIONS            }        end_unwind;#endif CATCH_NEWTON_EXCEPTIONS        	v.obj = 0;	return v;	}Var VM::GraphicsDrawString(Var stack[])	{	TRACE("==GraphicsDrawString==");	Var v;	unsigned short* chars;		WObject graphics = stack[0].obj;	WObject string = stack[1].obj;	int x = stack[2].intValue;	int y = stack[3].intValue;	WObject charArray = WOBJ_StringCharArrayObj(string);	if (charArray == 0)		{v.obj = 0; return v;} // nothing to do	chars = (uint16 *)WOBJ_arrayStart(charArray);	int count = WOBJ_arrayLen(charArray);	// because we can't be sure that there's a closing terminator,	// we have to copy it into a new array in order to make	// the string.  :-(		uint16* newchars = new uint16[count+1];#ifdef CATCH_NEWTON_EXCEPTIONS        unwind_protect            {#endif CATCH_NEWTON_EXCEPTIONS            Ustrncpy(newchars,chars,count);            // terminate just in case            newchars[count] = 0;            RefVar str = MakeString(newchars);                    RefVar fontspec = GetFramePath(getRefStruct(		WOBJ_NewtonFontStyleFrame(graphics)),SYM(font));            int baseline = 		RINT(NSCallGlobalFn(SYM(FontAscent),fontspec));            // we hack the ascent so that it's slightly smaller -- the Newton            // has too high an ascent as far as Waba is concerned.  The only            // critical item is Espy 10, which we use for our controls.            if (!ISNIL(GetFrameSlot(fontspec,SYM(system))))		baseline--;            // Now we draw the string	            DrawNewtonGraphics(NSCallGlobalFn(SYM(MakeText),str,MAKEINT(x),MAKEINT(y),					MAKEINT(BIG_NUMBER),MAKEINT(y+baseline)),		graphics,		getRefStruct(WOBJ_NewtonFontStyleFrame(graphics)));#ifdef CATCH_NEWTON_EXCEPTIONS            }        on_unwind            {#endif CATCH_NEWTON_EXCEPTIONS            delete newchars;#ifdef CATCH_NEWTON_EXCEPTIONS           }        end_unwind;#endif CATCH_NEWTON_EXCEPTIONS        	v.obj = 0;	return v;	}#define DOT_SEPARATION 4Var VM::GraphicsDrawDots(Var stack[])	{	TRACE("==GraphicsDrawDots==");	// I imagine we could use a custom pattern, but I'm not sure	// what that pattern would be or how to do it.  So I'm going	// to just draw a bunch of dots.  We'll do a dot every 4 pixels.	// We know that the lines HAVE to be horizontal or vertical	Var v;	WObject graphics = stack[0].obj;	int x1 = stack[1].intValue;	int y1 = stack[2].intValue;	int x2 = stack[3].intValue;	int y2 = stack[4].intValue;		if (x1!=x2 && y1!=y2)  // diagonal		{v.obj = 0; return v; }		int numdots;	int sign;	int horizontal;	if (x1!=x2)		{		sign = (x2 > x1 ? 1 : -1 );		numdots = (sign * (x2 - x1) + 1) / DOT_SEPARATION;		horizontal = 1;		}	else			{		sign = (y2 > y1 ? 1 : -1 );		numdots = (sign * (y2 - y1) + 1) / DOT_SEPARATION;		horizontal = 0;		}			RefVar array = AllocateArray(SYM(array),numdots);	for(int i=0;i<numdots;i++)		{		if (horizontal) // horizontal			SetArraySlot(array,i,NSCallGlobalFn(SYM(MakeLine),				MAKEINT(x1+i*DOT_SEPARATION*sign),				MAKEINT(y1),			    	MAKEINT(x1+i*DOT_SEPARATION*sign),				MAKEINT(y1)));		else	   // vertical			SetArraySlot(array,i,NSCallGlobalFn(SYM(MakeLine),				MAKEINT(x1),				MAKEINT(y1+i*DOT_SEPARATION*sign),				MAKEINT(x1),				MAKEINT(y1+i*DOT_SEPARATION*sign)));		}	DrawNewtonGraphics(array,		graphics,		getRefStruct(WOBJ_NewtonDrawStyleFrame(graphics)));	v.obj = 0;	return v;	}Ref VM::SnarfIntoBitmap(int x, int y, int width, int height, 			 WObject surface)	{	TRACE("==SnarfIntoBitmap==");	if (surface==NULL) return NILREF;  // no longer valid	// Make the bitmap	RefVar options = NILREF;	if (DRAW_GRAY) 		{ options = AllocateFrame(); SetFrameSlot(options,SYM(depth),MAKEINT(4)); }	RefVar bitmap = NSCallGlobalFn(SYM(MakeBitmap),	    MAKEINT(width), MAKEINT(height),options);	if (SurfaceGetType(surface)==SURF_IMAGE)	// grab from an image		{		RefVar image = getRefStruct(WOBJ_NewtonBitmap(surface));		// first, let's check to see if the shape bounds are equal		// to the bitmap, if so we can be a little cheaper		RefVar bounds = NSCallGlobalFn(SYM(ShapeBounds),image);		int left = RINT(GetFramePath(bounds,SYM(left)));		int top = RINT(GetFramePath(bounds,SYM(top)));		int right = RINT(GetFramePath(bounds,SYM(right)));		int bottom = RINT(GetFramePath(bounds,SYM(bottom)));		if (left==x && top==y &&		    right==x+width && bottom==y+height)  // we're in business			{			NSCallGlobalFn(SYM(DrawIntoBitmap),image,NILREF,bitmap);			return bitmap;			}				// Well, we can't cop out at this point, so this will be expensive!		// Translate the image		if ( x || y )			image = NSCallGlobalFn(SYM(OffsetShape), image,				MAKEINT(-x), MAKEINT(-y));					// Now we draw the image into the bitmap -- as it's		// been translated, some of it is negative and should		// get cropped out (I hope!)		NSCallGlobalFn(SYM(DrawIntoBitmap),image,NILREF,bitmap);                // Translate the image back		if (x||y)			image = NSCallGlobalFn(SYM(OffsetShape), image,				MAKEINT(x), MAKEINT(y));				return bitmap;		}	else if (doubleBuffer)	// grab from the buffered view  -- unlike unbuffered views, this works like a charm!		{                PRINTSTR("Double buffer!");		RefVar image = getRefStruct(WOBJ_Window_NewtonWindowBuffer(surface));		// first, let's check to see if the shape bounds are equal		// to the bitmap, if so we can be a little cheaper		RefVar bounds = NSCallGlobalFn(SYM(ShapeBounds),image);		int left = RINT(GetFramePath(bounds,SYM(left)));		int top = RINT(GetFramePath(bounds,SYM(top)));		int right = RINT(GetFramePath(bounds,SYM(right)));		int bottom = RINT(GetFramePath(bounds,SYM(bottom)));		if (left==x && top==y &&		    right==x+width && bottom==y+height)  // we're in business			{			PRINTSTR("Splatting");			NSCallGlobalFn(SYM(DrawIntoBitmap),image,NILREF,bitmap);			return bitmap;			}				// Well, we can't cop out at this point, so this will be very expensive!		// Translate the image		image = NSCallGlobalFn(SYM(OffsetShape), image,			MAKEINT(-x), MAKEINT(-y));		// Now we draw the image into the bitmap -- as it's		// been translated, some of it is negative and should		// get cropped out (I hope!)		NSCallGlobalFn(SYM(DrawIntoBitmap),image,NILREF,bitmap);				// Translate the image back		image = NSCallGlobalFn(SYM(OffsetShape), image,			MAKEINT(x), MAKEINT(y));		return bitmap;		}    else return bitmap;  // unbuffered window, can't do anything	}// this appears to be a very problematic function.  To implement it,// SnarfIntoBitmap must call ViewIntoBitmap, which in turn calls // ViewDrawScript -- so this native function would result in calling// _doPaint!!!  -- I'll try turning off ViewDrawScript, but I don't think// it will work, we'll see.Var VM::GraphicsCopyRect(Var stack[])	{	TRACE("==GraphicsCopyRect==");	Var v;	WObject graphics = stack[0].obj;	WObject srcSurf = stack[1].obj;	int x = stack[2].intValue;	int y = stack[3].intValue;	int w = stack[4].intValue;    	int h = stack[5].intValue;	WObject dstX = stack[6].intValue;	WObject dstY = stack[7].intValue;	RefVar bitmap = SnarfIntoBitmap(x,y,w,h,srcSurf);    if (ISNIL(bitmap)) // invalid for some reason        {v.obj=0; return v;}	bitmap = NSCallGlobalFn(SYM(OffsetShape), bitmap,		    MAKEINT(dstX), MAKEINT(dstY));	DrawNewtonGraphics(bitmap,		graphics,		getRefStruct(WOBJ_NewtonFillStyleFrame(graphics)));    v.obj = 0;    return v;	}Var VM::GraphicsDrawCursor(Var stack[])	{	TRACE("==GraphicsDrawCursor==");	// I have absolutely no idea why this has to be different	// from GraphicsFillRect, what a pain.	Var v;	WObject graphics = stack[0].obj;	int x = stack[1].intValue;	int y = stack[2].intValue;	int width = stack[3].intValue;	int height = stack[4].intValue;	DrawNewtonGraphics(NSCallGlobalFn(SYM(MakeRect),				MAKEINT(x),MAKEINT(y),				MAKEINT(x+width),MAKEINT(y+height)),		graphics,		getRefStruct(WOBJ_NewtonCursorStyleFrame(graphics)));	v.obj = 0;	return v;	}//// File//// Dunno if we'll be able to implement this -- the Newton doesn't// have a file-oriented mechanism.  Any ideas?// STUBBED OUT for nowVar VM::FileGetLength(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileCreateDir(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileCreate(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileListDir(Var stack[])    {	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileIsDir(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileClose(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileDelete(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileExists(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileIsOpen(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileSeek(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileRename(Var stack[])	{	Var v;	v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::FileRead(Var stack[])	{	Var v;	v.intValue = -1;	return v;	}// STUBBED OUT for nowVar VM::FileWrite(Var stack[])	{	Var v;	v.intValue = -1;	return v;	}// The Socket code was here.#include "NewtSockets.cp"//// Sound//// all functions // STUBBED OUT for now -- dunno if we can implement thisVar VM::SoundTone(Var stack[])	{	TRACE("==SoundTone==");        Var v;	if (noSound) { v.obj=0; return v; }                int frequency = stack[0].intValue;        int duration = stack[1].intValue;                RefVar mywin = getRefStruct(WOBJ_Window_NewtonWindow(globalMainWin));        RefVar drawArea = GetFramePath(mywin,SYM(wabaDrawingArea));        NSSend(drawArea,SYM(playSoundTone),MAKEINT(frequency),MAKEINT(duration));	        v.obj = 0;	return v;	}Var VM::SoundBeep(Var stack[])	{	TRACE("==SoundBeep==");	Var v;	if (noSound) { v.obj=0; return v; }	RefVar root = NSCallGlobalFn(SYM(GetRoot));	NSSend(root,SYM(SysBeep));	v.obj = 0;	return v;	}//// SoundClip//// STUBBED OUT for now -- dunno if we can implement thisVar VM::SoundClipPlay(Var stack[])	{	TRACE("==SoundClipPlay==");        Var v;	if (noSound) { v.obj=0; return v; }	v.obj = 0;	return v;	}//// Convert//Var VM::ConvertFloatToIntBitwise(Var stack[])	{	TRACE("==ConvertFloatToIntBitwise==");	return stack[0];	}Var VM::ConvertIntToFloatBitwise(Var stack[])	{	TRACE("==ConvertIntToFloatBitwise==");	return stack[0];	}Var VM::ConvertStringToInt(Var stack[])	{	TRACE("==ConvertStringToInt==");	UtfString s;	WObject string;	Var v;	v.intValue = 0;	string = stack[0].obj;	s = stringToUtf(string, STU_USE_STATIC | STU_NULL_TERMINATE);	if (s.len == 0)		return v;	v.intValue = (int32)atoi(s.str);	return v;	}void VM::itoa(char* buf, int n)        {/* Below we steal from p. 64 of the K&R */        int i, sign;        if ((sign=n) < 0)            n = -n;        i=0;        do            buf[i++] = n % 10 + '0';        while ((n /= 10) > 0);        if (sign < 0)            buf[i++] = '-';        buf[i] = '\0';/* Now we reverse buf as in p. 62 */        int c /*,i*/, j;        for(i=0, j=strlen(buf)-1;i<j; i++,j--)            {            c=buf[i];            buf[i]=buf[j];            buf[j]=c;            }        }Var VM::ConvertIntToString(Var stack[])	{	TRACE("==ConvertIntToString==");	Var v;	char buf[20];	xmemzero((uchar *)buf, 20);        itoa(buf,stack[0].intValue);	v.obj = createString(buf);	return v;	}Var VM::ConvertFloatToString(Var stack[])	{	TRACE("==ConvertFloatToString==");	Var v;	char buf[60];// p. 8-18 of the Newton C Reference has a very strange warning about using// floating-point values.  It looks like they had *meant* to include this for// sscanf, not sprintf.  So I'm going to assume it's incorrect and go// with a plain-jane sprintf.  -- Sean// In the CoreTest application, the convert test (test #8) suggests that// it expects that string forms of floating point values must have at least// seven decimal places, not 6 which is the standard for printf.  So we're// bumping it to 7 to look good for CoreTest. 	sprintf(buf,"%.7f",(double)(stack[0].floatValue));	v.obj = createString(buf);	return v;	}Var VM::ConvertCharToString(Var stack[])	{	TRACE("==ConvertCharToString==");	Var v;        char buf[2];        buf[0] = (char)stack[0].intValue;        buf[1] = 0;	v.obj = createString(buf);	return v;	}Var VM::ConvertBooleanToString(Var stack[])	{	TRACE("==ConvertBooleanToString==");	Var v;	char *s;	if (stack[0].intValue == 0)		s = "false";	else		s = "true";	v.obj = createString(s);	return v;	}//// Catalog//// var[0] = Class#define WOBJ_CatalogFrame(o) &((objectPtr(o))[1].refStruct)// this stuff will be totally ignored -- Newton soups are always read/write/create#define Catalog_READ_ONLY 1#define Catalog_WRITE_ONLY 2#define Catalog_READ_WRITE 3#define Catalog_CREATE 4// STUBBED OUT for nowVar VM::CatalogCreate(Var stack[])	{        TRACE("==CatalogCreate==");	Var v;    RefStruct** ref = WOBJ_CatalogFrame(stack[0].obj);    initRefStruct(ref);        RefVar mainVmApp = GetFramePath(NSCallGlobalFn(SYM(GetRoot)), SYM(VM:waba));    setRefStruct(ref,NSSend(mainVmApp,SYM(CatalogCreate),        getRefStruct(&uniqueSymbol),        WabaStringToNewtonString(stack[1].obj),        MAKEINT(stack[2].intValue)));        v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::CatalogIsOpen(Var stack[])	{	TRACE("==CatalogIsOpen==");        Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    if (!ISNIL(NSSendIfDefined(getRefStruct(frame),SYM(CatalogIsOpen)))) v.intValue=1;	return v;	}// STUBBED OUT for nowvoid VM::CatalogDestroy(WObject cat)	{        TRACE("==CatalogDestroy==");        RefStruct** frame = WOBJ_CatalogFrame(cat);        NSSendIfDefined(getRefStruct(frame),SYM(CatalogDestroy));        deleteRefStruct(frame);	}// STUBBED OUT for nowVar VM::CatalogClose(Var stack[])	{        TRACE("==CatalogClose==");	Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    if (!ISNIL(NSSendIfDefined(getRefStruct(frame),SYM(CatalogClose)))) v.intValue=1;	return v;	}// STUBBED OUT for nowVar VM::CatalogDelete(Var stack[])	{	TRACE("==CatalogDelete==");        Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    if (!ISNIL(NSSendIfDefined(getRefStruct(frame),SYM(CatalogDelete)))) v.intValue=1;	return v;	}// STUBBED OUT for nowVar VM::CatalogListCatalogs(Var stack[])	{        TRACE("==CatalogListCatalogs==");    // this one is static.  So stack[0].obj DOESN'T EXIST    	Var v;    RefVar mainVmApp = GetFramePath(NSCallGlobalFn(SYM(GetRoot)), SYM(VM:waba));    RefVar catalogs = NSSend(mainVmApp,SYM(CatalogListCatalogs),getRefStruct(&uniqueSymbol));        int len=0;    if (!ISNIL(catalogs) && (len=Length(catalogs))!=0)        {        // build the string array to return        WObject stringArray = createArrayObject(1,len);        pushObject(stringArray);        WObject* strings = (WObject *)WOBJ_arrayStart(stringArray);        for(int x=0;x<len;x++)            strings[x] = NewtonStringToWabaString(GetArraySlot(catalogs,x));        popObject();  // stringArray        v.obj = stringArray;        }    else v.obj = 0;	return v;	}// STUBBED OUT for nowVar VM::CatalogGetRecordSize(Var stack[])	{        TRACE("==CatalogGetRecordSize==");	Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogGetRecordSize));    if (ISINT(result)) v.intValue = RINT(result);	return v;	}// STUBBED OUT for nowVar VM::CatalogGetRecordCount(Var stack[])	{	TRACE("==CatalogGetRecordCount==");        Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogGetRecordCount));    if (ISINT(result)) v.intValue = RINT(result);	return v;	}// STUBBED OUT for nowVar VM::CatalogDeleteRecord(Var stack[])	{	TRACE("==CatalogDeleteRecord==");        Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogDeleteRecord));    if (!ISNIL(result)) v.intValue = 1;	return v;	}// STUBBED OUT for nowVar VM::CatalogResizeRecord(Var stack[])	{	TRACE("==CatalogResizeRecord==");        Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogResizeRecord),MAKEINT(stack[1].intValue));    if (!ISNIL(result)) v.intValue = 1;	return v;	}// STUBBED OUT for nowVar VM::CatalogAddRecord(Var stack[])	{        TRACE("==CatalogAddRecord==");	Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogAddRecord),MAKEINT(stack[1].intValue));    if (ISINT(result)) v.intValue = RINT(result);	return v;	}// STUBBED OUT for nowVar VM::CatalogSetRecordPos(Var stack[])	{        TRACE("==CatalogSetRecordPos==");	Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogSetRecordPos),MAKEINT(stack[1].intValue));    if (!ISNIL(result)) v.intValue = 1;	return v;	}// STUBBED OUT for nowVar VM::CatalogRead(Var stack[])	{        TRACE("==CatalogRead==");	Var v;	v.intValue = -1;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    WObject bytearray = stack[1].obj;    int start = stack[2].intValue;    int count = stack[3].intValue;    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogRead),MAKEINT(count));    if (IsFrame(result))        {        RefVar bytes = GetFrameSlot(result,SYM(data));        RefVar _offset = GetFrameSlot(result,SYM(offset));        RefVar _len = GetFrameSlot(result,SYM(length));        if (ISINT(_len) && ISINT(_offset) && IsBinary(bytes))            {            int offset = RINT(_offset);            int len = RINT(_len);            if (len == -1)  // uh oh, can't read, we have an error                { }            else if (len > count) PRINTSTR("len > count!!!");            else if (offset < 0) PRINTSTR("offset < 0");            else if (len + offset > Length(bytes)) PRINTSTR("length of data in byte_frame is < length + offset");            else if (arrayRangeCheck(bytearray, start, count) == 0)                PRINTSTR("len and start for byte array is invalid");            else                {                WITH_LOCKED_BINARY(bytes,bytesptr)                signed char* bytestart = (signed char *)WOBJ_arrayStart(bytearray);                xmemmove(bytestart+start,((signed char*)bytesptr)+offset,len);                END_WITH_LOCKED_BINARY(bytes)                v.intValue = len;                }            }        else { PRINTSTR("length or offset or data is missing from byte_frame"); }        }	return v;	}// STUBBED OUT for nowVar VM::CatalogWrite(Var stack[])	{        TRACE("==CatalogWrite==");	Var v;	v.intValue = -1;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    WObject bytearray = stack[1].obj;    int start = stack[2].intValue;    int count = stack[3].intValue;    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogGetByteFrameForWrite),MAKEINT(count));    if (IsFrame(result))        {        RefVar bytes = GetFrameSlot(result,SYM(data));        RefVar _offset = GetFrameSlot(result,SYM(offset));        RefVar _len = GetFrameSlot(result,SYM(length));        if (ISINT(_len) && ISINT(_offset) && IsBinary(bytes))            {            int offset = RINT(_offset);            int len = RINT(_len);            if (len < count) PRINTSTR("len < count!!!");            else if (offset < 0) PRINTSTR("offset < 0");            else if (len + offset > Length(bytes))                PRINTSTR("length of data in byte_frame is < length + offset");            else if (arrayRangeCheck(bytearray, start, count) == 0)                PRINTSTR("len and start for byte array is invalid");            else                {                WITH_LOCKED_BINARY(bytes,bytesptr)                signed char* bytestart = (signed char *)WOBJ_arrayStart(bytearray);                xmemmove(((signed char*)bytesptr)+offset,bytestart+start,count);                END_WITH_LOCKED_BINARY(bytes)                // set the length of data written                SetFrameSlot(result,SYM(length),MAKEINT(count));                RefVar result2 = NSSendIfDefined(getRefStruct(frame),SYM(CatalogWrite),result);                if (ISINT(result2)) v.intValue = RINT(result2);                }            }        else { PRINTSTR("length or offset or data is missing from byte_frame"); }        }	return v;	}// STUBBED OUT for nowVar VM::CatalogSkipBytes(Var stack[])	{        TRACE("==CatalogSkipBytes==");	Var v;	v.obj = 0;    RefStruct** frame = WOBJ_CatalogFrame(stack[0].obj);    RefVar result = NSSendIfDefined(getRefStruct(frame),SYM(CatalogSkipBytes),MAKEINT(stack[1].intValue));    if (ISINT(result)) v.intValue = RINT(result);	return v;	}//// Time//// var[0] = Class// var[1] = int year// var[2] = int month// var[3] = int day// var[4] = int hour// var[5] = int minute// var[6] = int second// var[7] = int millis#define WOBJ_TimeYear(o) (objectPtr(o))[1].intValue#define WOBJ_TimeMonth(o) (objectPtr(o))[2].intValue#define WOBJ_TimeDay(o) (objectPtr(o))[3].intValue#define WOBJ_TimeHour(o) (objectPtr(o))[4].intValue#define WOBJ_TimeMinute(o) (objectPtr(o))[5].intValue#define WOBJ_TimeSecond(o) (objectPtr(o))[6].intValue#define WOBJ_TimeMillis(o) (objectPtr(o))[7].intValueVar VM::TimeCreate(Var stack[])	{	TRACE("==TimeCreate==");	Var v;	WObject time;		time = stack[0].obj;	RefVar date = NSCallGlobalFn(SYM(DateFromSeconds),NSCallGlobalFn(SYM(TimeInSeconds)));	WOBJ_TimeYear(time) = RINT(GetFramePath(date,SYM(year)));	WOBJ_TimeMonth(time) = RINT(GetFramePath(date,SYM(month)));	WOBJ_TimeDay(time) = RINT(GetFramePath(date,SYM(date)));	WOBJ_TimeHour(time) = RINT(GetFramePath(date,SYM(hour)));	WOBJ_TimeMinute(time) = RINT(GetFramePath(date,SYM(minute)));	WOBJ_TimeSecond(time) = RINT(GetFramePath(date,SYM(second)));	WOBJ_TimeMillis(time) = ((RINT(NSCallGlobalFn(SYM(Ticks))) % 60) * 1000) / 60;	v.obj = 0;	return v;	}// The Serial Ports code was here.#include "NewtSerial.cp"//// Vm//// This was originally:// Var VM::VmIsColor()// .. which appears to be a bug that was never picked up by// the C compilers they're using for WinCE and PalmOS.Var VM::VmIsColor(Var stack[])	{	TRACE("==VmIsColor==");	Var v;	v.intValue = (DRAW_GRAY);	return v;	}Var VM::VmGetTimeStamp(Var stack[])	{	TRACE("==VmGetTimeStamp==");	Var v;	v.intValue = GetTimeStamp();	return v;	}Var VM::VmExec(Var stack[])	{	TRACE("==VmExec==");	Var v;/* The Newton does not have synchronous execution, only asynchronous.   This function is very simple: it looks up an app named "foo:bar"   and launches it as if the user had double-clicked on its icon.    The VM stays intact, it doesn't die or anything, and wait is ignored. */// See p. 16-90 of the NTK Reference        RefVar soup = NSCall(SYM(kGetPartCursorFunc),		WabaStringToNewtonString(stack[0].obj),NILREF,SYM(_all));// See p. 9-61 of the NTK Reference        RefVar entry = NSSend(soup,SYM(Entry));	if (ISNIL(entry)) v.intValue=-1;  // oops!  Nothing there!	else	    {// See p. 16-92 of the NTK Reference	    NSCall(SYM(kLaunchPartEntryFunc),entry);	    v.intValue = 0;	    }	return v;	}Var VM::VmSleep(Var stack[])	{	TRACE("==VmSleep==");	Var v;    	NSCallGlobalFn(SYM(Sleep), MAKEINT((stack[0].intValue*60)/1000));	v.obj = 0;	return v;	}Var VM::VmGetPlatform(Var stack[])	{	TRACE("==VmGetPlatform==");	Var v;	v.obj = createString("NewtonOS");	return v;	}// STUBBED OUT: unlikely we will be able to implement this on the NewtonVar VM::VmSetDeviceAutoOff(Var stack[])	{	TRACE("==VmSetDeviceAutoOff==");	Var v;	v.obj = 0;  // we don't want to provide auto-off timing	return v;	}Var VM::VmGetUserName(Var stack[])	{	TRACE("==VmGetUserName==");        Var v;        v.obj = NewtonStringToWabaString(NSCallGlobalFn(SYM(GetUserConfig),SYM(name)));	return v;	}/** New Methods added for hash code, reflection, etc. */Var VM::ObjectHashCode(Var stack[])    {    TRACE("==ObjectHashCode==");    Var v;    v.intValue = stack[0].obj;  // obj is a WObject, which is an int    return v;    }Var VM::VmGetClassName(Var stack[])    {    TRACE("==VmGetClassName==");    Var v;    WClass* wclass = WOBJ_class(stack[0].obj);    if (wclass==NULL) // it's an array        v.obj = createStringFromUtf(createUtfString(""));/*        {        switch (WOBJ_arrayType(stack[0].obj))		{		case 1:  // object		case 2:  // array                    v.obj = createStringFromUtf(createUtfString("Object[]")); break;                case 3:  // huh?  -- I added this to make the switch complete                    v.obj = createStringFromUtf(createUtfString("???")); break;		case 4: // boolean                    v.obj = createStringFromUtf(createUtfString("boolean[]")); break;		case 5:  // char                    v.obj = createStringFromUtf(createUtfString("char[]")); break;		case 6:  // float                    v.obj = createStringFromUtf(createUtfString("double[]")); break;		case 7:  // double                    v.obj = createStringFromUtf(createUtfString("double[]")); break;		case 8: // byte                    v.obj = createStringFromUtf(createUtfString("byte[]")); break;		case 9:  // short                    v.obj = createStringFromUtf(createUtfString("short[]")); break;		case 10: // int                    v.obj = createStringFromUtf(createUtfString("int[]")); break;		case 11: // long                    v.obj = createStringFromUtf(createUtfString("long[]")); break;                default:                    v.obj = createStringFromUtf(createUtfString("???")); break;		}        }    */    else v.obj = createStringFromUtf(getUtfString(wclass,wclass->classNameIndex));    return v;    }Var VM::VmMakeInstance(Var stack[])    {    TRACE("==VmMakeInstance==");    Var v;    Var params[1];    WClassMethod* method;    WClass* wclass;    v.obj = 0;    if (stack[0].obj == 0)  // it's null, so return null        return v;    UtfString s = stringToUtf(stack[0].obj,STU_NULL_TERMINATE | STU_USE_STATIC);    if (s.len == 0)  	// possibly a bad string        return v;    wclass = getClassMaybe(s,0);    if (wclass==NULL)  // can't find the wclass, so return null        return v;    v.obj = createObject(wclass);  // new    method = getMethod(wclass,createUtfString("<init>"),                        createUtfString("()V"),NULL);  // find constructor    params[0] = v;    if (method!=NULL)        executeMethod(wclass, method,params,1);  // call constructor    return v;    }    