// This software is subject to the terms of the IBM Jikes Compiler// License Agreement available at the following URL:// http://www.ibm.com/research/jikes.// Copyright (C) 1996, 1998, International Business Machines Corporation// and others.  All Rights Reserved.// You must accept the terms of that agreement to use this software./*This code is a modification of code found in the file "system.cpp"Of the Jikes 1.10 distribution.  Jikes is an open source Javacompiler written in C++, and had nearly perfect functions for ourpurposes.  I made a few modifications and added some additionallength functions so we can spend more time determining exactly thestring length and so don't waste unneccessary space.  -- Sean*/#define U_NULL (0)#define STOP_AT_NULL_TERMINATOR (-1)#define BAD_UTF8 (-1)// ...might garbage collect.  See the warning in nmnewt_c.cWObject VM::NewtonStringToWabaString(RefArg string_or_rich_string)	{	// Newton Strings are always null-terminated, so we don't have to	// worry about that.    int len;	char* utf8;        RefVar unistring = NSCallGlobalFn(SYM(StripInk),string_or_rich_string,NILREF);	WITH_LOCKED_BINARY(unistring,unicode)        len = LengthOfUtf8ForUnicode((unsigned short*)unicode,STOP_AT_NULL_TERMINATOR);		utf8 = new char[len];		ConvertUnicodeToUtf8((unsigned short*)unicode,utf8,STOP_AT_NULL_TERMINATOR);	END_WITH_LOCKED_BINARY(unistring)		UtfString s;	s.len = len;	s.str = utf8;	WObject obj = createStringFromUtf(s);	delete utf8;	return obj;	}    Ref VM::UtfStringToNewtonString(UtfString s)	{	int numunicode = NumUnicodeCharsInUtf8(s.str,s.len);	unsigned short* unichar = new unsigned short[numunicode + 1];	ConvertUtf8ToUnicode(unichar,s.str,s.len);	// tack on a '\0' at the end -- it's probably not null terminated!	unichar[numunicode] = 0;	Ref unistring = MakeString(unichar);	delete unichar;        return unistring;	}// ...might garbage collect.  See the warning in nmnewt_c.cRef VM::WabaStringToNewtonString(WObject utf8_string)	{	UtfString s = stringToUtf(utf8_string,STU_NULL_TERMINATE | STU_USE_STATIC);	return UtfStringToNewtonString(s);	}/*Returns the length of a UTF8 string for a given unicode string, where0x0 is encoded in 2 bytes per Java tradition.  len indicates thelength of the unicode block to encode (in this case, null terminatorsdo not signify the "end" of the string -- it's just a block off characters).Or if _length_ is <= STOP_AT_NULL_TERMINATOR, then the unicode string is readuntil and including the first null terminator.  Returns the length,in bytes, of the converted Utf8 string, including any possible endingnull terminator.*/int VM::LengthOfUtf8ForUnicode(const unsigned short *unicode, int len){    int length = 0;    int base = 0;    for (; len<=STOP_AT_NULL_TERMINATOR ? *unicode : base < len ; unicode++, base++)    {        int ch = *unicode;        if (ch == 0) length += 2;        else if (ch <= 0x007F) length++;        else if (ch <= 0x07FF) length+=2;        else length+=3;    }    if (len <= STOP_AT_NULL_TERMINATOR) // null terminated    	length++;    return length;}/*Converts a unicode string into a UTF8 string, where0x0 is encoded in 2 bytes per Java tradition.  len indicates thelength of the unicode block to encode (in this case, null terminatorsdo not signify the "end" of the string -- it's just a block off characters).Or if _length_ is <= STOP_AT_NULL_TERMINATOR, then the unicode string is readuntil and including the first null terminator.  Returns the length,in bytes, of the converted Utf8 string, including any possible endingnull terminator.The char string utf8 is presumed to have been allocated and to be large enoughto accommodate the conversion.  You can get the necessary size for the bufferin utf8 by calling LengthOfUtf8ForUnicode(unicode,len);*/int VM::ConvertUnicodeToUtf8(const unsigned short *unicode, char *utf8, int len){    int length = 0;    int base = 0;    for (; len<=STOP_AT_NULL_TERMINATOR ? *unicode : base < len ; unicode++, base++)    {        int ch = *unicode;        if (ch == 0)        {             utf8[length++] = (char) 0xC0;             utf8[length++] = (char) 0x80;        }        else if (ch <= 0x007F)             utf8[length++] = (char) ch;        else if (ch <= 0x07FF)        {             utf8[length++] = (char) ((char) 0xC0 | (char) ((ch >> 6) & 0x001F)); // bits 6-10             utf8[length++] = (char) ((char) 0x80 | (char) (ch & 0x003F));        // bits 0-5        }        else        {             utf8[length++] = (char) ((char) 0xE0 | (char) ((ch >> 12) & 0x000F));             utf8[length++] = (char) ((char) 0x80 | (char) ((ch >> 6) & 0x003F));             utf8[length++] = (char) ((char) 0x80 | (char) (ch & 0x3F));        }    }    if (len <= STOP_AT_NULL_TERMINATOR) // null terminated	utf8[length++] = U_NULL;    return length;}/* Convert the Utf8 string of length len (bytes) pointed to by utf8 into its unicode representation pointed to by unicode. The unsigned short string unicode is presumed to have been allocated and to be large enough to accomodate the conversion.  You can get this size with NumUnicodeCharsInUtf8(*utf8,len); The resulting string *may* not be null-terminated (if the utf8 string wasn't null-terminated) so you might have to tack on a null-termination at the end if that's an issue for you.  len is the length of the utf8 string in bytes, including any null terminator if it's there. Returns BAD_UTF8 if there were bad UTF characters in the string.*/int VM::ConvertUtf8ToUnicode(unsigned short *unicode, const char *utf8, int len){    unsigned short *ptr = unicode;    for (int i = 0; i < len; i++, ptr++)    {        unsigned char ch = utf8[i];        if ((ch & 0x80) == 0)            *ptr = ch;        else if ((ch & 0xE0) == 0xC0)        {            *ptr = ch & 0x1F;            *ptr <<= 6;            i++;            ch = utf8[i] & 0x3F;            *ptr += ch;        }        else if ((ch & 0xF0) == 0xE0)        {            *ptr = ch & 0x0F;            *ptr <<= 6;            i++;            ch = utf8[i] & 0x3F;            *ptr += ch;            *ptr <<= 6;            i++;            ch = utf8[i] & 0x3F;            *ptr += ch;        }        else	    return BAD_UTF8;    }    // *ptr = U_NULL;  		// we don't do null termination any more    return (ptr - unicode);}/* Returns the number of unicode characters in the block of bytes of utf8  up to length len, or BAD_UTF8 if the UTF8 is bad.*/int VM::NumUnicodeCharsInUtf8(const char *utf8, int len){    int ptr=0;    for (int i = 0; i < len; i++, ptr++)    {        unsigned char ch = utf8[i];        if ((ch & 0x80) == 0)	    { }        else if ((ch & 0xE0) == 0xC0)        {            i++;        }        else if ((ch & 0xF0) == 0xE0)        {            i+=2;        }        else	    return BAD_UTF8;    }    return ptr;}