/*Copyright (C) 1998, 1999, 2000 WabasoftThis program is free software; you can redistribute it and/or modify it underthe terms of the GNU General Public License as published by the Free SoftwareFoundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANYWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along withthis program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave,Cambridge, MA 02139, USA. *//*Welcome to the WabaVM source. This is the platform indepdenent code for theinterpreter, class parser and garbage collector. I like the code myself (ofcourse I wrote it, so that's not saying much) and hopefully it doesn't seemtoo complicated. Actually, I'm hoping it reads rather easily given what itdoes.If you're looking through the source and wondering about the QUICKBIND stuff,you should know that you can turn it off completely by removing all the codewith an #ifdef QUICKBIND around it. It's an optimization that speeds thingsup quite a bit. So, if you're trying to figure out the code, ignore theQUICKBIND stuff at first and then look at it later on.The SMALLMEM define determines whether the VM uses a small or large memorymodel (16 bit or 32 bit offsets). The default is SMALLMEM which means that ifprogams use memory beyond a certain size, they jump to being slow since theycan't QUICKBIND any more. It still works since the QUICKBIND is adaptive, ifthe offset fits, it uses it, if not, it doesn't use QUICKBIND.This file should pretty much compile on any platform. To port the VM, youcreate the 3 native method (nm) files. See the nmport_a.c if you areinterested in starting a port or to see how easy/difficult it would be.Have a blast!Rick Wild*/// ============ Includes ===========#ifdef NEWTOS	#ifndef __NEWTONGESTALT_H		#include "NewtonGestalt.h"	#endif#endif// allows you to call method pointers using the syntax:// callMemberFunction(pointername,object)(arg,arg,arg,arg...)// So if you have a member function in VM called foo(int x, float y),// and you have a pointer to foo stored in the variable bar, and// your VM instance is *dereferenced* in the variable vm, and your// arguments are q (an int) and w (a float), then you can call foo// as callMemberFunction(vm,foo)(q,w);// Thanks to the C++ FAQ item 30.5, at// http://www.cerfnet.com/~mpcline/C++-FAQs-Lite/pointers-to-members.html// these were defined to allow the VM to call native and destroy funcs// from the VM class rather than as global C functions, which the // Newton does not permit.  -- Sean #define callMemberFunction(object,ptrToMember)   ((object.*(ptrToMember)))#define callThis(funcname)   callMemberFunction((*(this)),funcname)#define initRefStruct(rs) (*rs=NULL) /* I believe this is unnecessary, NewtOS appears to init to 0x0 */#define getRefStruct(rs) (*(*rs==NULL ? *rs = new RefStruct() : *rs))#define setRefStruct(rs,val) (getRefStruct(rs) = val)#define deleteRefStruct(rs) if (*rs!=NULL) { setRefStruct(rs,NILREF); delete *rs; *rs=NULL; }// The Newton can do one of two things: either copy all the class data// into C++ heap areas (and use up valuable C++ heap space), or keep// the pointers out into arbitrary locations on the Flash RAM and hope// that the class data pointers remain fresh.  This define is the toggle// for that.  The first option is much safer.  The second option allows// you to have far larger programs in terms of number of classes.//#define USE_CPLUSPLUS_HEAP// The Newton uses a 32-bit chip, so we have a large memory model//#define SMALLMEM 1// Dunno if Quickbind presently works, we assume it does #define QUICKBIND 1// undefine sanity checks for final releases#define SANITYCHECK 1// do our array bugfix//#define ARRAY_BUGFIX/*"True words are not beautiful, beautiful words are not true. The good are not argumentative, the argumentative are not good. Knowers do not generalize, generalists do not know. Sages do not accumulate anything but give everything to others, having more the more they give. The Way of heaven helps and does not harm. The Way for humans is to act without contention." - Lao-tzu, Tao Te Ching circa 500 B.C.*///// TYPES AND METHODS//// Access flags#define ACCESS_PUBLIC       0x0001#define ACCESS_PRIVATE      0x0002#define ACCESS_PROTECTED    0x0004#define ACCESS_STATIC       0x0008#define ACCESS_FINAL        0x0010#define ACCESS_SYNCHRONIZED 0x0020#define ACCESS_VOLATILE     0x0040#define ACCESS_TRANSIENT    0x0080#define ACCESS_NATIVE       0x0100#define ACCESS_INTERFACE    0x0200#define ACCESS_ABSTRACT     0x0400// Constant Pool tags#define CONSTANT_Utf8               1#define CONSTANT_Integer            3#define CONSTANT_Float              4#define CONSTANT_Long               5#define CONSTANT_Double             6#define CONSTANT_Class              7#define CONSTANT_String             8#define CONSTANT_Fieldref           9#define CONSTANT_Methodref          10#define CONSTANT_InterfaceMethodref 11#define CONSTANT_NameAndType        12// Standard Opcodes#define OP_nop             0#define OP_aconst_null     1#define OP_iconst_m1       2#define OP_iconst_0        3#define OP_iconst_1        4#define OP_iconst_2        5#define OP_iconst_3        6#define OP_iconst_4        7#define OP_iconst_5        8#define OP_lconst_0        9#define OP_lconst_1        10#define OP_fconst_0        11#define OP_fconst_1        12#define OP_fconst_2        13#define OP_dconst_0        14#define OP_dconst_1        15#define OP_bipush          16#define OP_sipush          17#define OP_ldc             18#define OP_ldc_w           19#define OP_ldc2_w          20#define OP_iload           21#define OP_lload           22#define OP_fload           23#define OP_dload           24#define OP_aload           25#define OP_iload_0         26#define OP_iload_1         27#define OP_iload_2         28#define OP_iload_3         29#define OP_lload_0         30#define OP_lload_1         31#define OP_lload_2         32#define OP_lload_3         33#define OP_fload_0         34#define OP_fload_1         35#define OP_fload_2         36#define OP_fload_3         37#define OP_dload_0         38#define OP_dload_1         39#define OP_dload_2         40#define OP_dload_3         41#define OP_aload_0         42#define OP_aload_1         43#define OP_aload_2         44#define OP_aload_3         45#define OP_iaload          46#define OP_laload          47#define OP_faload          48#define OP_daload          49#define OP_aaload          50#define OP_baload          51#define OP_caload          52#define OP_saload          53#define OP_istore          54#define OP_lstore          55#define OP_fstore          56#define OP_dstore          57#define OP_astore          58#define OP_istore_0        59#define OP_istore_1        60#define OP_istore_2        61#define OP_istore_3        62#define OP_lstore_0        63#define OP_lstore_1        64#define OP_lstore_2        65#define OP_lstore_3        66#define OP_fstore_0        67#define OP_fstore_1        68#define OP_fstore_2        69#define OP_fstore_3        70#define OP_dstore_0        71#define OP_dstore_1        72#define OP_dstore_2        73#define OP_dstore_3        74#define OP_astore_0        75#define OP_astore_1        76#define OP_astore_2        77#define OP_astore_3        78#define OP_iastore         79#define OP_lastore         80#define OP_fastore         81#define OP_dastore         82#define OP_aastore         83#define OP_bastore         84#define OP_castore         85#define OP_sastore         86#define OP_pop             87#define OP_pop2            88#define OP_dup             89#define OP_dup_x1          90#define OP_dup_x2          91#define OP_dup2            92#define OP_dup2_x1         93#define OP_dup2_x2         94#define OP_swap            95#define OP_iadd            96#define OP_ladd            97#define OP_fadd            98#define OP_dadd            99#define OP_isub            100#define OP_lsub            101#define OP_fsub            102#define OP_dsub            103#define OP_imul            104#define OP_lmul            105#define OP_fmul            106#define OP_dmul            107#define OP_idiv            108#define OP_ldiv            109#define OP_fdiv            110#define OP_ddiv            111#define OP_irem            112#define OP_lrem            113#define OP_frem            114#define OP_drem            115#define OP_ineg            116#define OP_lneg            117#define OP_fneg            118#define OP_dneg            119#define OP_ishl            120#define OP_lshl            121#define OP_ishr            122#define OP_lshr            123#define OP_iushr           124#define OP_lushr           125#define OP_iand            126#define OP_land            127#define OP_ior             128#define OP_lor             129#define OP_ixor            130#define OP_lxor            131#define OP_iinc            132#define OP_i2l             133#define OP_i2f             134#define OP_i2d             135#define OP_l2i             136#define OP_l2f             137#define OP_l2d             138#define OP_f2i             139#define OP_f2l             140#define OP_f2d             141#define OP_d2i             142#define OP_d2l             143#define OP_d2f             144#define OP_i2b             145#define OP_i2c             146#define OP_i2s             147#define OP_lcmp            148#define OP_fcmpl           149#define OP_fcmpg           150#define OP_dcmpl           151#define OP_dcmpg           152#define OP_ifeq            153#define OP_ifne            154#define OP_iflt            155#define OP_ifge            156#define OP_ifgt            157#define OP_ifle            158#define OP_if_icmpeq       159#define OP_if_icmpne       160#define OP_if_icmplt       161#define OP_if_icmpge       162#define OP_if_icmpgt       163#define OP_if_icmple       164#define OP_if_acmpeq       165#define OP_if_acmpne       166#define OP_goto            167#define OP_jsr             168#define OP_ret             169#define OP_tableswitch     170#define OP_lookupswitch    171#define OP_ireturn         172#define OP_lreturn         173#define OP_freturn         174#define OP_dreturn         175#define OP_areturn         176#define OP_return          177#define OP_getstatic       178#define OP_putstatic       179#define OP_getfield        180#define OP_putfield        181#define OP_invokevirtual   182#define OP_invokespecial   183#define OP_invokestatic    184#define OP_invokeinterface 185#define OP_new             187#define OP_newarray        188#define OP_anewarray       189#define OP_arraylength     190#define OP_athrow          191#define OP_checkcast       192#define OP_instanceof      193#define OP_monitorenter    194#define OP_monitorexit     195#define OP_wide            196#define OP_multianewarray  197#define OP_ifnull          198#define OP_ifnonnull       199#define OP_goto_w          200#define OP_jsr_w           201#define OP_breakpoint      202//// Error Handling//const char* const errorMessages[] =    {    "sanity",    "incompatible device",    "can't access waba classes",    "can't access app classes",    "can't allocate memory",    "out of class memory",    "out of object memory",    "native stack overflow",    "native stack underflow",    "java stack overflow",    "bad class",    "bad opcode",    "can't find class",    "can't find method",    "can't find field",    "null object access",    "null array access",    "index out of range",    "divide by zero",    "bad class cast",    "class too large"#ifdef NEWTOS    ,    "newton waba error",    "bad UTF string"#endif NEWTOS    };// fatal errors#define ERR_SanityCheckFailed        0#define ERR_IncompatibleDevice       1 #define ERR_CantAccessCoreClasses    2#define ERR_CantAccessAppClasses     3#define ERR_CantAllocateMemory       4#define ERR_OutOfClassMem            5#define ERR_OutOfObjectMem           6#define ERR_NativeStackOverflow      7#define ERR_NativeStackUnderflow     8#define ERR_StackOverflow            9// program errors#define ERR_BadClass                 10#define ERR_BadOpcode                11#define ERR_CantFindClass            12#define ERR_CantFindMethod           13#define ERR_CantFindField            14#define ERR_NullObjectAccess         15#define ERR_NullArrayAccess          16#define ERR_IndexOutOfRange          17#define ERR_DivideByZero             18#define ERR_ClassCastException       19#define ERR_ClassTooLarge            20#ifdef NEWTOS#define ERR_NewtOSError		     21#define ERR_BadUtfString	     22#endif NEWTOS// flags for stringToUtf()#define STU_NULL_TERMINATE 1#define STU_USE_STATIC     2// NOTE: we made this function a #define and it showed no real performance// gain over having it a function on either PalmOS or Windows when// optimization was turned on.// -- Since it's now a member function, I'm making it a #define again -- Sean#define objectPtr(obj) (heap.hos[- (int32)(obj - FIRST_OBJ -1)].ptr)/*Var VM::*objectPtr(WObject obj)	{	return heap.hos[- (int32)(obj - FIRST_OBJ - 1)].ptr;	}*///DefineException(ALL_EXCEPTIONS, evt.ex);// -- defined by Sean to allow mutal reference between Var and WClassclass WSuper    {    };//// types and accessors//typedef uint32 WObject;typedef union    {    int32 intValue;    float32 floatValue;    WSuper *classRef;  // used to be void*    uchar *pc;    WSuper *refValue;    WObject obj;#ifdef NEWTOS    RefStruct* refStruct;#endif NEWTOS    } Var;// Now we have a REALLY BIG PROBLEM.  Ordinarily in order to declare// a class VM prior to "really" declaring it, in order to create member// function pointers NativeFunc and ObjDestroyFunc, you'd do the following:#ifdef NEWTOS#elseclass VM;typedef Var (VM::*NativeFunc)(Var stack[]);typedef void (VM::*ObjDestroyFunc)(WObject obj);#endif NEWTOS// ...this works just peachy keen for g++ and other compilers.  But// the Newton C++ compiler dies with a horrible error // ("Failed Internal Consistency Check").  Which is yet more proof that// it was a Good Thing that NeXT took over Apple, as Apple makes the worst// development environments in the known universe.  The ARMCPlus compiler// that comes with the NTK isn't available in the latest version of the// Macintosh Programmer's Workshop, so we can't update it to deal with this// bug.  So what do we do?// We can't declare these two typedefs until VM is declared, and we can't// declare VM until the typedefs are declared!// my solution, which I hope works, is to make a class called FuncHack// and two subclasses of it which hold these native functions.  Then// our various access methods will have to toss around FuncHack*'s // and dereference them to grab the native functions.  // [PG]ÊSean, can't let you say "it was a Good Thing that NeXT took over Apple".// ARMCpp has been written by ARM, Ltd. Apple only ported it.// It doesn't support everything it should to comply to today's C++ standards.// But it optimizes code much more than gcc for arm.typedef int NativeFunc_i;typedef int ObjDestroyFunc_i;//// more types and accessors//// modified by Sean to allow mutal reference between Var and WClass, what// a hack...//#define WOBJ_class(o) (objectPtr(o))[0].classRef#define WOBJ_class(o) ((WClass*)((objectPtr(o))[0].classRef))// added by Sean here so we can still set in casting down#define WOBJ_setclass(o) (objectPtr(o))[0].classRef#define WOBJ_var(o, idx) (objectPtr(o))[idx + 1]#ifdef NEWTOS// grabs the RefStruct out of a newton.Ref object.  See newtonAPI.cp#define WOBJ_Ref(o) &((objectPtr(o))[1].refStruct)// grabs Callback data out of a newton.Callback object.  See newtonAPI.cp#define WOBJ_CallbackID(o) (objectPtr(o))[1].intValue#define WOBJ_CallbackFunc(o) &((objectPtr(o))[2].refStruct)#define WOBJ_CallbackArgs(o) (objectPtr(o))[3].obj#endif NEWTOS// NOTE: These get various values in objects at defined offsets.// If the variables in the base classes change, these offsets will// need to be recomputed. For example, the first (StringCharArray)// get the character array var offset in a String object.#define WOBJ_StringCharArrayObj(o) (objectPtr(o))[1].obj#define WOBJ_StringBufferStrings(o) (objectPtr(o))[1].obj#define WOBJ_StringBufferCount(o) (objectPtr(o))[2].intValue#define WOBJ_arrayType(o) (objectPtr(o))[1].intValue#define WOBJ_arrayLen(o) (objectPtr(o))[2].intValue#define WOBJ_arrayStart(o) (&(objectPtr(o)[3]))// for faster access#define WOBJ_arrayTypeP(objPtr) (objPtr)[1].intValue#define WOBJ_arrayLenP(objPtr) (objPtr)[2].intValue#define WOBJ_arrayStartP(objPtr) (&(objPtr[3]))typedef struct UtfStringStruct    {    const char *str;    uint32 len;    } UtfString;typedef union    {    // FieldVar is either a reference to a static class variable (staticVar)    // or an offset of a local variable within an object (varOffset)    Var staticVar;    uint32 varOffset; // computed var offset in object    } FieldVar;typedef struct WClassFieldStruct    {    uchar *header;    FieldVar var;    } WClassField;#define FIELD_accessFlags(f) getUInt16(f->header)#define FIELD_nameIndex(f) getUInt16(&f->header[2])#define FIELD_descIndex(f) getUInt16(&f->header[4])#define FIELD_isStatic(f) ((FIELD_accessFlags(f) & ACCESS_STATIC) > 0)typedef union    {    // Code is either pointer to bytecode or pointer to native function    // NOTE: If accessFlags(method) & ACCESS_NATIVE then nativeFunc    // is set, otherwise codeAttr is set. Native methods don't have    // maxStack, maxLocals so it is OK to merge the codeAttr w/nativeFunc.    uchar *codeAttr;#ifdef NEWTOS    NativeFunc_i nativeFunc;#else    NativeFunc nativeFunc;#endif NEWTOS    } Code;typedef class WClassMethodStruct:public WSuper    {    public:    uchar *header;    Code code;    uint16 numParams:14;    uint16 returnsValue:1;    uint16 isInit:1;    } WClassMethod;#define METH_accessFlags(m) getUInt16(m->header)#define METH_nameIndex(m) getUInt16(&m->header[2])#define METH_descIndex(m) getUInt16(&m->header[4])#define METH_maxStack(m) getUInt16(&m->code.codeAttr[6])#define METH_maxLocals(m) getUInt16(&m->code.codeAttr[8])#define METH_codeCount(m) getUInt32(&m->code.codeAttr[10])#define METH_code(m) &m->code.codeAttr[14]#define CONS_offset(wc, idx) wc->constantOffsets[idx - 1]#define CONS_ptr(wc, idx) (wc->byteRep + CONS_offset(wc, idx))#define CONS_tag(wc, idx) CONS_ptr(wc, idx)[0]#define CONS_utfLen(wc, idx) getUInt16(&CONS_ptr(wc, idx)[1])#define CONS_utfStr(wc, idx) &CONS_ptr(wc, idx)[3]#define CONS_integer(wc, idx) getInt32(&CONS_ptr(wc, idx)[1])#define CONS_float(wc, idx) getFloat32(&CONS_ptr(wc, idx)[1])#define CONS_stringIndex(wc, idx) getUInt16(&CONS_ptr(wc, idx)[1])#define CONS_classIndex(wc, idx) getUInt16(&CONS_ptr(wc, idx)[1])#define CONS_nameAndTypeIndex(wc, idx) getUInt16(&CONS_ptr(wc, idx)[3])#define CONS_nameIndex(wc, idx) getUInt16(&CONS_ptr(wc, idx)[1])#define CONS_typeIndex(wc, idx) getUInt16(&CONS_ptr(wc, idx)[3])// The VM keeps an array of constant offsets for each constant in a class// in the runtime class structure (see WClassStruct). For each constant,// the offset is an offset from the start of the bytes defining the class.// Depdending on whether SMALLMEM is defined, the offset is either a 16 or// 32 bit quantity. So, if SMALLMEM is defined, the maximum offset is 2^16.// However, we also keep a bit in the constant to determine whether the// constant is an offset that is "bound" or not. So, the maximum value of// an offset if SMALLMEM is defined (the small memory model) is 32767.//// This means under the small memory model, the biggest class constant// pool we can have is 32K. Under the large memory model (SMALLMEM not// defined) the maximum class constant pool size that we could have is// 2^31 bytes. Using SMALLMEM can save quite a bit of memory since// constant pools tend to be large.//// When a constant offset is "bound", instead of the offset being// an offset into the constant pool, it is (with the exception of methods)// a pointer offset from the start of the class heap to the actual data// the constant refers to.//// For example, when a field constant is bound, it contains an offset// from the start of the class heap to the actual WClassField * structure// for the field. For class offsets, it is an offset to the WClass *// structure. For method offsets, the offset is a virtual method number// and class index. Only class, field and methods can be bound.//// A bound offset will only be bound if the offset of the actual structure// in the class heap is within the range that can fit in the offset. For// example, in a small memory model, if a WClassField * structure exists// beyond 32K from the start of the class heap, its offset can't be bound.// If that happens, the offset simply won't be bound and will retain// an offset into the constant pool (known now as an "adaptive bind").//// Binding of constants (adaptive quickbind) will only be performed if// QUICKBIND is defined. When an offset is bound, it's CONS_boundBit// will be set to 1.#ifdef SMALLMEMtypedef uint16 ConsOffset;#define MAX_consOffset 0x7FFF#define CONS_boundBit 0x8000#define CONS_boundOffsetMask 0x7FFF// 1 bit for bound bit, 7 bits for method, 8 bits for class index#define MAX_boundMethodNum 127#define MAX_boundClassIndex 255#define CONS_boundMethodShift 8#define CONS_boundClassMask 0xFF;#elsetypedef uint32 ConsOffset;#define MAX_consOffset 0x7FFFFFFF#define CONS_boundBit 0x80000000#define CONS_boundOffsetMask 0x7FFFFFFF// 1 bit for bound bit, 15 bits for method, 16 bits for class index#define MAX_boundMethodNum 32767#define MAX_boundClassIndex 65535#define CONS_boundMethodShift 16#define CONS_boundClassMask 0xFFFF;#endif#ifdef QUICKBINDtypedef struct    {    uint16 classNum:6;    uint16 methodNum:10;    } VMapValue;#define MAX_superClassNum 63#define MAX_methodNum 1023typedef struct    {    VMapValue *mapValues; // maps virtual method number to class, virtual method index    uint16 mapSize; // size of map = number of inherited methods    uint16 numVirtualMethods; // number of new virtual methods in the class    uint16 numOverriddenMethods; // number of overridden methods in the class    } VirtualMethodMap;// search types for getMethodMapNum()#define SEARCH_ALL 0#define SEARCH_INHERITED 1#define SEARCH_THISCLASS 2// keep this a prime number for best distribution#define OVERRIDE_HASH_SIZE 127#endif// NOTE: In the following structure, a constant offset can either be// bound (by having boundBit set) in which case it is an offset into// the classHeap directly or unbound in which case it is an offset into// the byteRep of the classtypedef class WClassStruct:public WSuper    {    public:    struct WClassStruct **superClasses; // array of this classes superclasses    uint16 numSuperClasses;    uint16 classNameIndex;    uchar *byteRep; // pointer to class representation in memory (bytes)    uchar *attrib2; // pointer to area after constant pool (accessFlags)    uint16 numConstants;    ConsOffset *constantOffsets;    uint16 numFields;    WClassField *fields;    uint16 numMethods;    WClassMethod *methods;#ifdef QUICKBIND    VirtualMethodMap vMethodMap;#endif    uint16 numVars; // computed number of object variables#ifdef NEWTOS    ObjDestroyFunc_i objDestroyFunc;#else    ObjDestroyFunc objDestroyFunc#endif NEWTOS    struct WClassStruct *nextClass; // next class in hash table linked list    } WClass;#define WCLASS_accessFlags(wc) getUInt16(wc->attrib2)#define WCLASS_thisClass(wc) getUInt16(&wc->attrib2[2])#define WCLASS_superClass(wc) getUInt16(&wc->attrib2[4])#define WCLASS_numInterfaces(wc) getUInt16(&wc->attrib2[6])#define WCLASS_interfaceIndex(wc, idx) getUInt16(&wc->attrib2[8 + (idx * 2)])#define WCLASS_objectSize(wc) ((wc->numVars + 1) * sizeof(Var))#define WCLASS_isInterface(wc) ((WCLASS_accessFlags(wc) & ACCESS_INTERFACE) > 0)typedef struct    {    uint16 errNum;    char className[40];    char methodName[40];    char arg1[40];    char arg2[40];    } ErrorStatus;#ifdef SANITYCHECKconst uchar floatTest[] = { 64, 160, 0, 0 };const uchar intTest1[] = { 0, 0, 255, 255 };const uchar intTest2[] = { 255, 255, 128, 8 };const uchar intTest3[] = { 255, 240, 189, 193 };const uchar intTest4[] = { 255, 254 };const uchar intTest5[] = { 39, 16 };#endifconst char * const specialClasses[] =    {    "java/",    "waba/lang/Object",    "waba/lang/String",    "waba/lang/StringBuffer"    };typedef struct    {    Var *ptr;    uint32 order;    uint32 temp;    } Hos;// NOTE: The total amount of memory used up at any given// time in the heap is: objectSize + (numHandles * sizeof(Hos))typedef struct    {    Hos *hos; // handle, order and scan arrays (interlaced)    uint32 numHandles;    uint32 numFreeHandles;    uchar *mem;    uint32 memSize; // total size of memory (including free)    uint32 objectSize; // size of all objects in heap    } ObjectHeap;class VM    {    public://// stuff declared in waba.cpp//    void VmInit(uint32 vmStackSizeInBytes, uint32 nmStackSizeInBytes,		uint32 classHeapSize, uint32 objectHeapSize);    void VmError(uint16 errNum, WClass *iclass, UtfString *desc1, UtfString *desc2);    void VmQuickError(uint16 errNum);    WObject VmStartApp(char *className);    void VmStopApp(WObject mainWinObj);    void VmFree();    WClass *findLoadedClass(UtfString className);    WClass *getClass(UtfString className);#ifdef NEWTOS    WClass *getClassMaybe(UtfString className, int errIfNoClass);#endif NEWTOS    unsigned char* VM::nativeLoadClass(UtfString className, uint32 *size);    void freeClass(WClass *wclass);    uchar *loadClassConstant(WClass *wclass, uint16 idx, uchar *p);    uchar *loadClassField(WClass *wclass, WClassField *field, uchar *p);    Var constantToVar(WClass *wclass, uint16 idx);    uchar *loadClassMethod(WClass *wclass, WClassMethod *method, uchar *p);#ifdef QUICKBIND    int createVirtualMethodMap(WClass *wclass);#endif    UtfString createUtfString(char *buf);    UtfString getUtfString(WClass *wclass, uint16 idx);    WObject createObject(WClass *wclass);    int32 arrayTypeSize(int32 type);    int32 arraySize(int32 type, int32 len);    WObject createArrayObject(int32 type, int32 len);    uint16 arrayType(char c);    WObject createMultiArray(int32 ndim, const char *desc, Var *sizes);    WObject createStringFromUtf(UtfString s);    WObject createString(char *buf);    UtfString stringToUtf(WObject str, int flags);    int arrayRangeCheck(WObject array, int32 start, int32 count);    Var copyArray(Var stack[]);    WClassField *getField(WClass *wclass, UtfString name, UtfString desc);    WClass *getClassByIndex(WClass *wclass, uint16 classIndex);#ifdef QUICKBIND    int compareMethodNameDesc(WClass *wclass, uint16 mapNum, UtfString name, UtfString desc);    int32 getMethodMapNum(WClass *wclass, UtfString name, UtfString desc, int searchType);    WClassMethod *getMethodByMapNum(WClass *wclass, WClass **vclass, uint16 mapNum);#endif    WClassMethod *getMethod(WClass *wclass, UtfString name, UtfString desc, WClass **vclass);    int32 countMethodParams(UtfString desc);    int compatible(WClass *wclass, WClass *target);    int compatibleArray(WObject obj, UtfString arrayName);    uint32 getUnusedMem();    int initObjectHeap(uint32 heapSize);    void freeObjectHeap();    void markObject(WObject obj);    void sweep();    void gc();    WObject allocObject(int32 size);    int pushObject(WObject obj);    WObject popObject();#ifdef NEWTOS    NativeFunc_i#else    NativeFunc#endif NEWTOS    getNativeMethod(WClass *wclass, UtfString methodName, UtfString methodDesc);    void setClassHooks(WClass *wclass);#ifdef NEWTOS#define executeMethod(class,method,params,numparams)   executeAndReturn(class,method,params,numparams,NULL)    void executeAndReturn(WClass *wclass, WClassMethod *method, Var params[], uint32 numParams, Var *retValue);#else    void executeMethod(WClass *wclass, WClassMethod *method,Var params[], uint32 numParams);#endif NEWTOS    void printToBuf(char *buf, int maxbuf, UtfString *s1, UtfString *s2);    uint32 genHashCode(UtfString name);    uchar* allocClassPart(uint32 size);    WClassField* getFieldByIndex(WClass *wclass, uint16 fieldIndex);    // stuff declared in nmnewt_c.cVar MainWinCreate(Var stack[]);Var MainWinExit(Var stack[]);Var MainWinSetTimerInterval(Var stack[]);int SurfaceGetType(WObject surface);Var FontMetricsCreate(Var stack[]);Var FontMetricsGetWidth(int type, Var stack[]);Var FontMetricsGetStringWidth(Var stack[]);Var FontMetricsGetCharArrayWidth(Var stack[]);Var FontMetricsGetCharWidth(Var stack[]);Var ImageFree(Var stack[]);Var ImageLoad(Var stack[]);Var ImageCreate(Var stack[]);void ImageDestroy(WObject image);Var ImageSetPixels(Var stack[]);void ImageLoadBMP(WObject image, uchar *p);Var GraphicsCreate(Var stack[]);Var GraphicsSetFont(Var stack[]);Var GraphicsSetColor(Var stack[]);Var GraphicsSetDrawOp(Var stack[]);Var GraphicsSetClip(Var stack[]);Var GraphicsGetClip(Var stack[]);Var GraphicsClearClip(Var stack[]);Var GraphicsTranslate(Var stack[]);Var GraphicsDraw(int type, Var stack[]);Var GraphicsDrawRect(Var stack[]);Var GraphicsFillRect(Var stack[]);Var GraphicsDrawLine(Var stack[]);Var GraphicsDrawPolygon(Var stack[]);Var GraphicsFillPolygon(Var stack[]);Var GraphicsDrawChars(Var stack[]);Var GraphicsDrawString(Var stack[]);Var GraphicsDrawDots(Var stack[]);Var GraphicsCopyRect(Var stack[]);Var GraphicsDrawCursor(Var stack[]);Var Return0Func(Var stack[]);Var ReturnNeg1Func(Var stack[]);Var SocketCreate(Var stack[]);void SocketDestroy(WObject socket);Var SocketClose(Var stack[]);Var SocketIsOpen(Var stack[]);Var SocketSetReadTimeout(Var stack[]);Var SocketRead(Var stack[]);Var SocketWrite(Var stack[]);Var SocketReadWriteBytes(Var stack[], int isRead);Var SoundTone(Var stack[]);Var SoundBeep(Var stack[]);Var ConvertFloatToIntBitwise(Var stack[]);Var ConvertIntToFloatBitwise(Var stack[]);Var ConvertStringToInt(Var stack[]);Var ConvertIntToString(Var stack[]);Var ConvertFloatToString(Var stack[]);Var ConvertCharToString(Var stack[]);Var ConvertBooleanToString(Var stack[]);Var CatalogCreate(Var stack[]);Var CatalogIsOpen(Var stack[]);void CatalogDestroy(WObject cat);Var CatalogClose(Var stack[]);Var CatalogDelete(Var stack[]);Var CatalogListCatalogs(Var stack[]);Var CatalogGetRecordSize(Var stack[]);Var CatalogGetRecordCount(Var stack[]);Var CatalogDeleteRecord(Var stack[]);Var CatalogResizeRecord(Var stack[]);Var CatalogAddRecord(Var stack[]);Var CatalogSetRecordPos(Var stack[]);Var CatalogRead(Var stack[]);Var CatalogWrite(Var stack[]);Var CatalogSkipBytes(Var stack[]);Var TimeCreate(Var stack[]);Var SerialPortCreate(Var stack[]);void SerialPortDestroy(WObject port);Var SerialPortIsOpen(Var stack[]);Var SerialPortSetReadTimeout(Var stack[]);Var SerialPortReadCheck(Var stack[]);Var SerialPortSetFlowControl(Var stack[]);Var SerialPortReadWriteBytes(Var stack[], int isRead);Var SerialPortRead(Var stack[]);Var SerialPortWrite(Var stack[]);Var SerialPortClose(Var stack[]);Var VmIsColor(Var stack[]);Var VmGetTimeStamp(Var stack[]);Var VmExec(Var stack[]);Var VmSleep(Var stack[]);Var VmGetPlatform(Var stack[]);Var VmSetDeviceAutoOff(Var stack[]);Var VmGetUserName(Var stack[]);Var FileGetLength(Var stack[]);Var FileCreateDir(Var stack[]);Var FileCreate(Var stack[]);Var FileListDir(Var stack[]);Var FileIsDir(Var stack[]);Var FileClose(Var stack[]);Var FileDelete(Var stack[]);Var FileExists(Var stack[]);Var FileIsOpen(Var stack[]);Var FileSeek(Var stack[]);Var FileRename(Var stack[]);Var FileRead(Var stack[]);Var FileWrite(Var stack[]);Var WindowCreate(Var stack[]);Var SoundClipPlay(Var stack[]);Var GraphicsFree(Var stack[]);// Refs and callbacks:Var RefBuildArray(Var stack[]);Var RefBuildBinary(Var stack[]);Var RefBuildChar(Var stack[]);Var RefBuildFloat(Var stack[]);Var RefBuildFrame(Var stack[]);Var RefBuildInt(Var stack[]);Var RefBuildNil(Var stack[]);Var RefBuildSymbol(Var stack[]);Var RefBuildString(Var stack[]);Var RefCall(Var stack[]);Var RefCharValue(Var stack[]);Var RefGetBytes(Var stack[]);Var RefGetClass(Var stack[]);Var RefGetLength(Var stack[]);Var RefGetPath(Var stack[]);Var RefGetArraySlot(Var stack[]);Var RefGetFrameSlot(Var stack[]);Var RefIntValue(Var stack[]);Var RefFloatValue(Var stack[]);Var RefPush(Var stack[]);Var RefSend(Var stack[]);Var RefSetBytes(Var stack[]);Var RefSetClass(Var stack[]);Var RefSetLength(Var stack[]);Var RefSetArraySlot(Var stack[]);Var RefSetFrameSlot(Var stack[]);Var RefStringValue(Var stack[]);Var RefSymbolValue(Var stack[]);Var RefType(Var stack[]);void RefDestroy(WObject obj);Var CallbackFunc(Var stack[]);Var NSObject(Var stack[]);Var NSProto(Var stack[]);Var ObjectHashCode(Var stack[]);Var VmGetClassName(Var stack[]);Var VmMakeInstance(Var stack[]);    // Constructor        VM() 	    { 	    vmInitialized = 0; 	    mainWinClass = 0;	    imageClass = 0;            mallocCount = 0;#ifdef NEWTOS	    winClass = NULL;	    _winHookOffset = -1;	    initRefStruct(&windowProto);  // initial setting for our RefStructs	    initRefStruct(&classFetcher);	    initRefStruct(&vmReference);	    initRefStruct(&drawArray);	    initRefStruct(&options);	    initRefStruct(&uniqueSymbol);        initRefStruct(&title);        	    windowOpened = 0;	    initRefStruct(&bufferStyleFrame);	    RefVar f = AllocateFrame();	    SetFrameSlot(f,SYM(transferMode),0);  // modeCopy, see nmnewt_c.cp	    setRefStruct(&bufferStyleFrame,f);	    numClassObjPtrs = 0;  // used for classObjPtrs and classObjRefs	#ifdef USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS        initRefStruct(&classObjRefs);	#else        classObjRefs = NULL;	#endif USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFS	    classObjPtrs = NULL; 	    displayingPrefs = 0;		newtonType = GetNewtonType();#endif NEWTOS	    }//// global vars//    int vmInitialized;// virtual machine stack    Var *vmStack;    uint32 vmStackSize; // in Var units    uint32 vmStackPtr;// native method stack    WObject *nmStack;    uint32 nmStackSize; // in WObject units    uint32 nmStackPtr;// keep these prime numbers for best distribution#ifdef SMALLMEM#define CLASS_HASH_SIZE 63#else#define CLASS_HASH_SIZE 255#endif//// Memory Management//// Here's the garbage collector. I implemented the mark and sweep below// after testing out a few different ones and reading://// Garbage Collection, Algorithms for Automatic Dynamic Memory Management// by Richard Jones and Rafael Lins//// which is an excellent book. Also, this collector has gone through a// lot of testing. It runs when the system is completely out of memory// which can happen at any time.. for example during class loading.//// To test it out, tests were run where 1000's of random objects were// loaded, constructed and random methods called on them over some// period of days. This found a couple subtle bugs that were// fixed like when the garbage collector ran in the middle of array// allocation and moved pointers around from under the array allocator// code (those have all been fixed).//// The heap is comprised of Hos objects (an array) that grows from// the "right" of object memory and objects that take up the space on// on the "left" side. The Hos array keeps track of where the objects// are on the left.//// The Hos structure (strange, but aptly named) is used to keep// track of handles (pointers to memory locations), order (order// of handles with respect to memory) and temporary items (used// during the scan phase).//// The 3 items in the Hos structure do not relate to each other. They// are each a part of 3 conceptually distinct arrays that grow// from the right of the heap while the objects grow from the left.// So, when the Hos array is indexed, it is always negative (first// element is 0, next is -1, next is -2, etc).        ObjectHeap heap;    #define FIRST_OBJ 2244#define VALID_OBJ(o) (o > FIRST_OBJ && o <= FIRST_OBJ + heap.numHandles)// class heap    uchar *classHeap;    uint32 classHeapSize;    uint32 classHeapUsed;    WClass *classHashList[CLASS_HASH_SIZE];// error status    ErrorStatus vmStatus;// pointer to String class (for performance)    WClass *stringClass; uchar sbytes[64]; WClass *mainWinClass; WClass *imageClass; #ifdef ARRAY_BUGFIX        // ... so we can quickly get the Object superclass of arrays -- Sean        WClass *objectClass;#endif ARRAY_BUGFIX   // stuff added by Sean#ifdef NEWTOS#define IS_NOS_21	(newtonType < NEWTONTYPE_MP130)#define DRAW_GRAY	(IS_NOS_21 && wantsGray)#define NEWTONTYPE_MP2100	1#define NEWTONTYPE_MP2000	2#define NEWTONTYPE_EMATE	3#define NEWTONTYPE_MP130	4#define NEWTONTYPE_MP120	5// Additional values which can be returned by GetNewtonType#define	NEWTONTYPE_ERROR	10#define	NEWTONTYPE_MARTIAN	11WClass* refClass;   // a pointer to the class newton.RefWClass* callbackClass;  // a pointer to the class newton.Callbackshort width;		// my width, not including decorationsshort height;		// my height, not including decorationschar noSound;	// should I do any sound output?  Including system beepschar newtonType;  // what kind of Newton am I?char wantsGray;  // should I draw in grayscale if possible?char useCPlusPlusHeap;  // should I allocate classes in the C++ heap or just use pointers out to Flash?char doubleBuffer;  // am I using double-buffering?RefStruct* uniqueSymbol;  // my unique symbol for preferences lookupRefStruct* title;		  // the name of my programRefStruct* vmReference;  // a four-byte binary object holding a pointer to this -- we use it as a unique tag to tell people which VM we areRefStruct* classFetcher;  // our class fetcher, must start out as NULL in the constructorRefStruct* windowProto;   // our window proto, must start out as NULL in the constructorRefStruct* drawArray;     // an array of two elements used for drawing -- to avoid reallocationRefStruct* options;	// the options frame that was passed meUtfString mainclassname;  // what was the classname that fired me up?char displayingPrefs;  // I'm displaying the prefs on exit// double-buffer stuffchar windowOpened;		// if I'm already opened, then I don't need to redrawRefStruct* bufferStyleFrame;  // frame with modeCopy transfer mode for blitting the buffer to the window// class allocationunsigned char** classObjPtrs;     // pointers to the classes that we've allocated#ifdef USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFSRefStruct* classObjRefs;  		  // array of references to the class blocks so they don't get lost##elseRefStruct** classObjRefs;  		  // array of references to the class blocks so they don't get lost##endif USE_NEWTONSCRIPT_ARRAY_FOR_CLASS_REFSint numClassObjPtrs;WClass *winClass; 		  // a pointer to the class for "waba.ui.Window", in case we                          // ever want to distinguish between windows and main windowsint _winHookOffset;		  // a hook offset for windowsWObject globalMainWin;	  // the main window// set our window title bar of sortsvoid SetTitle(UtfString str);// add or eliminate classes to classObjPtrsvoid pushClass(unsigned char* classptr);void pushClassRef(RefArg classptr);void freeClasses();// offer to display the preferences window in case of a memory errorvoid DisplayPrefs(int error);// our main access points to the VM.  Starting, stopping, and pulsing the VM.void VmStartAppNewton(char* className, RefArg _classFetcher, RefArg _vmPointer, RefArg optionsFrame, RefArg prefsFrame);void VmStopAppNewton();int PulseNewton(RefArg event);// return a Newton timestamp as an intint GetTimeStamp();// throw up a Newton alert boxvoid MakeAlertBox(UtfString* titlebuf, UtfString* buf);// Methods to convert strings.  The important ones are the first three,// the others are used internally by them.// From UTF8.cpp WObject NewtonStringToWabaString(RefArg string_or_rich_string); Ref WabaStringToNewtonString(WObject utf8_string); Ref UtfStringToNewtonString(UtfString s); int LengthOfUtf8ForUnicode(const unsigned short *unicode, int len); int ConvertUnicodeToUtf8(const unsigned short *unicode, char *utf8, int len); int ConvertUtf8ToUnicode(unsigned short *unicode, const char *utf8, int len); int NumUnicodeCharsInUtf8(const char *utf8, int len); // Standard itoa as given in the K&R.  We're not using it any more tho. void itoa(char* buf, int n);  // Returns a Newton font frame (family:, size:, style:} for the given font Ref FontSpecForFont(WObject font);  // creates and stores in graphics Newton clipping regions specified by the clipping // int values in the graphics object. void GraphicsCreateClippingRegion(WObject graphics);  // Draws the specified shape, translated and clipped according to graphics, // with the specified style, on the given surface according to graphicsvoid DrawNewtonGraphics(RefArg shape,WObject graphics,RefArg styleframe); // forms a Newton bitmap out of the (x,y)->(x+width,y+height) rectanglar area on surfaceRef SnarfIntoBitmap(int x, int y, int width, int height, WObject surface);  // finisher native functions void WindowDestroy(WObject win); void ImageDestoy(WObject image); void GraphicsDestroy(WObject graphics);// Display the double-buffer in the windowvoid SplatBufferIntoWindow(WObject window, RefArg clipframe);// Handle callbacksRef CallbackNewton(int id, RefArg args);// Debugging malloc and freeint mallocCount;void* debugmalloc(int size)    {    mallocCount++;    return malloc(size);    };void debugfree(void* ptr)    {    mallocCount--;    free(ptr);    };private:	// Private functions	// Get the Newton Typestatic int GetNewtonType( void );	enum {		// Internal constants used for Gestalt				// ===== Machine Type =====		kMP120_130_MT		= kGestalt_MachineType_Lindy,		kMP2x00_MT			= 0x10003000,		kEM300_MT			= 0x10004000,				// RAM Size - to distinguish the MP120 and the MP130		kMP120_RS			= 0x080000,		kMP130_RS			= 0x100000,		// RAM Size - to distinguish the MP2100 and the MP2000		kMP2100_RS			= 0x3E4000,		// Unused		kEM300u_RS			= 0x3E1000	};#endif NEWTOS };//// Native Methods and Hooks//typedef struct	{	char *className;#ifdef NEWTOS	ObjDestroyFunc_i destroyFunc;#else    ObjDestroyFunc destroyFunc;#endif NEWTOS	uint16 varsNeeded;	} ClassHook;typedef struct	{	uint32 hash;#ifdef NEWTOS	NativeFunc_i func;#else    NativeFunc func;#endif NEWTOS	} NativeMethod;void handleNewtonException(VM* vm, char* name)    {    UtfString message = vm->createUtfString("A NewtonScript Exception was raised.");    UtfString theinfo = vm->createUtfString(name);    vm->VmError(ERR_NewtOSError,NULL,&message,&theinfo);    }Var callNativeMethod(NativeFunc_i func, VM* vm, Var stack[])    {    /* I generated this big ugly case statement using the following    UNIX shell script.  First, I copied all the stuff between the braces    in nativeMethods[] to a file called junk, then ran:    grep "VM::" junk | awk '{print $3'} - | awk -F: '{print $3}' - | awk 'BEGIN{s=0}{print "        case " s ": return vm->" $1 "(stack); break;"; s += 1; }' - > junk.out    ... the result is in junk.out, which is pasted here.    Let us pray that Apple's compiler is smart and knows how to convert    this into an offset table instead of a huge gob of if/thens.*/#ifdef CATCH_NEWTON_EXCEPTIONS    DECLARE_VOLATILE(Var,ret);#else    Var ret;#endif CATCH_NEWTON_EXCEPTIONS    ret.obj=0; // in case we don't get a return value    #ifdef CATCH_NEWTON_EXCEPTIONSnewton_try    {#endif CATCH_NEWTON_EXCEPTIONS    switch(func)        {        case 0: ret = vm->VmExec(stack); break;     // waba/sys/Vm.exec(Ljava/lang/String;Ljava/lang/String;IZ)I        case 1: ret = vm->VmGetTimeStamp(stack); break;     // waba/sys/Vm.getTimeStamp()I        case 2: ret = vm->VmGetClassName(stack); break;     // waba/sys/Vm.getClassName(Ljava/lang/Object;)Ljava/lang/String;        case 3: ret = vm->copyArray(stack); break;     // waba/sys/Vm.copyArray(Ljava/lang/Object;ILjava/lang/Object;II)Z        case 4: ret = vm->VmMakeInstance(stack); break;     // waba/sys/Vm.makeInstance(Ljava/lang/String;)Ljava/lang/Object;        case 5: ret = vm->VmSleep(stack); break;     // waba/sys/Vm.sleep(I)V        case 6: ret = vm->VmSetDeviceAutoOff(stack); break;     // waba/sys/Vm.setDeviceAutoOff(I)I        case 7: ret = vm->VmGetUserName(stack); break;     // waba/sys/Vm.getUserName()Ljava/lang/String;        case 8: ret = vm->VmGetPlatform(stack); break;     // waba/sys/Vm.getPlatform()Ljava/lang/String;        case 9: ret = vm->VmIsColor(stack); break;     // waba/sys/Vm.isColor()Z        case 10: ret = vm->FileGetLength(stack); break;     // waba/io/File.getLength()I        case 11: ret = vm->FileCreateDir(stack); break;     // waba/io/File.createDir()Z        case 12: ret = vm->FileRead(stack); break;     // waba/io/File.readBytes([BII)I        case 13: ret = vm->FileRename(stack); break;     // waba/io/File.rename(Ljava/lang/String;)Z        case 14: ret = vm->FileCreate(stack); break;     // waba/io/File._nativeCreate()V        case 15: ret = vm->FileWrite(stack); break;     // waba/io/File.writeBytes([BII)I        case 16: ret = vm->FileListDir(stack); break;     // waba/io/File.listDir()[Ljava/lang/String;        case 17: ret = vm->FileSeek(stack); break;     // waba/io/File.seek(I)Z        case 18: ret = vm->FileIsDir(stack); break;     // waba/io/File.isDir()Z        case 19: ret = vm->FileClose(stack); break;     // waba/io/File.close()Z        case 20: ret = vm->FileIsOpen(stack); break;     // waba/io/File.isOpen()Z        case 21: ret = vm->FileDelete(stack); break;     // waba/io/File.delete()Z        case 22: ret = vm->FileExists(stack); break;     // waba/io/File.exists()Z        case 23: ret = vm->ImageCreate(stack); break;     // waba/fx/Image._nativeCreate()V        case 24: ret = vm->ImageFree(stack); break;     // waba/fx/Image.free()V        case 25: ret = vm->ImageSetPixels(stack); break;     // waba/fx/Image.setPixels(I[IIII[B)V        case 26: ret = vm->ImageLoad(stack); break;     // waba/fx/Image._nativeLoad(Ljava/lang/String;)V        case 27: ret = vm->SoundBeep(stack); break;     // waba/fx/Sound.beep()V        case 28: ret = vm->SoundTone(stack); break;     // waba/fx/Sound.tone(II)V        case 29: ret = vm->TimeCreate(stack); break;     // waba/sys/Time._nativeCreate()V        case 30: ret = vm->SocketCreate(stack); break;     // waba/io/Socket._nativeCreate(Ljava/lang/String;I)V        case 31: ret = vm->SocketRead(stack); break;     // waba/io/Socket.readBytes([BII)I        case 32: ret = vm->SocketWrite(stack); break;     // waba/io/Socket.writeBytes([BII)I        case 33: ret = vm->SocketSetReadTimeout(stack); break;     // waba/io/Socket.setReadTimeout(I)Z        case 34: ret = vm->SocketClose(stack); break;     // waba/io/Socket.close()Z        case 35: ret = vm->SocketIsOpen(stack); break;     // waba/io/Socket.isOpen()Z        case 36: ret = vm->WindowCreate(stack); break;     // waba/ui/Window._nativeCreate()V        case 37: ret = vm->CatalogListCatalogs(stack); break;     // waba/io/Catalog.listCatalogs()[Ljava/lang/String;        case 38: ret = vm->CatalogAddRecord(stack); break;     // waba/io/Catalog.addRecord(I)I        case 39: ret = vm->CatalogSkipBytes(stack); break;     // waba/io/Catalog.skipBytes(I)I        case 40: ret = vm->CatalogCreate(stack); break;     // waba/io/Catalog._nativeCreate(Ljava/lang/String;I)V        case 41: ret = vm->CatalogRead(stack); break;     // waba/io/Catalog.readBytes([BII)I        case 42: ret = vm->CatalogDeleteRecord(stack); break;     // waba/io/Catalog.deleteRecord()Z        case 43: ret = vm->CatalogSetRecordPos(stack); break;     // waba/io/Catalog.setRecordPos(I)Z        case 44: ret = vm->CatalogGetRecordSize(stack); break;     // waba/io/Catalog.getRecordSize()I        case 45: ret = vm->CatalogResizeRecord(stack); break;     // waba/io/Catalog.resizeRecord(I)Z        case 46: ret = vm->CatalogWrite(stack); break;     // waba/io/Catalog.writeBytes([BII)I        case 47: ret = vm->CatalogGetRecordCount(stack); break;     // waba/io/Catalog.getRecordCount()I        case 48: ret = vm->CatalogClose(stack); break;     // waba/io/Catalog.close()Z        case 49: ret = vm->CatalogIsOpen(stack); break;     // waba/io/Catalog.isOpen()Z        case 50: ret = vm->CatalogDelete(stack); break;     // waba/io/Catalog.delete()Z        case 51: ret = vm->CallbackFunc(stack); break;     // newton/Callback._func(Lnewton/Ref;)Lnewton/Ref;        case 52: ret = vm->ObjectHashCode(stack); break;     // java/lang/Object.hashCode()I        case 53: ret = vm->GraphicsCopyRect(stack); break;     // waba/fx/Graphics.copyRect(Lwaba/fx/ISurface;IIIIII)V        case 54: ret = vm->GraphicsClearClip(stack); break;     // waba/fx/Graphics.clearClip()V        case 55: ret = vm->GraphicsSetFont(stack); break;     // waba/fx/Graphics.setFont(Lwaba/fx/Font;)V        case 56: ret = vm->GraphicsSetDrawOp(stack); break;     // waba/fx/Graphics.setDrawOp(I)V        case 57: ret = vm->GraphicsSetClip(stack); break;     // waba/fx/Graphics.setClip(IIII)V        case 58: ret = vm->GraphicsSetColor(stack); break;     // waba/fx/Graphics.setColor(III)V        case 59: ret = vm->GraphicsGetClip(stack); break;     // waba/fx/Graphics.getClip(Lwaba/fx/Rect;)Lwaba/fx/Rect;        case 60: ret = vm->GraphicsFillRect(stack); break;     // waba/fx/Graphics.fillRect(IIII)V        case 61: ret = vm->GraphicsDrawLine(stack); break;     // waba/fx/Graphics.drawLine(IIII)V        case 62: ret = vm->GraphicsTranslate(stack); break;     // waba/fx/Graphics.translate(II)V        case 63: ret = vm->GraphicsDrawRect(stack); break;     // waba/fx/Graphics.drawRect(IIII)V        case 64: ret = vm->GraphicsDrawDots(stack); break;     // waba/fx/Graphics.drawDots(IIII)V        case 65: ret = vm->GraphicsDrawChars(stack); break;     // waba/fx/Graphics.drawText([CIIII)V        case 66: ret = vm->GraphicsCreate(stack); break;     // waba/fx/Graphics._nativeCreate()V        case 67: ret = vm->GraphicsDrawCursor(stack); break;     // waba/fx/Graphics.drawCursor(IIII)V        case 68: ret = vm->GraphicsSetClip(stack); break;     // waba/fx/Graphics.setClipRect(IIII)V        case 69: ret = vm->GraphicsFree(stack); break;     // waba/fx/Graphics.free()V        case 70: ret = vm->GraphicsFillPolygon(stack); break;     // waba/fx/Graphics.fillPolygon([I[II)V        case 71: ret = vm->GraphicsDrawPolygon(stack); break;     // waba/fx/Graphics.drawPolygon([I[II)V        case 72: ret = vm->GraphicsDrawString(stack); break;     // waba/fx/Graphics.drawText(Ljava/lang/String;II)V        case 73: ret = vm->ConvertStringToInt(stack); break;     // waba/sys/Convert.toInt(Ljava/lang/String;)I        case 74: ret = vm->ConvertFloatToIntBitwise(stack); break;     // waba/sys/Convert.toIntBitwise(F)I        case 75: ret = vm->ConvertCharToString(stack); break;     // waba/sys/Convert.toString(C)Ljava/lang/String;        case 76: ret = vm->ConvertIntToFloatBitwise(stack); break;     // waba/sys/Convert.toFloatBitwise(I)F        case 77: ret = vm->ConvertFloatToString(stack); break;     // waba/sys/Convert.toString(F)Ljava/lang/String;        case 78: ret = vm->ConvertIntToString(stack); break;     // waba/sys/Convert.toString(I)Ljava/lang/String;        case 79: ret = vm->ConvertBooleanToString(stack); break;     // waba/sys/Convert.toString(Z)Ljava/lang/String;        case 80: ret = vm->SoundClipPlay(stack); break;     // waba/fx/SoundClip.play()Z        case 81: ret = vm->MainWinCreate(stack); break;     // waba/ui/MainWindow._nativeCreate()V        case 82: ret = vm->MainWinExit(stack); break;     // waba/ui/MainWindow.exit(I)V        case 83: ret = vm->MainWinSetTimerInterval(stack); break;     // waba/ui/MainWindow._setTimerInterval(I)V        case 84: ret = vm->SerialPortReadCheck(stack); break;     // waba/io/SerialPort.readCheck()I        case 85: ret = vm->SerialPortRead(stack); break;     // waba/io/SerialPort.readBytes([BII)I        case 86: ret = vm->SerialPortWrite(stack); break;     // waba/io/SerialPort.writeBytes([BII)I        case 87: ret = vm->SerialPortSetReadTimeout(stack); break;     // waba/io/SerialPort.setReadTimeout(I)Z        case 88: ret = vm->SerialPortClose(stack); break;     // waba/io/SerialPort.close()Z        case 89: ret = vm->SerialPortSetFlowControl(stack); break;     // waba/io/SerialPort.setFlowControl(Z)Z        case 90: ret = vm->SerialPortIsOpen(stack); break;     // waba/io/SerialPort.isOpen()Z        case 91: ret = vm->SerialPortCreate(stack); break;     // waba/io/SerialPort._nativeCreate(IIIZI)V        case 92: ret = vm->FontMetricsGetStringWidth(stack); break;     // waba/fx/FontMetrics.getTextWidth(Ljava/lang/String;)I        case 93: ret = vm->FontMetricsGetCharWidth(stack); break;     // waba/fx/FontMetrics.getCharWidth(C)I        case 94: ret = vm->FontMetricsCreate(stack); break;     // waba/fx/FontMetrics._nativeCreate()V        case 95: ret = vm->FontMetricsGetCharArrayWidth(stack); break;     // waba/fx/FontMetrics.getTextWidth([CII)I        case 96: ret = vm->NSProto(stack); break;     // newton/NS.proto(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;        case 97: ret = vm->NSObject(stack); break;     // newton/NS.object(ILnewton/Ref;)Lnewton/Ref;        case 98: ret = vm->RefSend(stack); break;     // newton/Ref.send(Lnewton/Ref;[Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;        case 99: ret = vm->RefBuildInt(stack); break;     // newton/Ref.buildInt(I)V        case 100: ret = vm->RefCharValue(stack); break;     // newton/Ref.charValue()C        case 101: ret = vm->RefGetLength(stack); break;     // newton/Ref.getLength()I        case 102: ret = vm->RefGetArraySlot(stack); break;     // newton/Ref.getSlot(ILnewton/Ref;)Lnewton/Ref;        case 103: ret = vm->RefGetClass(stack); break;     // newton/Ref.getClass(Lnewton/Ref;)Lnewton/Ref;        case 104: ret = vm->RefSetArraySlot(stack); break;     // newton/Ref.setSlot(ILnewton/Ref;)Lnewton/Ref;        case 105: ret = vm->RefGetPath(stack); break;     // newton/Ref.getPath(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;        case 106: ret = vm->RefSetClass(stack); break;     // newton/Ref.setClass(Lnewton/Ref;)Lnewton/Ref;        case 107: ret = vm->RefBuildChar(stack); break;     // newton/Ref.buildChar(C)V        case 108: ret = vm->RefGetFrameSlot(stack); break;     // newton/Ref.getSlot(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;        case 109: ret = vm->RefSetFrameSlot(stack); break;     // newton/Ref.setSlot(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;        case 110: ret = vm->RefSetLength(stack); break;     // newton/Ref.setLength(I)I        case 111: ret = vm->RefBuildFrame(stack); break;     // newton/Ref.buildFrame()V        case 112: ret = vm->RefFloatValue(stack); break;     // newton/Ref.floatValue()F        case 113: ret = vm->RefBuildFloat(stack); break;     // newton/Ref.buildFloat(F)V        case 114: ret = vm->RefBuildArray(stack); break;     // newton/Ref.buildArray(I)V        case 115: ret = vm->RefGetBytes(stack); break;     // newton/Ref.getBytes(III[B)I        case 116: ret = vm->RefSetBytes(stack); break;     // newton/Ref.setBytes(III[B)I        case 117: ret = vm->RefBuildBinary(stack); break;     // newton/Ref.buildBinary(ILnewton/Ref;)V        case 118: ret = vm->RefType(stack); break;     // newton/Ref.type()I        case 119: ret = vm->RefPush(stack); break;     // newton/Ref.push(Lnewton/Ref;)Lnewton/Ref;        case 120: ret = vm->RefSymbolValue(stack); break;     // newton/Ref.symbolValue()Ljava/lang/String;        case 121: ret = vm->RefStringValue(stack); break;     // newton/Ref.stringValue()Ljava/lang/String;        case 122: ret = vm->RefCall(stack); break;     // newton/Ref.call([Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;        case 123: ret = vm->RefBuildSymbol(stack); break;     // newton/Ref.buildSymbol(Ljava/lang/String;)V        case 124: ret = vm->RefBuildString(stack); break;     // newton/Ref.buildString(Ljava/lang/String;)V        case 125: ret = vm->RefBuildNil(stack); break;     // newton/Ref.buildNil()V        case 126: ret = vm->RefIntValue(stack); break;     // newton/Ref.intValue()I        }#ifdef CATCH_NEWTON_EXCEPTIONS    // we should never get here;    // but never break out of a newton_try block    }newton_catch_all    {    handleNewtonException(vm,CurrentException()->name);    // never return or break from a newton_catch_all block    }end_try;#endif CATCH_NEWTON_EXCEPTIONSreturn ret;}    /* Generated using:grep "VM::" junk | awk '{print $2 ":" $3;}' - | awk -F: '{print $1 " " $4;}' - | awk -F, '{print $1 " " $2;}' - | awk 'BEGIN{s=0}{print "    { " $1 ", " s " },"; s+=1;}' - */const NativeMethod nativeMethods[] =     {    { 113969325, 0 },     // waba/sys/Vm.exec(Ljava/lang/String;Ljava/lang/String;IZ)I     (VmExec)    { 113990543, 1 },     // waba/sys/Vm.getTimeStamp()I     (VmGetTimeStamp)    { 114002482, 2 },     // waba/sys/Vm.getClassName(Ljava/lang/Object;)Ljava/lang/String;     (VmGetClassName)    { 114004019, 3 },     // waba/sys/Vm.copyArray(Ljava/lang/Object;ILjava/lang/Object;II)Z     (copyArray)    { 114004274, 4 },     // waba/sys/Vm.makeInstance(Ljava/lang/String;)Ljava/lang/Object;     (VmMakeInstance)    { 114016841, 5 },     // waba/sys/Vm.sleep(I)V     (VmSleep)    { 114019540, 6 },     // waba/sys/Vm.setDeviceAutoOff(I)I     (VmSetDeviceAutoOff)    { 114021471, 7 },     // waba/sys/Vm.getUserName()Ljava/lang/String;     (VmGetUserName)    { 114023839, 8 },     // waba/sys/Vm.getPlatform()Ljava/lang/String;     (VmGetPlatform)    { 114024842, 9 },     // waba/sys/Vm.isColor()Z     (VmIsColor)    { 340528908, 10 },     // waba/io/File.getLength()I     (FileGetLength)    { 340529036, 11 },     // waba/io/File.createDir()Z     (FileCreateDir)    { 340548368, 12 },     // waba/io/File.readBytes([BII)I     (FileRead)    { 340553947, 13 },     // waba/io/File.rename(Ljava/lang/String;)Z     (FileRename)    { 340555856, 14 },     // waba/io/File._nativeCreate()V     (FileCreate)    { 340557521, 15 },     // waba/io/File.writeBytes([BII)I     (FileWrite)    { 340560348, 16 },     // waba/io/File.listDir()[Ljava/lang/String;     (FileListDir)    { 340567816, 17 },     // waba/io/File.seek(I)Z     (FileSeek)    { 340568456, 18 },     // waba/io/File.isDir()Z     (FileIsDir)    { 340570184, 19 },     // waba/io/File.close()Z     (FileClose)    { 340575817, 20 },     // waba/io/File.isOpen()Z     (FileIsOpen)    { 340576137, 21 },     // waba/io/File.delete()Z     (FileDelete)    { 340579017, 22 },     // waba/io/File.exists()Z     (FileExists)    { 781023312, 23 },     // waba/fx/Image._nativeCreate()V     (ImageCreate)    { 781029959, 24 },     // waba/fx/Image.free()V     (ImageFree)    { 781038420, 25 },     // waba/fx/Image.setPixels(I[IIII[B)V     (ImageSetPixels)    { 781052768, 26 },     // waba/fx/Image._nativeLoad(Ljava/lang/String;)V     (ImageLoad)    { 940413127, 27 },     // waba/fx/Sound.beep()V     (SoundBeep)    { 940424137, 28 },     // waba/fx/Sound.tone(II)V     (SoundTone)    { 969766992, 29 },     // waba/sys/Time._nativeCreate()V     (TimeCreate)    { 1317941923, 30 },     // waba/io/Socket._nativeCreate(Ljava/lang/String;I)V     (SocketCreate)    { 1317952272, 31 },     // waba/io/Socket.readBytes([BII)I     (SocketRead)    { 1317961425, 32 },     // waba/io/Socket.writeBytes([BII)I     (SocketWrite)    { 1317972178, 33 },     // waba/io/Socket.setReadTimeout(I)Z     (SocketSetReadTimeout)    { 1317974088, 34 },     // waba/io/Socket.close()Z     (SocketClose)    { 1317979721, 35 },     // waba/io/Socket.isOpen()Z     (SocketIsOpen)    { 1406040144, 36 },     // waba/ui/Window._nativeCreate()V     (WindowCreate)    { 1661930913, 37 },     // waba/io/Catalog.listCatalogs()[Ljava/lang/String;     (CatalogListCatalogs)    { 1661934285, 38 },     // waba/io/Catalog.addRecord(I)I     (CatalogAddRecord)    { 1661937741, 39 },     // waba/io/Catalog.skipBytes(I)I     (CatalogSkipBytes)    { 1661940387, 40 },     // waba/io/Catalog._nativeCreate(Ljava/lang/String;I)V     (CatalogCreate)    { 1661950736, 41 },     // waba/io/Catalog.readBytes([BII)I     (CatalogRead)    { 1661951823, 42 },     // waba/io/Catalog.deleteRecord()Z     (CatalogDeleteRecord)    { 1661957200, 43 },     // waba/io/Catalog.setRecordPos(I)Z     (CatalogSetRecordPos)    { 1661957392, 44 },     // waba/io/Catalog.getRecordSize()I     (CatalogGetRecordSize)    { 1661958480, 45 },     // waba/io/Catalog.resizeRecord(I)Z     (CatalogResizeRecord)    { 1661959889, 46 },     // waba/io/Catalog.writeBytes([BII)I     (CatalogWrite)    { 1661964433, 47 },     // waba/io/Catalog.getRecordCount()I     (CatalogGetRecordCount)    { 1661972552, 48 },     // waba/io/Catalog.close()Z     (CatalogClose)    { 1661978185, 49 },     // waba/io/Catalog.isOpen()Z     (CatalogIsOpen)    { 1661978505, 50 },     // waba/io/Catalog.delete()Z     (CatalogDelete)    { 1976552991, 51 },     // newton/Callback._func(Lnewton/Ref;)Lnewton/Ref;     (CallbackFunc)    { 2119233099, 52 },     // java/lang/Object.hashCode()I     (ObjectHashCode)    { 2182088099, 53 },     // waba/fx/Graphics.copyRect(Lwaba/fx/ISurface;IIIIII)V     (GraphicsCopyRect)    { 2182090124, 54 },     // waba/fx/Graphics.clearClip()V     (GraphicsClearClip)    { 2182094808, 55 },     // waba/fx/Graphics.setFont(Lwaba/fx/Font;)V     (GraphicsSetFont)    { 2182095437, 56 },     // waba/fx/Graphics.setDrawOp(I)V     (GraphicsSetDrawOp)    { 2182096846, 57 },     // waba/fx/Graphics.setClip(IIII)V     (GraphicsSetClip)    { 2182099790, 58 },     // waba/fx/Graphics.setColor(III)V     (GraphicsSetColor)    { 2182102117, 59 },     // waba/fx/Graphics.getClip(Lwaba/fx/Rect;)Lwaba/fx/Rect;     (GraphicsGetClip)    { 2182103055, 60 },     // waba/fx/Graphics.fillRect(IIII)V     (GraphicsFillRect)    { 2182103119, 61 },     // waba/fx/Graphics.drawLine(IIII)V     (GraphicsDrawLine)    { 2182103502, 62 },     // waba/fx/Graphics.translate(II)V     (GraphicsTranslate)    { 2182103503, 63 },     // waba/fx/Graphics.drawRect(IIII)V     (GraphicsDrawRect)    { 2182104271, 64 },     // waba/fx/Graphics.drawDots(IIII)V     (GraphicsDrawDots)    { 2182115089, 65 },     // waba/fx/Graphics.drawText([CIIII)V     (GraphicsDrawChars)    { 2182117456, 66 },     // waba/fx/Graphics._nativeCreate()V     (GraphicsCreate)    { 2182118865, 67 },     // waba/fx/Graphics.drawCursor(IIII)V     (GraphicsDrawCursor)    { 2182122322, 68 },     // waba/fx/Graphics.setClipRect(IIII)V     (GraphicsSetClip)    { 2182124103, 69 },     // waba/fx/Graphics.free()V     (GraphicsFree)    { 2182132179, 70 },     // waba/fx/Graphics.fillPolygon([I[II)V     (GraphicsFillPolygon)    { 2182132627, 71 },     // waba/fx/Graphics.drawPolygon([I[II)V     (GraphicsDrawPolygon)    { 2182138655, 72 },     // waba/fx/Graphics.drawText(Ljava/lang/String;II)V     (GraphicsDrawString)    { 2387628570, 73 },     // waba/sys/Convert.toInt(Ljava/lang/String;)I     (ConvertStringToInt)    { 2387636560, 74 },     // waba/sys/Convert.toIntBitwise(F)I     (ConvertFloatToIntBitwise)    { 2387649437, 75 },     // waba/sys/Convert.toString(C)Ljava/lang/String;     (ConvertCharToString)    { 2387649554, 76 },     // waba/sys/Convert.toFloatBitwise(I)F     (ConvertIntToFloatBitwise)    { 2387649629, 77 },     // waba/sys/Convert.toString(F)Ljava/lang/String;     (ConvertFloatToString)    { 2387649821, 78 },     // waba/sys/Convert.toString(I)Ljava/lang/String;     (ConvertIntToString)    { 2387650909, 79 },     // waba/sys/Convert.toString(Z)Ljava/lang/String;     (ConvertBooleanToString)    { 2584844359, 80 },     // waba/fx/SoundClip.play()Z     (SoundClipPlay)    { 3037886544, 81 },     // waba/ui/MainWindow._nativeCreate()V     (MainWinCreate)    { 3037899400, 82 },     // waba/ui/MainWindow.exit(I)V     (MainWinExit)    { 3037919317, 83 },     // waba/ui/MainWindow._setTimerInterval(I)V     (MainWinSetTimerInterval)    { 3046245644, 84 },     // waba/io/SerialPort.readCheck()I     (SerialPortReadCheck)    { 3046267664, 85 },     // waba/io/SerialPort.readBytes([BII)I     (SerialPortRead)    { 3046276817, 86 },     // waba/io/SerialPort.writeBytes([BII)I     (SerialPortWrite)    { 3046287570, 87 },     // waba/io/SerialPort.setReadTimeout(I)Z     (SerialPortSetReadTimeout)    { 3046289480, 88 },     // waba/io/SerialPort.close()Z     (SerialPortClose)    { 3046290066, 89 },     // waba/io/SerialPort.setFlowControl(Z)Z     (SerialPortSetFlowControl)    { 3046295113, 90 },     // waba/io/SerialPort.isOpen()Z     (SerialPortIsOpen)    { 3046299605, 91 },     // waba/io/SerialPort._nativeCreate(IIIZI)V     (SerialPortCreate)    { 3511879649, 92 },     // waba/fx/FontMetrics.getTextWidth(Ljava/lang/String;)I     (FontMetricsGetStringWidth)    { 3511903952, 93 },     // waba/fx/FontMetrics.getCharWidth(C)I     (FontMetricsGetCharWidth)    { 3511908432, 94 },     // waba/fx/FontMetrics._nativeCreate()V     (FontMetricsCreate)    { 3511921619, 95 },     // waba/fx/FontMetrics.getTextWidth([CII)I     (FontMetricsGetCharArrayWidth)    { 3670668267, 96 },     // newton/NS.proto(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;     (NSProto)    { 3670670177, 97 },     // newton/NS.object(ILnewton/Ref;)Lnewton/Ref;     (NSObject)    { 4190766007, 98 },     // newton/Ref.send(Lnewton/Ref;[Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;     (RefSend)    { 4190767820, 99 },     // newton/Ref.buildInt(I)V     (RefBuildInt)    { 4190768076, 100 },     // newton/Ref.charValue()C     (RefCharValue)    { 4190768908, 101 },     // newton/Ref.getLength()I     (RefGetLength)    { 4190770722, 102 },     // newton/Ref.getSlot(ILnewton/Ref;)Lnewton/Ref;     (RefGetArraySlot)    { 4190771426, 103 },     // newton/Ref.getClass(Lnewton/Ref;)Lnewton/Ref;     (RefGetClass)    { 4190771490, 104 },     // newton/Ref.setSlot(ILnewton/Ref;)Lnewton/Ref;     (RefSetArraySlot)    { 4190771757, 105 },     // newton/Ref.getPath(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;     (RefGetPath)    { 4190772194, 106 },     // newton/Ref.setClass(Lnewton/Ref;)Lnewton/Ref;     (RefSetClass)    { 4190772749, 107 },     // newton/Ref.buildChar(C)V     (RefBuildChar)    { 4190773101, 108 },     // newton/Ref.getSlot(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;     (RefGetFrameSlot)    { 4190773869, 109 },     // newton/Ref.setSlot(Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;     (RefSetFrameSlot)    { 4190774349, 110 },     // newton/Ref.setLength(I)I     (RefSetLength)    { 4190775437, 111 },     // newton/Ref.buildFrame()V     (RefBuildFrame)    { 4190775949, 112 },     // newton/Ref.floatValue()F     (RefFloatValue)    { 4190780622, 113 },     // newton/Ref.buildFloat(F)V     (RefBuildFloat)    { 4190781390, 114 },     // newton/Ref.buildArray(I)V     (RefBuildArray)    { 4190787152, 115 },     // newton/Ref.getBytes(III[B)I     (RefGetBytes)    { 4190787920, 116 },     // newton/Ref.setBytes(III[B)I     (RefSetBytes)    { 4190794971, 117 },     // newton/Ref.buildBinary(ILnewton/Ref;)V     (RefBuildBinary)    { 4190803719, 118 },     // newton/Ref.type()I     (RefType)    { 4190813022, 119 },     // newton/Ref.push(Lnewton/Ref;)Lnewton/Ref;     (RefPush)    { 4190822687, 120 },     // newton/Ref.symbolValue()Ljava/lang/String;     (RefSymbolValue)    { 4190822751, 121 },     // newton/Ref.stringValue()Ljava/lang/String;     (RefStringValue)    { 4190823595, 122 },     // newton/Ref.call([Lnewton/Ref;Lnewton/Ref;)Lnewton/Ref;     (RefCall)    { 4190827360, 123 },     // newton/Ref.buildSymbol(Ljava/lang/String;)V     (RefBuildSymbol)    { 4190827424, 124 },     // newton/Ref.buildString(Ljava/lang/String;)V     (RefBuildString)    { 4190828171, 125 },     // newton/Ref.buildNil()V     (RefBuildNil)    { 4190828683, 126 },     // newton/Ref.intValue()I     (RefIntValue)    };    /*// This array is used to map a hash value to a corresponding native function.// It must remain sorted by hash value because a binary search is performed// to find a method by its hash value. There is a small chance of collision// if two hashes match and if one occurs, the function name should be changed// to avoid collision. To prevent users from creating invalid native methods// that hash to a valid value, native methods could be restricted to a specific// set of classes (this is probably not necessary since any verifier probably// wouldn't allow native methods to get by anyway).const NativeMethod nativeMethods[] =    {    // waba/sys/Vm_exec_(Ljava/lang/String;Ljava/lang/String;IZ)I    { 113969325, VM::VmExec },    // waba/sys/Vm_getTimeStamp_()I    { 113990543, VM::VmGetTimeStamp },    // waba/sys/Vm_copyArray_(Ljava/lang/Object;ILjava/lang/Object;II)Z    { 114004019, VM::copyArray },    // waba/sys/Vm_sleep_(I)V    { 114016841, VM::VmSleep },    // waba/sys/Vm_setDeviceAutoOff_(I)I    { 114019540, VM::VmSetDeviceAutoOff },    // waba/sys/Vm_getUserName_()Ljava/lang/String;    { 114021471, VM::VmGetUserName },    // waba/sys/Vm_getPlatform_()Ljava/lang/String;    { 114023839, VM::VmGetPlatform },    // waba/sys/Vm_isColor_()Z    { 114024842, VM::VmIsColor },    // waba/io/File_getLength_()I    { 340528908, VM::FileGetLength },    // waba/io/File_createDir_()Z    { 340529036, VM::FileCreateDir },    // waba/io/File_readBytes_([BII)I    { 340548368, VM::FileRead },    // waba/io/File_rename_(Ljava/lang/String;)Z    { 340553947, VM::FileRename },    // waba/io/File__nativeCreate_()V    { 340555856, VM::FileCreate },    // waba/io/File_writeBytes_([BII)I    { 340557521, VM::FileWrite },    // waba/io/File_listDir_()[Ljava/lang/String;    { 340560348, VM::FileListDir },    // waba/io/File_seek_(I)Z    { 340567816, VM::FileSeek },    // waba/io/File_isDir_()Z    { 340568456, VM::FileIsDir },    // waba/io/File_close_()Z    { 340570184, VM::FileClose },    // waba/io/File_isOpen_()Z    { 340575817, VM::FileIsOpen },    // waba/io/File_delete_()Z    { 340576137, VM::FileDelete },    // waba/io/File_exists_()Z    { 340579017, VM::FileExists },    // waba/fx/Image__nativeCreate_()V    { 781023312, VM::ImageCreate },    // waba/fx/Image_free_()V    { 781029959, VM::ImageFree },    // waba/fx/Image_setPixels_(I[IIII[B)V    { 781038420, VM::ImageSetPixels },    // waba/fx/Image__nativeLoad_(Ljava/lang/String;)V    { 781052768, VM::ImageLoad },    // waba/fx/Sound_beep_()V    { 940413127, VM::SoundBeep },    // waba/fx/Sound_tone_(II)V    { 940424137, VM::SoundTone },    // waba/sys/Time__nativeCreate_()V    { 969766992, VM::TimeCreate },    // waba/io/Socket__nativeCreate_(Ljava/lang/String;I)V    { 1317941923, VM::SocketCreate },    // waba/io/Socket_readBytes_([BII)I    { 1317952272, VM::SocketRead },    // waba/io/Socket_writeBytes_([BII)I    { 1317961425, VM::SocketWrite },    // waba/io/Socket_setReadTimeout_(I)Z    { 1317972178, VM::SocketSetReadTimeout },    // waba/io/Socket_close_()Z    { 1317974088, VM::SocketClose },    // waba/io/Socket_isOpen_()Z    { 1317979721, VM::SocketIsOpen },    // waba/ui/Window__nativeCreate_()V    { 1406040144, VM::WindowCreate },    // waba/io/Catalog_listCatalogs_()[Ljava/lang/String;    { 1661930913, VM::CatalogListCatalogs },    // waba/io/Catalog_addRecord_(I)I    { 1661934285, VM::CatalogAddRecord },    // waba/io/Catalog_skipBytes_(I)I    { 1661937741, VM::CatalogSkipBytes },    // waba/io/Catalog__nativeCreate_(Ljava/lang/String;I)V    { 1661940387, VM::CatalogCreate },    // waba/io/Catalog_readBytes_([BII)I    { 1661950736, VM::CatalogRead },    // waba/io/Catalog_deleteRecord_()Z    { 1661951823, VM::CatalogDeleteRecord },    // waba/io/Catalog_setRecordPos_(I)Z    { 1661957200, VM::CatalogSetRecordPos },    // waba/io/Catalog_getRecordSize_()I    { 1661957392, VM::CatalogGetRecordSize },    // waba/io/Catalog_resizeRecord_(I)Z    { 1661958480, VM::CatalogResizeRecord },    // waba/io/Catalog_writeBytes_([BII)I    { 1661959889, VM::CatalogWrite },    // waba/io/Catalog_getRecordCount_()I    { 1661964433, VM::CatalogGetRecordCount },    // waba/io/Catalog_close_()Z    { 1661972552, VM::CatalogClose },    // waba/io/Catalog_isOpen_()Z    { 1661978185, VM::CatalogIsOpen },    // waba/io/Catalog_delete_()Z    { 1661978505, VM::CatalogDelete },    // waba/fx/Graphics_copyRect_(Lwaba/fx/ISurface;IIIIII)V    { 2182088099, VM::GraphicsCopyRect },    // waba/fx/Graphics_clearClip_()V    { 2182090124, VM::GraphicsClearClip },    // waba/fx/Graphics_setFont_(Lwaba/fx/Font;)V    { 2182094808, VM::GraphicsSetFont },    // waba/fx/Graphics_setDrawOp_(I)V    { 2182095437, VM::GraphicsSetDrawOp },    // waba/fx/Graphics_setClip_(IIII)V    { 2182096846, VM::GraphicsSetClip },    // waba/fx/Graphics_setColor_(III)V    { 2182099790, VM::GraphicsSetColor },    // waba/fx/Graphics_getClip_(Lwaba/fx/Rect;)Lwaba/fx/Rect;    { 2182102117, VM::GraphicsGetClip },    // waba/fx/Graphics_fillRect_(IIII)V    { 2182103055, VM::GraphicsFillRect },    // waba/fx/Graphics_drawLine_(IIII)V    { 2182103119, VM::GraphicsDrawLine },    // waba/fx/Graphics_translate_(II)V    { 2182103502, VM::GraphicsTranslate },    // waba/fx/Graphics_drawDots_(IIII)V    { 2182104271, VM::GraphicsDrawDots },    // waba/fx/Graphics_drawText_([CIIII)V    { 2182115089, VM::GraphicsDrawChars },    // waba/fx/Graphics__nativeCreate_()V    { 2182117456, VM::GraphicsCreate },    // waba/fx/Graphics_drawCursor_(IIII)V    { 2182118865, VM::GraphicsDrawCursor },    // waba/fx/Graphics_setClipRect_(IIII)V    { 2182122322, VM::GraphicsSetClip },    // waba/fx/Graphics_free_()V    { 2182124103, VM::GraphicsFree },    // waba/fx/Graphics_fillPolygon_([I[II)V    { 2182132179, VM::GraphicsFillPolygon },    // waba/fx/Graphics_drawText_(Ljava/lang/String;II)V    { 2182138655, VM::GraphicsDrawString },    // waba/sys/Convert_toInt_(Ljava/lang/String;)I    { 2387628570, VM::ConvertStringToInt },    // waba/sys/Convert_toIntBitwise_(F)I    { 2387636560, VM::ConvertFloatToIntBitwise },    // waba/sys/Convert_toString_(C)Ljava/lang/String;    { 2387649437, VM::ConvertCharToString },    // waba/sys/Convert_toFloatBitwise_(I)F    { 2387649554, VM::ConvertIntToFloatBitwise },    // waba/sys/Convert_toString_(F)Ljava/lang/String;    { 2387649629, VM::ConvertFloatToString },    // waba/sys/Convert_toString_(I)Ljava/lang/String;    { 2387649821, VM::ConvertIntToString },    // waba/sys/Convert_toString_(Z)Ljava/lang/String;    { 2387650909, VM::ConvertBooleanToString },    // waba/fx/SoundClip_play_()Z    { 2584844359, VM::SoundClipPlay },    // waba/ui/MainWindow__nativeCreate_()V    { 3037886544, VM::MainWinCreate },    // waba/ui/MainWindow_exit_(I)V    { 3037899400, VM::MainWinExit },    // waba/ui/MainWindow__setTimerInterval_(I)V    { 3037919317, VM::MainWinSetTimerInterval },    // waba/io/SerialPort_readCheck_()I    { 3046245644, VM::SerialPortReadCheck },    // waba/io/SerialPort_readBytes_([BII)I    { 3046267664, VM::SerialPortRead },    // waba/io/SerialPort_writeBytes_([BII)I    { 3046276817, VM::SerialPortWrite },    // waba/io/SerialPort_setReadTimeout_(I)Z    { 3046287570, VM::SerialPortSetReadTimeout },    // waba/io/SerialPort_close_()Z    { 3046289480, VM::SerialPortClose },    // waba/io/SerialPort_setFlowControl_(Z)Z    { 3046290066, VM::SerialPortSetFlowControl },    // waba/io/SerialPort_isOpen_()Z    { 3046295113, VM::SerialPortIsOpen },    // waba/io/SerialPort__nativeCreate_(IIIZI)V    { 3046299605, VM::SerialPortCreate },    // waba/fx/FontMetrics_getTextWidth_(Ljava/lang/String;)I    { 3511879649, VM::FontMetricsGetStringWidth },    // waba/fx/FontMetrics_getCharWidth_(C)I    { 3511903952, VM::FontMetricsGetCharWidth },    // waba/fx/FontMetrics__nativeCreate_()V    { 3511908432, VM::FontMetricsCreate },    // waba/fx/FontMetrics_getTextWidth_([CII)I    { 3511921619, VM::FontMetricsGetCharArrayWidth },    };*/void callDestroyFunc(ObjDestroyFunc_i func, VM* vm, WObject obj)    {    /* I generated this big ugly case statement using the following    UNIX shell script.  First, I copied all the stuff between the braces    in classHooks[] to a file called junk, then ran:    grep "VM::" junk | awk '{print $3'} - | awk -F: '{print $3}' - | awk -F, '{print $1;}' - | awk 'BEGIN{s=0}{print "        case " s ": vm->" $1 "(obj); break;"; s += 1; }' - > junk.out    ... the result is in junk.out, which is pasted here.    This is lots smaller than the switch statement for callNativeFunc,    so you can probably just hand-hack it.*/	PRINTSTR("==callDestroyFunc==");    switch(func)        {	// no case 0 -- that's the "no ObjDestroyFunc" value, same as NULL was previously.        case 1: vm->WindowDestroy(obj); break;        case 2: vm->ImageDestroy(obj); break;        case 3: vm->GraphicsDestroy(obj); break;        case 4: vm->SerialPortDestroy(obj); break;        case 5: vm->SocketDestroy(obj); break;        case 6: vm->CatalogDestroy(obj); break;        case 7: vm->RefDestroy(obj); break;        }    }/* Generated using:grep "VM::" junk | awk '{print $2 ":" $3 ":" $4;}' - | awk -F: '{print $1 " " $4 " " $5;}' - | awk -F, '{print $1 " " $2 " " $3;}' - | awk 'BEGIN{s=0}{print "    { " $1 ", " s ", " $3  "},"; s+=1;}' - */const ClassHook classHooks[] =    {    { "waba/ui/Window", 1, 2},    { "waba/fx/Image", 2, 2},    { "waba/fx/Graphics", 3, 11},    { "waba/io/SerialPort", 4, 2},    { "waba/io/Socket", 5, 2},    { "waba/io/Catalog", 6, 1},    { "newton/Ref", 7, 1},    { NULL, 0, 0 }    };        /*const ClassHook classHooks[] =	{	{ "waba/fx/Window", VM::WindowDestroy, 1 },	{ "waba/fx/Image", VM::ImageDestroy, 1 },	{ "waba/fx/Graphics", VM::GraphicsDestroy, 9 },	//{ "waba/fx/Graphics", NULL, 11},	//{ "waba/fx/Image", VM::ImageDestroy, 1 },	//{ "waba/io/Catalog", VM::CatalogDestroy, 7 },	//{ "waba/io/Socket", VM::SocketDestroy, 2 }, 	//{ "waba/io/SerialPort", VM::SerialPortDestroy, 2 }, 	{ NULL, NULL }	};*/